<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>The index blog</title>
    <url>/2023/01/15/Indexs/My-first-bolg/</url>
    <content><![CDATA[<p>This is the introduction and index of my blog, and it’s for testing the <code>Hexo</code>.</p>
<h2 id="My-plans-and-projects"><a href="#My-plans-and-projects" class="headerlink" title="My plans and projects"></a>My plans and projects</h2><p>This is the list of my plans and projects.</p>
<p>Some of them would be written in Chinese and some of them would be written in English(awful English).</p>
<ul>
<li><p>A magnetic field sensor based on a 3D printer(3D 位移平台)</p>
</li>
<li><p>Study the spectrum of maxi1820(maxi1820)</p>
</li>
<li><p>Make and improve a python library to process the uncertainty</p>
</li>
<li><p>Some other useful tools</p>
</li>
</ul>
<h2 id="My-study-plans"><a href="#My-study-plans" class="headerlink" title="My study plans"></a>My study plans</h2><p>Also, I need to learn some interesting thing, the list can be the index of my notes</p>
<ul>
<li><p>Controlling system with python(Python设计控制系统)</p>
</li>
<li><p>Machine learning(机器学习)</p>
</li>
<li><p>Analyzing X-ray spectrum from BH(X-ray spectrum)</p>
</li>
<li><p>Statics(统计学)</p>
</li>
</ul>
<h2 id="My-logs"><a href="#My-logs" class="headerlink" title="My logs"></a>My logs</h2><p>Sometimes there are interesting logs in my project and study, most of them may be about Python and Linux.</p>
]]></content>
      <tags>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title>位移平台程序应当满足的功能</title>
    <url>/2023/01/16/3Dmover/3Dmove1/</url>
    <content><![CDATA[<h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>预想中的程序应该实现以下几个功能:</p>
<ol>
<li>对路径的规划:获得带测量点,<em>避免和已有待测物体发生撞车</em>,<em>智能更新测量点</em>(类似于绘制函数的时候梯度变化大的点多,梯度变化小的点少)</li>
<li>移动命令的执行:<del>与grbl进行通讯实现移动(通过传输GCode的方式),实时获知位置</del>,获知出现撞车或者达到极限等状况,自定义原点</li>
<li>数据的获取与处理:<del>原始数据获取(厂家有提供库)</del>,<em>数据不确定度估算与定标</em>(需要结合技术手册以及探头设计进一步研究)</li>
<li>中央控制程序:<del>将电机等的状态显示出来</del>,3D显示路径以及测量结果</li>
</ol>
<h2 id="为何不使用如kliment这样的程序"><a href="#为何不使用如kliment这样的程序" class="headerlink" title="为何不使用如kliment这样的程序"></a>为何不使用如kliment这样的程序</h2><p>因为<code>kliment</code>是设计给3D打印机而非我们所使用的测量装置的</p>
<p>其优点有:</p>
<ol>
<li>具有较为完善的各种错误的处理功能(但是grbl不支持)</li>
<li>界面比较漂亮</li>
<li>支持stl文件的导入等</li>
</ol>
<p>但是我目前已经实现了gcode的传输以及实时的位置获取,<code>klimenr</code>可以为未来改进自定义原点或检查异常情况提供灵感,但是没有必要依赖其实现</p>
<p>主要原因在于<code>klimenr</code>缺乏开发文档,研究其源码会非常困难,并且其完全依赖于下位机的gcode功能(例如温度获取),但是对于我们现在的目标这么做并不切合实际.那么这样会导致可能存在解析gcode的”中间商”,将问题弄得过于复杂.</p>
<p>我的观点在于目前几个部分的模块分别开发(目前已经实现了一个可以控制grbl移动以及控制AD卡读取数据的一个控制程序),剩余的部分自行开发(当然像处理3D模型这样的问题究竟是使用像VTK这样的工具还是像使用slicer这样的小型工具还有待研究)</p>
<p>而最后的图形界面(虽然现在有一个基于CUI的”伪”图形界面),这个的制作属于比较细枝末节的问题(甚至最后可以扔给Labview解决),我们现在就不考虑了</p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>程序规划</tag>
      </tags>
  </entry>
  <entry>
    <title>3D位移平台路径开发器记录1</title>
    <url>/2023/01/16/3Dmover/3Dmove2/</url>
    <content><![CDATA[<p>完成路径规划的<code>RoutePlanner</code>类,实现从点集(<code>datapoints</code>)到路径命令(<code>routecmd</code>)的转换</p>
<h3 id="使用算法"><a href="#使用算法" class="headerlink" title="使用算法"></a>使用算法</h3><p>使用的算法参考自<a href="https://zem12345678.github.io/2019/03/14/%E4%BD%BF%E7%94%A8%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%EF%BC%88TSP%EF%BC%89%E9%97%AE%E9%A2%98">参考资料</a>,我们的问题是一个旅行商问题,因此没有一个多项式时间内可以实现的最优算法</p>
<p>但是我们需要注意到,我们所面临的图是一个完全图,并且近似满足三角不等式.因此可以使用最小生成树的方法得到近似解,其结果不会大于最优解的两倍</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于未来需要保留避障措施,但是避障之后的路径可以用一个新的路径代替,因此是通过<strong>修改路径获取函数实现</strong>(为未来预留接口)</p>
<blockquote>
<p>这样做可能导致三角不等式不成立,但是影响应该不大</p>
</blockquote>
<p><code>datapoints</code>属性在修改时会重新计算<code>route</code>,因此<em>不要频繁修改点集</em></p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/17/Indexs/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>处理3D模型</title>
    <url>/2023/01/16/3Dmover/3Dmoveslice/</url>
    <content><![CDATA[<p>为了实现通过用户给的3D模型实现避障功能的路径规划,我们采取首先对模型进行切片,然后再通过修改路径长度和两点之间路径获取的函数完成</p>
<h2 id="对于meshcut库的使用"><a href="#对于meshcut库的使用" class="headerlink" title="对于meshcut库的使用"></a>对于<code>meshcut</code>库的使用</h2><p>可以实现3D建模处理的库有很多,但如果仅仅是想要一个切面就将<code>vtk</code>搬出来未免就有一点大材小用了,通过寻找,我找到了一个<code>meshcut</code>库,其可以将<code>stl</code>文件和定义的平面求得交线.</p>
<p><a href="https://github.com/julienr/meshcut">meshcut库</a>的开发主页</p>
<p>下面是使用<code>meshcut</code>库实现对一个3D模型切割的效果图</p>
<p><img src="/2023/01/16/3Dmover/3Dmoveslice/42.png" alt="42"></p>
<p>而其所使用的源码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> stl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> meshcut</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_mesh</span>(<span class="params">m:stl.mesh.Mesh</span>):<span class="comment">#从stl文件中创建mesh</span></span><br><span class="line">    <span class="comment"># Flatten our vert array to Nx3 and generate corresponding faces array</span></span><br><span class="line">    verts = m.vectors.reshape(-<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    faces = np.arange(<span class="built_in">len</span>(verts)).reshape(-<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    verts, faces = meshcut.merge_close_vertices(verts, faces)</span><br><span class="line">    <span class="keyword">return</span> meshcut.TriangleMesh(verts,faces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    m=stl.mesh.Mesh.from_file(<span class="string">&quot;up.stl&quot;</span>)</span><br><span class="line">    mesh=create_mesh(m)</span><br><span class="line"></span><br><span class="line">    i=<span class="number">1</span></span><br><span class="line">    z=<span class="number">1</span><span class="comment">#z坐标</span></span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">0</span>):<span class="comment">#在没有交点是会报错,程序自动终止</span></span><br><span class="line">        plane_origin=np.array([<span class="number">0</span>,<span class="number">0</span>,z])</span><br><span class="line">        plane_n=np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">        plane=meshcut.Plane(plane_origin,plane_n)<span class="comment">#创建平面</span></span><br><span class="line"></span><br><span class="line">        p=meshcut.cross_section_mesh(mesh,plane)<span class="comment">#求解相交部分多边形</span></span><br><span class="line">        x=p[<span class="number">0</span>][:,<span class="number">0</span>]</span><br><span class="line">        x=np.hstack([x,np.array(x[<span class="number">0</span>])])</span><br><span class="line">        y=p[<span class="number">0</span>][:,<span class="number">1</span>]</span><br><span class="line">        y=np.hstack([y,np.array(y[<span class="number">0</span>])])</span><br><span class="line">        plt.plot(x,y)</span><br><span class="line">        plt.savefig(<span class="string">&quot;&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(z))</span><br><span class="line">        z=z+<span class="number">1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="判断一条线是否与多边形相交"><a href="#判断一条线是否与多边形相交" class="headerlink" title="判断一条线是否与多边形相交"></a>判断一条线是否与多边形相交</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>接下来我们来讨论一下关于碰撞检测这一部分的内容.</p>
<p>多边形是由有限个点首尾相连而成的,那么假如一条线段与多边形相交,那么其必然与多边形的至少一条边相交.因此问题就转化为<em>判断一条线段是否与一个线段集中线段相交</em>.</p>
<p>而对于判断两线段是否相交的方法,记第一条线段两点为$A_1,A_2$,第二条线段两点为$B_1,B_2$,如果从线段一指向线段二某点(通常使用某个端点)的两个矢量与线段二的叉乘异号,表明$A_1,A_2$分别位于第二条线段两侧.同理,可以判断$B_1,B_2$是否位于第一条线段两侧.如果两个条件同时满足,那么就可以说明线段相交.</p>
<p>这一手段<a href="https://blog.csdn.net/zhouzi2018/article/details/81871875">参考资料</a></p>
<blockquote>
<p>特殊情况,判断点是否在多边形内,可以用相似的方法,通过过该点做一条射线,然后统计相交点数,如果相交点数为偶数,则点在多边形内,否则在多边形外</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在实现这个问题的同时,需要考虑到Python在处理大量的<code>for</code>循环时效率非常低下,因此需要对操作进行向量化处理.</p>
<p>假定$A_x,A_y,B_x,B_y$为$n,n,m,m$维列向量,定义$C_{ij}$的值等于$A_{i}\times B_{j}$为行列式的值,根据线性代数相关知识,我们可以得到$C&#x3D;A_xB^T_y-A_yB_x^T$</p>
<blockquote>
<p>如此操作时需要注意对<code>array</code>进行<code>reshape</code></p>
</blockquote>
<p>下面展示了实现矢量集叉乘和判断线段集是否相交的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_cross</span>(<span class="params">a: np.array, b: np.array</span>):</span><br><span class="line">        <span class="comment"># 计算两个二维向量集的叉乘</span></span><br><span class="line">        ax = a[:, <span class="number">0</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        ay = a[:, <span class="number">1</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        bx = b[:, <span class="number">0</span>].reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        by = b[:, <span class="number">1</span>].reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.dot(ax, by)-np.dot(ay, bx)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_crossing</span>(<span class="params">lines1: np.array, lines2: np.array</span>):</span><br><span class="line">        begs1 = lines1[:, <span class="number">0</span>, :]</span><br><span class="line">        begs2 = lines2[:, <span class="number">0</span>, :]</span><br><span class="line">        ends1 = lines1[:, <span class="number">1</span>, :]</span><br><span class="line">        ends2 = lines2[:, <span class="number">1</span>, :]</span><br><span class="line">        l1 = ends1-begs1</span><br><span class="line">        l2 = ends2-begs2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查线2是否分隔线1</span></span><br><span class="line">        v1 = begs2-begs1</span><br><span class="line">        v2 = begs2-ends1</span><br><span class="line">        c1 = calc_cross(v1, l2)</span><br><span class="line">        c2 = calc_cross(v2, l2)</span><br><span class="line">        c = c1*c2  <span class="comment"># 计算两矩阵各个元素相乘(比较同号异号)</span></span><br><span class="line">        bca = c &lt; <span class="number">0</span>  <span class="comment"># 分割线1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查线1是否分隔线2</span></span><br><span class="line">        v1 = begs1-begs2</span><br><span class="line">        v2 = begs1-ends2</span><br><span class="line">        c1 = calc_cross(v1, l1)</span><br><span class="line">        c2 = calc_cross(v2, l1)</span><br><span class="line">        c = c1*c2  <span class="comment"># 计算两矩阵各个元素相乘(比较同号异号)</span></span><br><span class="line">        bcb = c &lt; <span class="number">0</span>  <span class="comment"># 分割线2</span></span><br><span class="line"></span><br><span class="line">        bc = np.<span class="built_in">all</span>([bca, bcb], axis=<span class="number">0</span>)  <span class="comment"># 同时分割</span></span><br><span class="line">        <span class="keyword">return</span> bc  <span class="comment"># 第i行第j列元素判断lines1的第i根线与lines2的第j根线是否相交</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候我意识到了一个问题:在实际的移动过程中,z轴的移动无法控制,因此需要在路径规划的过程中对z轴进行单独处理</p>
<p>因此:在每一次移动时,首先移动z轴,然后就可以理解为平面内运动</p>
</blockquote>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>蚁群算法分析</title>
    <url>/2023/02/09/3Dmover/ant/</url>
    <content><![CDATA[<p>之前提到过三维路径的查找的方法,使用A*寻找,但是在找完之后就面临一个问题,如何挑选出一个合适的路径.<br>很明显,我们这里的这个问题是一个旅行商问题,这玩意不可能有一个”完美”的算法.<br>之前我所使用的方法是使用基于贪心算法的最小生成树进行路径查找但是这种方法的结果只能保证路径总代价不超过2倍.<br>原本我想想只需要无脑调库就可以了,但是一查,虽然有一个民间制作的蚁群优化算法,但是那些都是基于python的python库,完全没法用.</p>
<blockquote>
<p>虽然你可能会觉得上面那句话很怪,但如果你了解过python的运行效率,那么就会知道这么做就是自寻死路</p>
</blockquote>
<p>所以我看来又得”自己造轮子”,使用C++处理蚁群算法</p>
<span id="more"></span>

<h2 id="蚁群算法机理"><a href="#蚁群算法机理" class="headerlink" title="蚁群算法机理"></a>蚁群算法机理</h2><p>这里的机理我主要参考的<a href="https://zhuanlan.zhihu.com/p/151442866">这篇知乎文章</a>,在这里我简单介绍以下(当然也包括我的一些实现细节,便于未来查找错误)</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>蚁群算法的基本处理方式是在原本的类似于贪心算法(但又不完全贪心)上添加了一个<em>信息素矩阵</em>,并且选取的途径并不是”决定性”的选取,而是概率选取,越符合要求的选取到的概率越高.<br>同时这个信息素的产生和变化遵循以下条件:</p>
<ol>
<li>不同蚂蚁产生信息素相互线性叠加</li>
<li>一只蚂蚁在所有路径上分泌的信息素总和为定值</li>
<li>信息素在每次迭代后都会挥发一部分</li>
</ol>
<p>使用这种方法实现结果</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先是概率的计算,在每一只蚂蚁选择下一个点(从$i$到$j$)时,每一个点的概率为</p>
<p>$$p_{ij}&#x3D;\frac{t_{ij}^\alpha r_{ij}^{\beta}}{\sum_j t_{ij}^\alpha r_{ij}^{\beta}}$$<br>其中$t_{ij}$为从$i$到$j$的信息素含量,而$r_{ij}$则为基于贪心的路径选择$r_{ij}&#x3D;\frac{1}{L_{ij}},L_{ij}$为这两点之间的距离,具体如何通过$p_{ij}$来进行选取,我们采用的是”轮盘赌”的方法,可以参考<a href="https://blog.csdn.net/weixin_39068956/article/details/105121469">这篇文章</a></p>
<p>而每次迭代之后,对于$t_{ij}$其变化为<br>$$t_{ij}&#x3D;pt_{ij}+\sum \frac{G}{L_i}$$<br>其中,$p$为挥发后剩余量,$G$为常数,$L_i$为经过这个边的第$i$个个体总路径长度.<br>而在达到迭代次数后,输出计算得到的结果.</p>
<blockquote>
<p>关于$G$的选取和初始化<br>我们面临一个初始化的问题,就是在第一次迭代之前,如何选取$t_{ij}$,我目前的做法是将其全部初始化为1,而令$G&#x3D;n\bar{L_{ij}}$,即边长平均值乘以$n$,(类似于平均边长)</p>
</blockquote>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>目前我的C++程序库使用的结构定义了一个<code>MapSearcher</code>类,其构造函数确定各个点间的连接矩阵<code>road_mat</code>,每个点的蚂蚁数<code>ant_num_per_point</code>,保留率<code>p</code>,以及$\alpha,\beta$,同时,为了保证结果的可重复性,其可以指定随机数种子.</p>
<p>在初始化后,<code>one_iter</code>方法迭代一次,并且返回最佳结果的总长度</p>
<p>类中有三个只读属性<code>best_now</code>保存目前全局最佳结果总长度,<code>best_route</code>返回这一结果所对应的路径(以<code>list</code>形式返回),<code>tmat</code>保存系统目前的信息素矩阵</p>
<h2 id="目前效果"><a href="#目前效果" class="headerlink" title="目前效果"></a>目前效果</h2><p>下面展示了50个随机点$\alpha&#x3D;2$,$\beta&#x3D;1$的计算处理的收敛图像<br><img src="/2023/02/09/3Dmover/ant/0.95_2_1_1.png" alt="Figure_1.png"><br>可以看出来200次迭代有较好的收敛能力.</p>
<p>但是我们为了更好研究结果与<strong>实际的</strong>最小相差多少,我们采用网格点进行测试<br>我们在网格上按照正方形排布均匀放49个点,然后经过迭代,得到了以下结果<br><img src="/2023/02/09/3Dmover/ant/Figure_1.png" alt="Figure_1.png"><br>其路径为<br><img src="/2023/02/09/3Dmover/ant/Figure_2.png" alt="Figure_2.png"><br>可以看出来,其实这种方法得到的结果与理论极限48有着较为明显的差距,还需要进一步优化</p>
<h2 id="可能存在的一些bug"><a href="#可能存在的一些bug" class="headerlink" title="可能存在的一些bug"></a>可能存在的一些bug</h2><p>似乎现在如果<code>p</code>太小或者$\alpha$太大的话,在迭代过程中可能出现概率为0的情况,因此如果库内无法正常选点触发异常,将输出此时这个节点上的总路径和</p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>程序规划</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划器设计 升级版</title>
    <url>/2023/02/07/3Dmover/astar/</url>
    <content><![CDATA[<p>在上一篇文章中我曾经提到有一种较好的替代算法,A*算法来处理存在障碍物的情况下对路径的寻找</p>
<p>不过这种算法存在一个限制条件,就是其必须在网格内执行,而不是矢量(这看起来很正常,因为矢量的算法可以说几乎找不到)</p>
<p>同时由于这种算法的性质,其运算过程是<strong>难以矢量化的</strong>,所以直接拿python去跑会变得非常让人难以接受,因此我们必须拿C++来实现这个功能</p>
<p>具体而言,我们可以将这个问题转化为:<strong>网格化-&gt;A*寻路-&gt;矢量化</strong>三步进行</p>
<span id="more"></span>

<h2 id="网格化"><a href="#网格化" class="headerlink" title="网格化"></a>网格化</h2><p>在进行网格化的过程中,我是首先制作了一个<code>Mesh</code>类,这个类中会储存已知起点和终点以及密度的网格.然后其中有一个方法,可以将<strong>现实坐标</strong>转化为<strong>网格坐标</strong></p>
<p>之后,这个类提供一个接口,可以将<strong>首尾不相连</strong>的多边形转换为网格,其原理就是先转换首末端点,然后用<code>Bresenham</code>算法对直线进行绘制(这种方法避免浮点运算,效率较高)</p>
<p>这样就实现了对于坐标的网格化.</p>
<blockquote>
<p>&#x3D;&#x3D;索引问题&#x3D;&#x3D;</p>
<p>由于在C中,数组的索引形式与<code>Eigen</code>(一个C++扩展,支持线性代数运算,可以参考<a href="https://eigen.tuxfamily.org/">这个网页</a>)相同,都是先行后列的索引</p>
<p>因此我们会看到像<code>a[y][x]</code>或是<code>a(y,x)</code>这样的索引</p>
<p>在编写接口的过程中,需要多加小心</p>
<p><em>现在看好像并没有什么很显著的问题</em></p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;网格化的优化&#x3D;&#x3D;</p>
<p>这种网格化提供了网格”生长”的可能性,例如在实际的操作中,我们知道机器必然不能精确的沿着边缘走,但是根据这一算法得到的结果,很多就是沿着边缘进行的</p>
<p>这个时候如果我们已经进行了网格化,就可以实现较为容易的计算机图形学中的膨胀操作</p>
<p>这里也许可以参考<a href="https://blog.csdn.net/qq_33732358/article/details/88725971">这篇文章</a></p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;向下舍入问题&#x3D;&#x3D;</p>
<p>我们的计算是向下舍入的,即$a_x&#x3D;(x-x_{beg})&#x2F;\Delta x$一式向下舍入,那么我们在将网格倒推时,就需要加上0.5,减小误差</p>
</blockquote>
<h2 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h2><p>接下来就是我们讨论的A*搜索部分,实际上这一部分的内容网上都有,我就在这里给大家大略复述一下流程</p>
<ol>
<li><p>创建一个<code>open_set</code>和一个<code>close_set</code></p>
</li>
<li><p>从起点开始,将设定一个代价值(这个后面会讨论),然后将起点添加进<code>open_set</code>中</p>
</li>
<li><p>开始循环,直到达到终点:</p>
<ol>
<li>取出<code>open_set</code>中代价值最低的点,并将其加到<code>close_set</code>中</li>
<li>在这个点周围寻找满足条件(可达且未经过的点),并将这些点加到<code>open_set</code>中</li>
</ol>
</li>
<li><p>如果达到终点,则回溯找到来时的路径,并返回</p>
</li>
<li><p>如果没有找到终点,那么终点不可达(有错误)</p>
</li>
</ol>
<blockquote>
<p>&#x3D;&#x3D;关于代价函数&#x3D;&#x3D;</p>
<p>我目前是使用曼哈顿距离作为代价函数进行计算实际上用欧几里得距离什么的也可以(但是计算效率会下降)</p>
<p>但是使用的代价函数必须满足一个条件:<strong>一个点的代价必须是唯一的</strong>(可以不同点有相同代价)</p>
<p>这与我们在算法中采用的<code>set</code>有关,如果出现一个点有不同代价,那么比较函数将无法抵达红黑树树叶,然后就会出错</p>
<p>必须满足传递原则:若a&gt;b,b&gt;c则a&gt;c</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;对于优化&#x3D;&#x3D;</p>
<p>上面描述的是一般的代价函数,但是我们这里比较特殊,在进行计算前,我们需要对所有点进行初始化,此时一个起点对应的就不仅仅是一个终点了,也许可以极大的提高运算效率</p>
</blockquote>
<h2 id="反网格化"><a href="#反网格化" class="headerlink" title="反网格化"></a>反网格化</h2><p>这里就相当于是网格化的逆过程,我也不必过多解释,但是要注意最后为了减小误差,需要加上半个步长</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>下面是我用python调取C++库采用曼哈顿距离作为代价函数的运行结果,蓝色线为障碍物边界,红色线为规划得到的路径,其效果非常可观.</p>
<p><img src="/2023/02/07/3Dmover/astar/outfig.png" alt="outfig"></p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>程序规划</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>在使用CNCSheld和GRBL的一些坑</title>
    <url>/2023/02/16/3Dmover/cncsheld/</url>
    <content><![CDATA[<p>在安装限位开关时,需要注意由于版本不对应,需要<strong>修改z限位开关接线</strong>,具体可以看<a href="https://github.com/grbl/grbl/issues/1128">这篇文章</a></p>
<p>GRBL的设定,应当参考<a href="https://www.diymachining.com/downloads/GRBL_Settings_Pocket_Guide_Rev_B.pdf">这篇文档</a></p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
      </tags>
  </entry>
  <entry>
    <title>对控制驱动的改进</title>
    <url>/2023/01/17/3Dmover/new-motor-driver/</url>
    <content><![CDATA[<p>之前在制作控制程序的时候,有一些不够优雅的地方,今天决定对这些问题进行修正</p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>之前的工作是通过不断地询问实现的,我们要实现<strong>与串口交互的部分不断询问,而上层则是通过事件去驱动</strong>,这样可以极大程度简便工作流程,并且为未来处理碰撞等问题提供解决方案.</p>
<h3 id="对于电机"><a href="#对于电机" class="headerlink" title="对于电机"></a>对于电机</h3><p>电机输入一个<code>MoveControlCallbacksBase</code>,其中规定了三种可能的情况:状态更新,碰撞和坐标更新</p>
<blockquote>
<p>这些函数只有在值改变的时候才会调用</p>
</blockquote>
<p>这样的话<code>MoveControl</code>类只留下了一个接受命令并阻塞运行的<code>run</code>方法(在阻塞运行时,坐标会更新),并且保留了两个公开可修改属性</p>
<ol>
<li><code>refreshtime</code>:控制多久刷新一次坐标信息</li>
<li><code>feed_rate</code>:控制移动速度</li>
</ol>
<h3 id="对于控制器"><a href="#对于控制器" class="headerlink" title="对于控制器"></a>对于控制器</h3><p>计划将控制器的构造函数的参数<strong>不出现</strong>有关移动控制和测量控制的函数,这样可以保证更好的封装</p>
<p>然后和电机保持一样的<strong>回调控制方式</strong></p>
<p>对于控制器,则保留四种情况的回调:</p>
<ol>
<li><code>status_refresh_call</code>控制器状态刷新</li>
<li><code>coordinate_refresh_call</code>坐标状态刷新</li>
<li><code>measure_refresh_call</code>测量结果刷新</li>
<li><code>no_command_call</code>无后续命令</li>
</ol>
<p>并且保留了两个公开方法<code>add_cmd</code>和<code>change_motor_settings</code></p>
<p>属性中保留<code>cmd_list</code>进行读取待进行指令,<code>cmd_now</code>为当前执行指令</p>
<p>以及<code>move_start</code>控制是否开始测量</p>
<h4 id="1-31更新"><a href="#1-31更新" class="headerlink" title="1.31更新"></a>1.31更新</h4><p>如果单纯的使用一个<code>cmd</code>来同时管理电机,测量和显示,这无疑是非常浪费的,而且这样操作如果未来需要修改命令格式以支持其他功能也是非常不妥当的,因此,我们需要对<code>cmd</code>进行预处理操作.</p>
<p>我们添加了一个<code>_cmd_parser</code>指令,这个指令可以<strong>独立地</strong>去处理数据,目前可以处理两类:</p>
<ol>
<li>一次移动,一次测量</li>
<li>多次移动一起,一次测量</li>
</ol>
<p>为了更好的适配2,我们在电机控制中添加了<code>_send_cmd_sync</code>这个命令,可以更高效处理曲折的路径</p>
<p>同时,我们在回调函数中添加了<code>cmd_refresh_call</code>,避免用户去访问<code>cmd_now</code>属性造成混乱</p>
<h2 id="测量驱动修改"><a href="#测量驱动修改" class="headerlink" title="测量驱动修改"></a>测量驱动修改</h2><p>应用了<code>MPS010602</code>,将相关文件打包成一个<code>weel</code>再安装,这个留到另外一篇文章讲</p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>程序规划</tag>
      </tags>
  </entry>
  <entry>
    <title>对已有代码的整理</title>
    <url>/2023/02/14/3Dmover/tidy/</url>
    <content><![CDATA[<p>我将所有的源代码均整理到了github上,之后的改进将会以<code>issue</code>的形式发布,除非非常具有广泛参考价值,不然就不在这里重复了<br><a href="https://github.com/lsyxiaopang/Translation-platform-programming">这个是github地址</a></p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器配置日志1</title>
    <url>/2023/02/12/Linux/linux-server1/</url>
    <content><![CDATA[<p>因为我认为需要搭建一个Linux服务器用于一些用途(比如说,练习使用Linux,或者未来搭建一些网页,以及部署偏微分方程求解器,都是很有用的).<br>我第一步,先在宿舍里面搭建这个服务器,好处是宿舍用的电信宽带拥有<strong>公网ip</strong>,因此我可以在任何地方访问到这台服务器,而且配置相对简单,因为不用使用校园网那样一套专门的认证系统,非常麻烦.<br>但相应的,缺点也非常显著,因为在宿舍,由于安全和考虑,白天必须断电,所以这就产生了定时开关机的问题<br>同时,一个服务器放在公网上总是显得不是那么安全,因此未来我会考虑把它搬到校内(这样的话也可以省去使用easyconnect这种软件)<br>下面是我在2.12日配置Linux服务器遇到的问题.</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>版本: Ubuntu 20.04.5 LTS</p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="连上网"><a href="#连上网" class="headerlink" title="连上网"></a>连上网</h3><p>下面是万恶的网络配置环节,由于安装的Linux-Server是完全没有GUI界面的,结果就网络配置起来非常痛苦.<br>幸好我有网线,可以在网络配置的过程中方便一些,我参考的是[这篇网页][1]对我的有限网络进行配置,但有一点不同,就是在我配置好这个,并且reboot之后,实际上还是没有反应.<br>就在我心灰意冷准备去改为使用无线连接时,在输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>
<p>之后,突然就可以了,我不确定是不是<code>netplan</code>的效果,但是未来也许可以参考</p>
<h3 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h3><p>我这里使用的是TP-LINK路由器提供的外网连接服务”DMZ主机”功能</p>
<blockquote>
<p>我之前发现机器重启之后不能用了,原因是没有分配静态ip</p>
</blockquote>
<h3 id="关于Samba访问"><a href="#关于Samba访问" class="headerlink" title="关于Samba访问"></a>关于Samba访问</h3><p>似乎由于之前的一个病毒,因此445端口的访问被关闭了,所以无法正常连接samba,所以还是得移到校内局域网环境</p>
<h2 id="邮件问题"><a href="#邮件问题" class="headerlink" title="邮件问题"></a>邮件问题</h2><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>这里先颠倒一下顺序,讲一下邮件<br>一开始,我打算使用Linux里面的<code>mail</code>命令,但是不幸的是,<code>mail</code>命令不支持修改邮件的发送者,也就是说我发送的邮件会毫无例外地被移到垃圾箱中,而且还不好移出来(会提示说邮件格式有问题),因此我打算使用<code>mailx</code>来解决问题<br>但是<code>mailx</code>也遇到的相应的问题,那就是对于外来的邮件似乎还是无法解析<br>看起来目前只有两种选项:</p>
<ol>
<li>使用前面已经妥善处理了的python脚本进行邮件处理</li>
<li>就扔到垃圾箱好了<br>这个问题值得去讨论<br>[1]:<a href="https://www.cnblogs.com/wayneliu007/p/10312202.html">https://www.cnblogs.com/wayneliu007/p/10312202.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux功能</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划器设计总结</title>
    <url>/2023/01/31/3Dmover/routeplanner/</url>
    <content><![CDATA[<p>经过数日的鏖战,我算是把一个路径规划程序给写完了,然而,这其中隐藏着不少的问题,以至于虽然这个程序<em>理论上</em>能够给出正确答案,但是实际上由于某些原因完全无法使用,下面我将这个记录下来,以供参考</p>
<span id="more"></span>

<h2 id="程序目的"><a href="#程序目的" class="headerlink" title="程序目的"></a>程序目的</h2><p>因为我们研究的磁场中存在物体,因此不能简单的整个空间到处跑,而是要根据物体的位置,进行<strong>避障</strong>,避完障之后还要<strong>选择一个尽量好的路径</strong></p>
<p>虽然说后者是一个典型的<strong>旅行商问题</strong>,显然是不可能在多项式时间以内完成的,但是我们这里不是算法题,并且实际计算的点并不多,因此并不是最为复杂的</p>
<p>但是前面一个问题就要复杂的多,因为我没有学过计算机图形学,只能自己猜应该怎么做,之后可以查一些别的资料(好像在这一部分可以用<strong>蚁群算法</strong>实现)</p>
<p>下面我就来介绍一下我的这个程序是如何工作的</p>
<h2 id="程序整体框架"><a href="#程序整体框架" class="headerlink" title="程序整体框架"></a>程序整体框架</h2><p>下图展示了这个程序的整体框架</p>
<p><img src="/2023/01/31/3Dmover/routeplanner/struct.png" alt="struct"></p>
<h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><p>这些算法可以参考以下内容</p>
<ol>
<li><a href="https://lsyxiaopang.github.io/2023/01/16/3Dmover/3Dmoveslice/">输入模型与判断点线与模型关系</a></li>
<li><a href="https://lsyxiaopang.github.io/2023/01/16/3Dmover/3Dmove2/">利用最小生成树方法挑选路径</a></li>
</ol>
<p>我们主要要讲的是中间<em>寻找任意两点间路径</em>这一部分实现</p>
<h3 id="寻找任意两点间路径"><a href="#寻找任意两点间路径" class="headerlink" title="寻找任意两点间路径"></a>寻找任意两点间路径</h3><p>寻找任意两点间的路径算法如下</p>
<p><img src="/2023/01/31/3Dmover/routeplanner/findroute.png" alt="findroute"></p>
<p>这中间有一个找顶点<strong>做偏移</strong>的步骤,理论上来说是可以贴边不偏移的,但是实际上你那么做的时候由于凹多边形,两个顶点都在边上时你<strong>难以判断这条线是不是在模型里面</strong></p>
<blockquote>
<p>也许我们可以在线上随机取点判断是否在模型中,但这未免太麻烦</p>
</blockquote>
<p>于是我就用一个小的偏移,在顶点处两线交汇处的角平分线移动一小段距离作为新的顶点</p>
<blockquote>
<p>这种方法偏移太大自然不行,但是偏移太小也会导致点判断错误,这与判断点是否在障碍物内算法有关</p>
</blockquote>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我拿了一个非常简单的模型进行了尝试,结果它硬生生跑了好久,最后扔给我这样一个结果</p>
<p><img src="/ant/Figure_1.png" alt="Figure_1"></p>
<p>红色的是障碍物轮廓,蓝色的是规划的路径</p>
<p>确实其给了我一个<em>可行答案</em>,但是这个答案<em>并不好</em>,而且获得答案的代价<strong>不可接受</strong></p>
<p>我认为主要原因来自于避障规划使用贪心算法,会给出并不一定好的结果,但是并不能用上贪心算法的高效</p>
<p>无疑这个问题还需要查阅更多的资料</p>
]]></content>
      <categories>
        <category>3D位移测量平台设计</category>
      </categories>
      <tags>
        <tag>3D位移平台</tag>
        <tag>算法</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>创建wheels</title>
    <url>/2023/01/19/MPS010602/make-wheel/</url>
    <content><![CDATA[<p>由于在开发3D位移平台时,需要使用到MPS010602,但是因为MPS010602是一个独立的项目(目前还在开发),因此正好学习一下如何打包为wheel库,以及其中遇到的一些问题</p>
<h2 id="源代码整理与-init-py"><a href="#源代码整理与-init-py" class="headerlink" title="源代码整理与__init__.py"></a>源代码整理与<code>__init__.py</code></h2><p>首先,我们要把源代码放置在一个文件夹中,并且需要有一个<code>__init__.py</code></p>
<p><code>__init__.py</code>应当如何编写,<a href="https://zhuanlan.zhihu.com/p/474874811">这篇文章</a>写得很清楚,可以去参考一下</p>
<p>目前我就采用最为简易的方式</p>
<p>如果目录结构是这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---MPS010602(import时所用的名称)</span><br><span class="line">  |-__init__.py</span><br><span class="line">  |-DriverOperator.py</span><br><span class="line">  |-MPSDataType.py</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>那么在<code>__init.py__</code>中,为了方便(不需要引用子文件名),可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from MPS010602.MPSDataType import *</span><br><span class="line">from MPS010602.DriverOperator import *</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意在两个源文件中如果出现了交叉引用,需要修改<code>import</code>格式</p>
</blockquote>
<h2 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a><code>setup.py</code></h2><p>在放置代码的文件夹外,新建一个<code>setup.py</code>,然后填写以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&#x27;mps010602&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.0.0&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;This is a program for MPS-010602&#x27;</span>,</span><br><span class="line">    author=<span class="string">&#x27;songyuli&#x27;</span>,</span><br><span class="line">    author_email=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    package_data=&#123;<span class="string">&#x27;&#x27;</span>:[<span class="string">&#x27;*.dll&#x27;</span>],&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其他部分都很简单,除了两个需要注意的地方:</p>
<ol>
<li>包名称和<code>import</code>时使用的名称不同</li>
<li><code>package_data</code>包含了你希望包含的除了源代码以外的内容(例如说使用的动态链接库)</li>
</ol>
<h2 id="构建与安装"><a href="#构建与安装" class="headerlink" title="构建与安装"></a>构建与安装</h2><p>在这一文件夹下,输入<code>python setup.py bdist_wheel</code>,之后在<code>dist</code>文件夹内可以看见编译好的<code>whl</code>文件,然后文件用<code>pip install</code>可以直接安装</p>
<blockquote>
<p>为了未来后续开发方便,建议一个环境开发,一个环境测试</p>
</blockquote>
<h2 id="其他的一些问题"><a href="#其他的一些问题" class="headerlink" title="其他的一些问题"></a>其他的一些问题</h2><p>我之前在引用动态链接库时遇到问题(因为工作目录发生改变)</p>
<p>因此获取自己当前的位置,可以通过<code>os.path.dirname(os.path.abspath(__file__))</code>访问当前所在文件夹</p>
]]></content>
      <categories>
        <category>MPS010602</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>forbiddenfruit修改ndarray</title>
    <url>/2023/01/19/Pyerror/forbiddenfruit/</url>
    <content><![CDATA[<blockquote>
<p>请注意:在本文中包含了一些<strong>非常危险</strong>的行为,在使用前请务必三思</p>
</blockquote>
<h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><p>因为之前我做过一个处理误差的库的尝试,虽然构造了一个可以自动计算常见误差形式的类,然而这样一个类用在科学计算上的价值却不大,原因就在于这么做没法使用python中的常用数学计算库<code>numpy</code>,那么我就开始动起了歪脑筋:<em>是不是可以通过修改<code>np.ndarray</code>一些函数支持来实现我所想要的功能</em></p>
<p>就以<code>__add__</code>为例,我可以创建一个新函数去替代<code>__add__</code>以实现我的功能.</p>
<p>于是尝试了一下<code>np.ndarray.__add__=myadd</code>,很不幸,解释器告诉我</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: can&#x27;t set attributes of built-in/extension type &#x27;numpy.ndarray&#x27;</span><br></pre></td></tr></table></figure>

<p>我考虑了一下,发现原因是<code>numpy</code>不是由python编写的,因此也无法直接使用python修改动态类型的手段.</p>
<h2 id="解决-forbiddenfruit"><a href="#解决-forbiddenfruit" class="headerlink" title="解决:forbiddenfruit"></a>解决:<code>forbiddenfruit</code></h2><p>正在我表示绝望准备放弃的时候(原本准备用类继承实现功能),突然看到了<a href="https://zhuanlan.zhihu.com/p/345547458">一篇文章</a></p>
<p>在这篇文章,作者介绍了一个神奇又危险的库<code>forbiddenfruit</code>(<a href="https://pypi.org/project/forbiddenfruit/">下载地址</a>),在这个库里,你可以替换python内置的类型</p>
<blockquote>
<p>在文章中也介绍了修改内置类的工作原理,但是仍然无法解决运算符重载的问题</p>
<p>即<code>__add__</code>可以正常被替换,但是<code>+</code>就不行了</p>
</blockquote>
<p>那么下面我可以来演示一下如何替换掉python中list的加法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> forbiddenfruit <span class="keyword">import</span> curse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_list_add</span>():</span><br><span class="line">    old_add=<span class="built_in">list</span>.__add__<span class="comment">#保存原来加法实现</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_add</span>(<span class="params">self,o</span>):</span><br><span class="line">        <span class="keyword">return</span> old_add(old_add(self,[<span class="string">&quot; &quot;</span>]),o)<span class="comment">#新的加法</span></span><br><span class="line">    curse(<span class="built_in">list</span>,<span class="string">&quot;__add__&quot;</span>,new_add)<span class="comment">#替换掉原有加法</span></span><br><span class="line">change_list_add()</span><br></pre></td></tr></table></figure>

<p>然后未来进行列表加法时大家就会惊奇地发现列表两个元素之间总是会有一个空格</p>
<blockquote>
<p>在实际的生产中,这样的做法可能会导致暴力事件的发生</p>
<p>大家也可以试试在python大作业中用这个东西(吃C别怪我)</p>
</blockquote>
]]></content>
      <categories>
        <category>PyError</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>作死行为</tag>
      </tags>
  </entry>
  <entry>
    <title>poetry</title>
    <url>/2023/01/23/Pyerror/poetry/</url>
    <content><![CDATA[<h1 id="利用poetry进行包管理"><a href="#利用poetry进行包管理" class="headerlink" title="利用poetry进行包管理"></a>利用poetry进行包管理</h1><p>今天我突发奇想:</p>
]]></content>
  </entry>
  <entry>
    <title>Linux服务器配置日志2</title>
    <url>/2023/02/14/Linux/linux-server2/</url>
    <content><![CDATA[<p>今天我意识到一个问题,<strong>在物理楼只有靠南的网线接口可以对外开放除22端口外的端口</strong></p>
<h2 id="检测手段"><a href="#检测手段" class="headerlink" title="检测手段"></a>检测手段</h2><p>一般判断服务器的一个端口是否开放,最为简单的方法是使用<code>telnet</code><br>就是<code>telnet 10.92.1.163 445</code>就可以检测其445端口是否开放</p>
]]></content>
      <categories>
        <category>Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux功能</tag>
      </tags>
  </entry>
  <entry>
    <title>关注闭环系统的控制系统设计(下)</title>
    <url>/2023/02/05/control%20system/closecontrol2/</url>
    <content><![CDATA[<h2 id="使用模型匹配法进行增益调整"><a href="#使用模型匹配法进行增益调整" class="headerlink" title="使用模型匹配法进行增益调整"></a>使用模型匹配法进行增益调整</h2><p>所谓<strong>模型匹配法</strong>就是通过指定合适的<strong>标准模型</strong>$\mathcal{M}(s)$尽量的去模拟目标值到控制量的传递函数$\mathcal{G}_{yr}(s)$<br>标准模型往往采用<strong>二项式系数标准型</strong>和<strong>巴特沃斯标准型</strong><br>例如,二阶系统的标准模型为:<br>$$\mathcal{M}(s)&#x3D;\frac{\omega_n^2}{s^2+2\zeta\omega_ns+\omega_n^2}$$<br>当我们将阻尼系数$\zeta$设为$\zeta&#x3D;1$时,就是二项式系数标准型,设为$\zeta&#x3D;\frac{1}{\sqrt{2}}$为巴特沃斯标准型<br>而无阻尼自然振荡频率$\omega_n$为决定快速性的参数,值越大控制系统启动上升越快  </p>
<p>而对于三阶系统,其标准模型为<br>$$\mathcal{M}(s)&#x3D;\frac{\omega_n^3}{s^3+\alpha_2\omega_ns^2+\alpha_1\omega_n^2s+\omega_n^3}$$<br>当$(\alpha_1,\alpha_2)&#x3D;(3,3)$时这个模型为二项式系数标准型,当$(\alpha_1,\alpha_2)&#x3D;(2,2)$时这个模型为巴特沃斯标准型<br>此外,还有<strong>ITAE最小标准型</strong>,其可以使误差绝对值的时间加权积分最小,即<br>$$\int_0^t\tau|e(\tau)|\mathrm{d}\tau$$<br>值最小,可以将$(\alpha_1,\alpha_2)&#x3D;(2.15,1.75)$</p>
<span id="more"></span>

<p>下面展示了各种标准模型效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备工作</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> control <span class="keyword">as</span> ct </span><br><span class="line"><span class="keyword">from</span> control.matlab <span class="keyword">import</span> *</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Simhei&#x27;</span>]  <span class="comment">#显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>    <span class="comment">#显示负号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_generator</span>():</span><br><span class="line">    linestyle=[<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;:&quot;</span>]</span><br><span class="line">    lineid=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> linestyle[lineid] <span class="comment">#* 这个yield用法很有趣,可以学习一下</span></span><br><span class="line">        lineid=(lineid+<span class="number">1</span>)%<span class="built_in">len</span>(linestyle)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax.set_xlabel(args[<span class="number">0</span>])</span><br><span class="line">    fig_ax.set_ylabel(args[<span class="number">1</span>])</span><br><span class="line">    fig_ax.grid(ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">        fig_ax.legend(loc=args[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bodeplot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax[<span class="number">0</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;Gain [dB]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;$\omega$ [rad/s]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;Phase [deg]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">0</span>:</span><br><span class="line">        fig_ax[<span class="number">1</span>].legend(loc=args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">1</span>:</span><br><span class="line">        fig_ax[<span class="number">0</span>].legend(loc=args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,axs=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">ls=line_generator()</span><br><span class="line">omega=<span class="number">10</span></span><br><span class="line">zetas=[<span class="number">1</span>,<span class="number">1</span>/np.sqrt(<span class="number">2</span>)]</span><br><span class="line">labels=[<span class="string">&quot;二项式系数标准型&quot;</span>,<span class="string">&quot;巴特沃斯标准型&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> zeta,label <span class="keyword">in</span> <span class="built_in">zip</span>(zetas,labels):</span><br><span class="line">    p=tf([<span class="number">0</span>,omega**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*zeta*omega,omega**<span class="number">2</span>])</span><br><span class="line">    y,t=step(p,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">    axs[<span class="number">0</span>].plot(t,y,<span class="built_in">next</span>(ls),label=label)</span><br><span class="line">plot_set(axs[<span class="number">0</span>],<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br><span class="line"></span><br><span class="line">alphas=[(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2.15</span>,<span class="number">1.75</span>)]</span><br><span class="line">labels=[<span class="string">&quot;二项式系数标准型&quot;</span>,<span class="string">&quot;巴特沃斯标准型&quot;</span>,<span class="string">&quot;ITAE最小标准型&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> alpha,label <span class="keyword">in</span> <span class="built_in">zip</span>(alphas,labels):</span><br><span class="line">    p=tf([<span class="number">0</span>,omega**<span class="number">3</span>],[<span class="number">1</span>,alpha[<span class="number">0</span>]*omega,alpha[<span class="number">1</span>]*omega**<span class="number">2</span>,omega**<span class="number">3</span>])</span><br><span class="line">    y,t=step(p,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">    axs[<span class="number">1</span>].plot(t,y,<span class="built_in">next</span>(ls),label=label)</span><br><span class="line">plot_set(axs[<span class="number">1</span>],<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​    <img src="/2023/02/05/control%20system/closecontrol2/close_control2_2_0.png" alt="png"><br>​    </p>
<p>而模型匹配法是通过求取从$r$至$y$的传递函数,并且计算$\frac{1}{\mathcal{G}_{yr}(s)}$和$\frac{1}{\mathcal{M}(s)}$的麦克劳林展开式(即在$s&#x3D;0$时的泰勒展开)按照顺序使其一致  </p>
<blockquote>
<p>简单而言就是在前面几阶近似下保持相同(可以假设$s$比较大)<br>例如机械臂模型,我们就可以有以下形式<br>$$\mathcal{G}_{yr}(s)&#x3D;\frac{k_Ps+k_I}{Js^3+(\mu+k_D)s^2+(Mgl+k_P)s+k_I}$$<br>,我们可以利用<code>Sympy</code>库对于其进行展开</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">s=sp.Symbol(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">kp,kd,ki=sp.symbols(<span class="string">&#x27;k_p k_d k_i&#x27;</span>)</span><br><span class="line">mgl,mu,j=sp.symbols(<span class="string">&#x27;mgl mu j&#x27;</span>)</span><br><span class="line"><span class="comment"># sp.init_printing()</span></span><br><span class="line">g=(kp*s+ki)/(j*s**<span class="number">3</span>+(mu+kd)*s**<span class="number">2</span>+(mgl+kp)*s+ki)</span><br><span class="line">sp.series(<span class="number">1</span>/g,s,<span class="number">0</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<p>$\displaystyle \frac{mgl s}{k_{i}} + 1 + s^{2} \left(\frac{k_{d}}{k_{i}} + \frac{\mu}{k_{i}} - \frac{k_{p} mgl}{k_{i}^{2}}\right) + s^{3} \left(\frac{j}{k_{i}} - \frac{k_{d} k_{p}}{k_{i}^{2}} - \frac{k_{p} \mu}{k_{i}^{2}} + \frac{k_{p}^{2} mgl}{k_{i}^{3}}\right) + O\left(s^{4}\right)$</p>
<p>我们可以得到以上结果,与此同时,我们也可以展开$\frac{1}{\mathcal{M}(s)}$的方式得到另外一部分的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=sp.Symbol(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">omega,zeta=sp.symbols(<span class="string">&#x27;omega zeta&#x27;</span>)</span><br><span class="line">m=omega**<span class="number">2</span>/(s**<span class="number">2</span>+<span class="number">2</span>*zeta*omega*s+omega**<span class="number">2</span>)</span><br><span class="line">sp.series(<span class="number">1</span>/g,m,<span class="number">0</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<p>$\displaystyle \frac{j s^{3} + k_{i} + s^{2} \left(k_{d} + \mu\right) + s \left(k_{p} + mgl\right)}{k_{i} + k_{p} s}$</p>
<p>联立两式,我们就可以得到$k_P,k_I,k_D$,在我们这种二阶滞后系统的情况下,可以实现$\frac{1}{\mathcal{G}_{yr}(s)}$和$\frac{1}{\mathcal{M}(s)}$完全一致  </p>
<blockquote>
<p>这是因为两者阶数恰好相同所以可以完全一致,但是在实际情况下只能大致相同</p>
</blockquote>
<h2 id="状态反馈控制"><a href="#状态反馈控制" class="headerlink" title="状态反馈控制"></a>状态反馈控制</h2><p>我们前面研究的是关于传递函数的模型,现在我们来研究<strong>状态空间模型$\dot{x}&#x3D;Ax+Bu$所描述的系统</strong><br>状态空间模型除了输入和输出,还存在有<strong>状态</strong>,我们可以假定可以通过传感器等观测到这些信息,具体而言,我们考虑如下的状态反馈控制:<br>$$u&#x3D;Fx$$<br>通过利用状态$x$的信息,来确定控制输入$u$,此处$F$称为<strong>状态反馈增益</strong><br>我们可以将状态反馈控制看作为一种PD控制,例如对于我们之前讨论的手推车系统,我们可以将手推车的位置$z$和速度$\dot{z}$当作状态,那么上式就可以被写作:<br>$$u&#x3D;Fx&#x3D;f_1z+f_2\dot{z}$$<br>其中$f_1$为比例增益,$f_2$为微分增益<br>而在状态反馈控制中最具代表性的设计方法有两种,分别为<strong>极点控制法</strong>和<strong>最优调节器</strong> </p>
<h3 id="极点配置法"><a href="#极点配置法" class="headerlink" title="极点配置法"></a>极点配置法</h3><p>将状态反馈控制$u&#x3D;Fx$施加于系统$\dot{x}&#x3D;Ax+Bu$上之后,闭环系统可以写作如下形式:<br>$$\dot{x}&#x3D;(A+BF)x$$<br>倘使和矩阵的所有极点的实部均为负数,那么系统是稳定的  </p>
<blockquote>
<p>这里提醒一下,和矩阵的所有特征值实部均为负数(因为是在e指数上)  </p>
</blockquote>
<p>做法是这样的:</p>
<ol>
<li>找到我们所需的特征值</li>
<li>寻找$F$,使$A+BF$能够满足我们的需要利用<code>acker</code>函数自带的阿克曼极点配置算法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A=<span class="string">&#x27;0 1;-4 5&#x27;</span></span><br><span class="line">B=<span class="string">&#x27;0; 1&#x27;</span></span><br><span class="line">C=<span class="string">&#x27;1 0;0 1&#x27;</span></span><br><span class="line">D=<span class="string">&#x27;0;0&#x27;</span></span><br><span class="line">P=ss(A,B,C,D)</span><br><span class="line"></span><br><span class="line">pole=[-<span class="number">1</span>,-<span class="number">1</span>] <span class="comment">#*指定极点</span></span><br><span class="line">F=-acker(P.A,P.B,pole)</span><br></pre></td></tr></table></figure>

<p>这里有负号的原因是在于<code>acker</code>返回的是使$A-BF$的特征值作为指定极点的$F$<br>我们可以验证一下特征值是否正确</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eigvals(P.A+P.B*F)</span><br></pre></td></tr></table></figure>




<pre><code>array([-1.+6.68896751e-09j, -1.-6.68896751e-09j])
</code></pre>
<p>几乎就是1(前面的应该是<code>float</code>的误差),那么我们来看一下闭环控制系统的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">acl=P.A+P.B*F</span><br><span class="line">pfb=ss(acl,P.B,P.C,P.D)</span><br><span class="line">td=np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">x0=[-<span class="number">0.3</span>,<span class="number">0.4</span>]</span><br><span class="line">x,t=initial(pfb,td,x0)</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&quot;$x_1$&quot;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],ls=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&quot;$x_2$&quot;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/02/05/control%20system/closecontrol2/close_control2_14_0.png" alt="png"></p>
<blockquote>
<p>对于特征值的选定</p>
</blockquote>
<h3 id="最优调节器"><a href="#最优调节器" class="headerlink" title="最优调节器"></a>最优调节器</h3><p>我们既然已经知道了极点配置法如何工作,那么我们需要评估其结果,主要有两点特征:  </p>
<ol>
<li>特征值实部负值越大响应越快,但是反馈增益$F$也会变大导致输入非常大</li>
<li>状态变量可能会出现涨幅较大的变量<br>为了解决这个问题,我们可以设定某个评价指标,同时求取状态反馈增益令评价指标最小化    <blockquote>
<p>对于$Q&#x3D;Q^T&gt;0,R&#x3D;R^T&gt;0$,有以下的评价函数<br>$$J&#x3D;\int^\infin_0(x^T(t)Qx(t)+u^T(t)Ru(t))dt$$<br>使得这个函数最小化的控制器形式为$u&#x3D;F_{opt}x$,其中$F_{opt}$的值为<br>$$F&#x3D;-R^{-1}B^TP$$<br>其中$P&#x3D;P^T&gt;0$,是满足下述方程的唯一正定二次型<br>$$A^TP+PA+PBR^{-1}B^TP+Q&#x3D;0$$<br>那么$J$的最小值为$x(0)^TPx(0)$<br>(仔细看评价函数,两个二次型)</p>
</blockquote>
</li>
</ol>
<p>像这样通过评价函数最优化得到的状态反馈控制为<strong>最优调节器</strong><br>另外,我们通常设定$Q$为对角阵(标准型),其中$Q$的对角元往往用来表示哪个先收敛<br>相应的,在$u$恒定的条件下,$R$作为标量越大,就可以得到不会让输入过大的$F$<br>而在python中,我们可以使用<code>lqr</code>来设计最优调节器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Q=[[<span class="number">100</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#*使用这个Q表示我们要让状态第一个变量速度大</span></span><br><span class="line">R=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">F,X,E=lqr(P.A,P.B,Q,R)<span class="comment">#*F为得到的反馈增益(要加一个负号),X为里卡提方程的解,E则为这个闭环系统的极点</span></span><br><span class="line">F=-F</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;反馈增益&quot;</span>.center(<span class="number">50</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(F)<span class="comment">#使用-(1/R)*B.T*X也能有相似的效果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;闭环极点&quot;</span>.center(<span class="number">50</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(E)</span><br><span class="line">acl=P.A+P.B*F</span><br><span class="line">pfb=ss(acl,P.B,P.C,P.D)</span><br><span class="line">td=np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">x0=[-<span class="number">0.3</span>,<span class="number">0.4</span>]</span><br><span class="line">x,t=initial(pfb,td,x0)</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&quot;$x_1$&quot;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],ls=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&quot;$x_2$&quot;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>-----------------------反馈增益-----------------------
[[ -0.12310563 -10.02555582]]
-----------------------闭环极点-----------------------
[-1.03259306 -3.99296276]
</code></pre>
<p><img src="/2023/02/05/control%20system/closecontrol2/close_control2_17_1.png" alt="png"></p>
<blockquote>
<p>使用<code>care</code>也可以得到相似的结果,在此不再介绍 </p>
</blockquote>
<blockquote>
<p>还有,我想当怀疑这个状态空间就是所谓的相空间,太像了(但是维度又不止二维)</p>
</blockquote>
<blockquote>
<p>同时,前面使用配置极点法时,要求任意状态$x$开始,要能够达到相空间的任何地方,可以使用<code>ctrb</code>求可控性矩阵</p>
</blockquote>
<h2 id="闭环系统规格"><a href="#闭环系统规格" class="headerlink" title="闭环系统规格"></a>闭环系统规格</h2><table>
<thead>
<tr>
<th></th>
<th>随动系统</th>
<th>恒值调节系统</th>
</tr>
</thead>
<tbody><tr>
<td>阻尼系数</td>
<td>0.6~0.8</td>
<td>0.2~0.5</td>
</tr>
<tr>
<td>超调量</td>
<td>0~0.25</td>
<td>0~0.25</td>
</tr>
<tr>
<td>峰值增益</td>
<td>1.1~1.5</td>
<td>1.1~1.5</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python设计控制系统</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title>对机器学习数据集进行处理和筛选</title>
    <url>/2023/02/22/machine-learning/goodtrainingsets/</url>
    <content><![CDATA[<p>数据的优劣和有效信息量的多少是决定机器学习算法能够学的多好的核心要素,因此,我们在喂给机器学习算法之前确保去检查和预处理一个数据集非常重要,在这一章,我们将介绍以下内容:</p>
<ol>
<li>移除和内插空白值</li>
<li>将分类数据整形为机器学习算法</li>
<li>为模型建构选择相关的特征<span id="more"></span></li>
</ol>
<h2 id="处理丢失的数据"><a href="#处理丢失的数据" class="headerlink" title="处理丢失的数据"></a>处理丢失的数据</h2><p>在现实生活中的数据集中,数据丢失并不罕见,这些可能来自于数据收集过程中的错误,一部分无法实现的测量或者对于调查而言一部分值空白之类.<br>我们一般会看到这些缺失值为<code>NaN</code>或者如<code>NULL</code><br>不幸的是,许多计算工具无法处理缺失值,或者会给出一些非常诡异的答案,因此我们必须亲自去处理这些问题</p>
<h3 id="在表格数据中找到缺失值"><a href="#在表格数据中找到缺失值" class="headerlink" title="在表格数据中找到缺失值"></a>在表格数据中找到缺失值</h3><p>在开始讨论之前,我们首先来”自制”一个CSV文件以更好地展示这个问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">csv_data=\</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A,B,C,D</span></span><br><span class="line"><span class="string">    1,2,3,4</span></span><br><span class="line"><span class="string">    5,6,,8</span></span><br><span class="line"><span class="string">    10,11,12,&#x27;&#x27;&#x27;</span></span><br><span class="line">df=pd.read_csv(StringIO(csv_data))</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>NaN</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<p>处理缺失值的前提自然是找到缺失值,但是在一个可能非常巨大的CSV文件里面人工去找缺失值很不现实,我们可以使用<code>isnull</code>来将一个<code>DataFrame</code>转化为相应的布尔数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<pre><code>A    0
B    0
C    1
D    1
dtype: int64
</code></pre>
<p>可以看到,C列和D列各有一个缺失值  </p>
<blockquote>
<p>需要注意到的是,<code>DataFrame</code>更加适合于数据的处理,但是机器学习所用的数据往往是以<code>Ndarray</code>的形式出现的,我们可以使用<code>df.values</code>实现这一转换</p>
</blockquote>
<h3 id="删除具有缺失值的样本或特征"><a href="#删除具有缺失值的样本或特征" class="headerlink" title="删除具有缺失值的样本或特征"></a>删除具有缺失值的样本或特征</h3><p>对付缺失值,最简单的方法莫过于是直接将其删除,我们可以使用<code>dropna</code>将存在缺失值的行或列删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



<p>当然,<code>dropna</code>也支持其他选项,下面有几个比较重要的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(how=<span class="string">&quot;all&quot;</span>)<span class="comment">#只有全部缺失才删除</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>NaN</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(thresh=<span class="number">4</span>)<span class="comment">#删除有效值小于4个</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(subset=[<span class="string">&#x27;C&#x27;</span>])<span class="comment">#只考虑C列的nan要删除</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<p>虽然删除缺失值非常方便,但也伴随着一些问题,我们可能会丢失太多的数据.<br>因此,我们接下来要看看最为常用的内插法处理缺失值的方法</p>
<h3 id="计算缺失值"><a href="#计算缺失值" class="headerlink" title="计算缺失值"></a>计算缺失值</h3><p>一般而言,将缺失值全部去掉并不现实,我们这里则是采用内插处理</p>
<p>在内插中最为常见的莫过于<strong>平均值内插</strong>,我们就将缺失值替换为整个特征的平均值,这么做有一个简单的方法就是使用<code>Imputer</code>类,就像下面所展示的那样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer<span class="comment">#!0.22版本以上需要使用SimpleImputer代替</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">imr=SimpleImputer(missing_values=np.nan,strategy=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">imr=imr.fit(df.values)</span><br><span class="line">imputed_data=imr.transform(df.values)</span><br><span class="line">imputed_data</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 1. ,  2. ,  3. ,  4. ],
       [ 5. ,  6. ,  7.5,  8. ],
       [10. , 11. , 12. ,  6. ]])
</code></pre>
<p>可以注意到,每一处的<code>NaN</code>都已经被相应的平均值所替换了,这种手段在分类数据中非常有用</p>
<h3 id="理解scikit-learn中的估计API"><a href="#理解scikit-learn中的估计API" class="headerlink" title="理解scikit-learn中的估计API"></a>理解<code>scikit-learn</code>中的估计API</h3><p>在之前的部分中,我们采用<code>SimpleImputer</code>类来计算我们数据集中的缺失值,这在<code>scikit-learn</code>类中被称作<strong>转换类</strong><br>转换类中最为重要的两个方法就是<code>fit</code>和<code>transform</code>,实际上,这和我们之前所学的分类数据很像,主要区别在于我们这里的训练集和测试集都要经过相同的处理(但是<code>fit</code>过程还是要用训练集),如图所示:<br><img src="/2023/02/22/machine-learning/goodtrainingsets/image-20230222003147893.png" alt="image-20230222003147893"></p>
<h2 id="处理分类数据"><a href="#处理分类数据" class="headerlink" title="处理分类数据"></a>处理分类数据</h2><p>到目前为止,我们处理的还主要是数值数据,但是在现实生活中一个或多个分类数据并不少见,在这一部分,我们将用一些简单而有效的例子来展现我们应当如何处理这类数据.</p>
<h3 id="可排序与不可排序的特征"><a href="#可排序与不可排序的特征" class="headerlink" title="可排序与不可排序的特征"></a>可排序与不可排序的特征</h3><p>如果我们在讨论分类数据时,我们往往会进一步将其分为可排序和不可排序的特征</p>
<p>可排序特征比如我们可以认为超大号&gt;大号&gt;中号&gt;小号来对衣服尺码的分类来进行排序,但是显然我们无法对一些特征例如男性或女性这样的特征进行排序</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="创建一个示例数据集"><a href="#创建一个示例数据集" class="headerlink" title="创建一个示例数据集"></a>创建一个示例数据集</h3><p>在我们探索处理这样的分类数据前,我们首先先创建一个用来展现问题的数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame([</span><br><span class="line">    [<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">10.1</span>,<span class="string">&#x27;class1&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="number">13.5</span>,<span class="string">&#x27;class2&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;XL&#x27;</span>,<span class="number">15.3</span>,<span class="string">&#x27;class1&#x27;</span>]</span><br><span class="line">    ])</span><br><span class="line">df.columns=[<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;size&#x27;</span>,<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;classlabel&#x27;</span>]</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>size</th>
      <th>price</th>
      <th>classlabel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>green</td>
      <td>M</td>
      <td>10.1</td>
      <td>class1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>red</td>
      <td>L</td>
      <td>13.5</td>
      <td>class2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>blue</td>
      <td>XL</td>
      <td>15.3</td>
      <td>class1</td>
    </tr>
  </tbody>
</table>
</div>



<p>我们可以看到,刚刚创建的<code>DataFrame</code>包含一个不可排序的特征,一个可以排序的特征<br>而分类标签则是被储存在了最后一列<br>在我们所使用的学习算法中,并不会使用到标签的先后顺序</p>
<h3 id="映射可排序特征"><a href="#映射可排序特征" class="headerlink" title="映射可排序特征"></a>映射可排序特征</h3><p>为了保证学习算法可以准确地解释排序特征,我们需要将分类标签字符串转化为整数<br>不幸的是,没有可以从标签直接方便地转变成数字的方法,因此我们需要手动去定义映射</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size_mapping=&#123;</span><br><span class="line">    <span class="string">&#x27;XL&#x27;</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;L&#x27;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;M&#x27;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">df[<span class="string">&#x27;size&#x27;</span>]=df[<span class="string">&#x27;size&#x27;</span>].<span class="built_in">map</span>(size_mapping)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>size</th>
      <th>price</th>
      <th>classlabel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>green</td>
      <td>1</td>
      <td>10.1</td>
      <td>class1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>red</td>
      <td>2</td>
      <td>13.5</td>
      <td>class2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>blue</td>
      <td>3</td>
      <td>15.3</td>
      <td>class1</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以看到<code>size</code>特征已经被完全地分割了,而假如最后我们希望其再替换回原来的字符串标签,我们可以使用制作一个反映射字典,其做法并不困难,用生成器非常方便</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inv_mapping=&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> size_mapping.items()&#125;</span><br><span class="line">df[<span class="string">&#x27;size&#x27;</span>].<span class="built_in">map</span>(inv_mapping)</span><br></pre></td></tr></table></figure>




<pre><code>0     M
1     L
2    XL
Name: size, dtype: object
</code></pre>
<h3 id="编码类标签"><a href="#编码类标签" class="headerlink" title="编码类标签"></a>编码类标签</h3><p>许多机器学习库需要编码成正整数的类标签(虽然也有很大一部分在内部执行这一工作)<br>为了给类标签编码,我们可以用前一部分的方式,但是我们同样也要记住,此处的标签是<strong>不可排序</strong>的,因此我们只需要简单地枚举类标签(从0开始)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">class_mapping=&#123;label:idx <span class="keyword">for</span> idx,label <span class="keyword">in</span> <span class="built_in">enumerate</span>(np.unique(df[<span class="string">&#x27;classlabel&#x27;</span>]))&#125;</span><br><span class="line">class_mapping</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;class1&#39;: 0, &#39;class2&#39;: 1&#125;
</code></pre>
<p>接下来,我们就可以将类标签转换为整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;classlabel&#x27;</span>]=df[<span class="string">&#x27;classlabel&#x27;</span>].<span class="built_in">map</span>(class_mapping)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>size</th>
      <th>price</th>
      <th>classlabel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>green</td>
      <td>1</td>
      <td>10.1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>red</td>
      <td>2</td>
      <td>13.5</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>blue</td>
      <td>3</td>
      <td>15.3</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<p>我们也可以像之前那样翻转键值对以达到返回原来表示形式的目的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inv_mapping=&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> class_mapping.items()&#125;</span><br><span class="line">df[<span class="string">&#x27;classlabel&#x27;</span>]=df[<span class="string">&#x27;classlabel&#x27;</span>].<span class="built_in">map</span>(inv_mapping)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>size</th>
      <th>price</th>
      <th>classlabel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>green</td>
      <td>1</td>
      <td>10.1</td>
      <td>class1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>red</td>
      <td>2</td>
      <td>13.5</td>
      <td>class2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>blue</td>
      <td>3</td>
      <td>15.3</td>
      <td>class1</td>
    </tr>
  </tbody>
</table>
</div>



<p>相应的,在机器学习库中也有一个<code>LabelEncoder</code>类也可以直接实现这个目的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">class_le=LabelEncoder()</span><br><span class="line">y=class_le.fit_transform(df[<span class="string">&#x27;classlabel&#x27;</span>].values)</span><br><span class="line">y</span><br></pre></td></tr></table></figure>




<pre><code>array([0, 1, 0])
</code></pre>
<p>需要注意的是<code>fit_transform</code>就是简单地先后依次调用<code>fit</code>和<code>transform</code>,接下来我们可以使用<code>inverse_transform</code>将整数类标签再转换为原来的字符串表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class_le.inverse_transform(y)</span><br></pre></td></tr></table></figure>




<pre><code>array([&#39;class1&#39;, &#39;class2&#39;, &#39;class1&#39;], dtype=object)
</code></pre>
<h3 id="在不可排序特征使用”单一热源”-one-hot-编码方式"><a href="#在不可排序特征使用”单一热源”-one-hot-编码方式" class="headerlink" title="在不可排序特征使用”单一热源”(one-hot)编码方式"></a>在不可排序特征使用”单一热源”(one-hot)编码方式</h3><p>在我们之前的部分中,我们采用的是一个简单的字典映射的方法进行编码<br>但是这存在一个问题,倘使我们采用这样的编码形式,那么即使我们认为各个数之间不存在大小关系,但是学习算法不会那么想,这会导致一些错误</p>
<p>一种常见的解决方法是采用一种被称作”单一热源编码”(one-hot)的方式,其原理是为每一个特定的分类创建一个新的特征</p>
<blockquote>
<p>比如说颜色,从原来的颜色(红绿蓝),变成三个特征(是否是红,是否是绿,是否是蓝)</p>
</blockquote>
<p>我们可以使用<code>OneHotEncoder</code>实现这个功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;size&#x27;</span>,<span class="string">&#x27;price&#x27;</span>]].values</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;green&#39;, 1, 10.1],
       [&#39;red&#39;, 2, 13.5],
       [&#39;blue&#39;, 3, 15.3]], dtype=object)
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">ohe=OneHotEncoder()</span><br><span class="line">ohe.fit_transform(df[[<span class="string">&#x27;color&#x27;</span>]].values).toarray()</span><br></pre></td></tr></table></figure>




<pre><code>array([[0., 1., 0.],
       [0., 0., 1.],
       [1., 0., 0.]])
</code></pre>
<blockquote>
<p>需要注意一下,如果我们希望在这里对于一整个数据集中的部分类施加这一方法,在书中的版本中,采用的是<code>categorical_features</code>这一关键字参数,但是这个参数在现在的版本中已经被废除,因此应当采用以下形式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line">X=df[[<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;size&#x27;</span>,<span class="string">&#x27;price&#x27;</span>]].values</span><br><span class="line">color_en=ColumnTransformer([(<span class="string">&quot;Test Transform&quot;</span>,OneHotEncoder(),[<span class="number">0</span>])],remainder=<span class="string">&#x27;passthrough&#x27;</span>)</span><br><span class="line">X=color_en.fit_transform(X)</span><br><span class="line">X</span><br></pre></td></tr></table></figure>




<pre><code>array([[0.0, 1.0, 0.0, 1, 10.1],
       [0.0, 0.0, 1.0, 2, 13.5],
       [1.0, 0.0, 0.0, 3, 15.3]], dtype=object)
</code></pre>
<p>当然,我们处理这个还有更加方便的方法,就是使用<code>get_dummies</code>方法(<code>pandas</code>内置)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.get_dummies(df[[<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;size&#x27;</span>]])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>size</th>
      <th>color_blue</th>
      <th>color_green</th>
      <th>color_red</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>10.1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>13.5</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>15.3</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<p><strong>注意,这个方法只会修改以字符串为内容的列,其他列不变</strong></p>
<h2 id="将数据集分割成训练集和测试集"><a href="#将数据集分割成训练集和测试集" class="headerlink" title="将数据集分割成训练集和测试集"></a>将数据集分割成训练集和测试集</h2><p>我们之前曾经简单描述过如何将训练集进行分割,在这一部分,我们将准备一个全新的测试集<code>Wine</code>,这里面有178个酒类数据,每个有13个特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df=pd.read_csv(<span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data&quot;</span></span><br><span class="line">               ,header=<span class="literal">None</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
      <th>11</th>
      <th>12</th>
      <th>13</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>14.23</td>
      <td>1.71</td>
      <td>2.43</td>
      <td>15.6</td>
      <td>127</td>
      <td>2.80</td>
      <td>3.06</td>
      <td>0.28</td>
      <td>2.29</td>
      <td>5.64</td>
      <td>1.04</td>
      <td>3.92</td>
      <td>1065</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>13.20</td>
      <td>1.78</td>
      <td>2.14</td>
      <td>11.2</td>
      <td>100</td>
      <td>2.65</td>
      <td>2.76</td>
      <td>0.26</td>
      <td>1.28</td>
      <td>4.38</td>
      <td>1.05</td>
      <td>3.40</td>
      <td>1050</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>13.16</td>
      <td>2.36</td>
      <td>2.67</td>
      <td>18.6</td>
      <td>101</td>
      <td>2.80</td>
      <td>3.24</td>
      <td>0.30</td>
      <td>2.81</td>
      <td>5.68</td>
      <td>1.03</td>
      <td>3.17</td>
      <td>1185</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>14.37</td>
      <td>1.95</td>
      <td>2.50</td>
      <td>16.8</td>
      <td>113</td>
      <td>3.85</td>
      <td>3.49</td>
      <td>0.24</td>
      <td>2.18</td>
      <td>7.80</td>
      <td>0.86</td>
      <td>3.45</td>
      <td>1480</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>13.24</td>
      <td>2.59</td>
      <td>2.87</td>
      <td>21.0</td>
      <td>118</td>
      <td>2.80</td>
      <td>2.69</td>
      <td>0.39</td>
      <td>1.82</td>
      <td>4.32</td>
      <td>1.04</td>
      <td>2.93</td>
      <td>735</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>173</th>
      <td>3</td>
      <td>13.71</td>
      <td>5.65</td>
      <td>2.45</td>
      <td>20.5</td>
      <td>95</td>
      <td>1.68</td>
      <td>0.61</td>
      <td>0.52</td>
      <td>1.06</td>
      <td>7.70</td>
      <td>0.64</td>
      <td>1.74</td>
      <td>740</td>
    </tr>
    <tr>
      <th>174</th>
      <td>3</td>
      <td>13.40</td>
      <td>3.91</td>
      <td>2.48</td>
      <td>23.0</td>
      <td>102</td>
      <td>1.80</td>
      <td>0.75</td>
      <td>0.43</td>
      <td>1.41</td>
      <td>7.30</td>
      <td>0.70</td>
      <td>1.56</td>
      <td>750</td>
    </tr>
    <tr>
      <th>175</th>
      <td>3</td>
      <td>13.27</td>
      <td>4.28</td>
      <td>2.26</td>
      <td>20.0</td>
      <td>120</td>
      <td>1.59</td>
      <td>0.69</td>
      <td>0.43</td>
      <td>1.35</td>
      <td>10.20</td>
      <td>0.59</td>
      <td>1.56</td>
      <td>835</td>
    </tr>
    <tr>
      <th>176</th>
      <td>3</td>
      <td>13.17</td>
      <td>2.59</td>
      <td>2.37</td>
      <td>20.0</td>
      <td>120</td>
      <td>1.65</td>
      <td>0.68</td>
      <td>0.53</td>
      <td>1.46</td>
      <td>9.30</td>
      <td>0.60</td>
      <td>1.62</td>
      <td>840</td>
    </tr>
    <tr>
      <th>177</th>
      <td>3</td>
      <td>14.13</td>
      <td>4.10</td>
      <td>2.74</td>
      <td>24.5</td>
      <td>96</td>
      <td>2.05</td>
      <td>0.76</td>
      <td>0.56</td>
      <td>1.35</td>
      <td>9.20</td>
      <td>0.61</td>
      <td>1.60</td>
      <td>560</td>
    </tr>
  </tbody>
</table>
<p>178 rows × 14 columns</p>
</div>



<p>将这个分割成分别的训练集和测试集是使用<code>train_test_split</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X,y=df.iloc[:,<span class="number">1</span>:].values,df.iloc[:,<span class="number">0</span>].values</span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=<span class="number">0.3</span>,random_state=<span class="number">0</span>,stratify=y)</span><br></pre></td></tr></table></figure>

<p>在这一步中,我们首先将数据中的特征与分类标签区分开来,然后随机划分30%的测试集,向<code>stratify</code>参数中输入标签是为了保证三种不同的标签都等量的被选中</p>
<blockquote>
<p>我们需要注意到,应当尽量避免出现在划分数据集时去掉了有价值的内容,因此,我们可能要选取多次划分</p>
</blockquote>
<h2 id="将特征归一化"><a href="#将特征归一化" class="headerlink" title="将特征归一化"></a>将特征归一化</h2><p>在我们的处理流程中,<strong>特征重放缩</strong>是一个非常容易被忘掉,但是也非常重要的一步.只有非常少见的算法(决策树和随机森林)不需要考虑重放缩的问题<br>这里我们利用梯度下降法进行机器学习来展示这种技术的效果</p>
<p>归一化的效果非常容易想象,比如有两个特征,一个范围0<del>1,一个范围0</del>10000,那么如果我们不进行归一化,毫无疑问,算法会主要处理后面那个特征.</p>
<p>而对于将不同的特征带到同样一个范围有两种常用的方式:归一化(<strong>normalization</strong>)和标准化(<strong>standardization</strong>),但这两种说法经常被混用,需要注意.往往归一化是将特征转换到[0,1]的范围中,使用的叫<strong>最大-最小缩放</strong>,计算公式也非常简单<br>$$x_{norm}^{(i)}&#x3D;\frac{x^{(i)}-x_{min}}{x_{max}-x_{min}}$$<br>代码则如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">mms=MinMaxScaler()</span><br><span class="line">X_train_norm=mms.fit_transform(X_train)</span><br><span class="line">X_test_norm=mms.transform(X_test)</span><br></pre></td></tr></table></figure>

<p>虽然这种最大-最小放缩在我们已知范围的数据区间内非常有用,但是<strong>标准化</strong>在许多机器学习内容中更加重要,尤其是优化算法比如梯度下降法.通过标准化,我们可以将特征集中到以0为均值,1为标准差的方位之内.<br>另外,标准化还有一个很大的好处,就是它不是那么容易受到极值的影响<br>标准化的流程可以用下式来表示:<br>$$x_{std}^{(i)}&#x3D;\frac{x^{(i)}-\mu_x}{\sigma_x}$$<br>我们可以使用以下代码来执行标准化过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">stdsc=StandardScaler()</span><br><span class="line">X_train_std=stdsc.fit_transform(X_train)</span><br><span class="line">X_test_std=stdsc.transform(X_test)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们这里仍然需要注意,<code>StandardScaler</code>在使用过程中只能<code>fit</code>一次</p>
</blockquote>
<h2 id="挑选有价值的信息"><a href="#挑选有价值的信息" class="headerlink" title="挑选有价值的信息"></a>挑选有价值的信息</h2><p>如果我们发现一个模型在训练集上的效果<strong>远优于</strong>测试集,那么这就意味着很有可能发生了过拟合,这样的模型收到噪音的影响太大,泛化性不好.可能的原因是使用的模型太过于复杂,常见的解决方案如下:</p>
<ol>
<li>选取更多的训练数据</li>
<li>使用正则化为过度复杂的情况引入惩罚</li>
<li>选取一个更加简单的模型</li>
<li>减少数据的维数<br>接下来的部分我们将介绍如何通过选取特征实现降维和正则化,能给我们带来更加简单的模型</li>
</ol>
<h3 id="L1和L2正则化作为模型复杂度代价"><a href="#L1和L2正则化作为模型复杂度代价" class="headerlink" title="L1和L2正则化作为模型复杂度代价"></a>L1和L2正则化作为模型复杂度代价</h3><p>我们之前提到过一种正则化方法可以实现对模型的简化,通过加上一项<strong>L2模</strong><br>$$L2:||\omega||^2_2&#x3D;\sum_{j&#x3D;1}^m\omega_j^2$$<br>另外一种降低模型复杂度的方法则被称作为L1正则化:<br>$$L1:||\omega||<em>1&#x3D;\sum</em>{j&#x3D;1}^{m}|\omega_j|$$<br>相较于L2正则化,L1正则化更加适合稀疏的特征(大部分的特征向量中值为0),在这种考虑下,L1正则化可以被看作是一种<strong>特征选取的技术</strong></p>
<h3 id="L2正则化的一种几何化解读"><a href="#L2正则化的一种几何化解读" class="headerlink" title="L2正则化的一种几何化解读"></a>L2正则化的一种几何化解读</h3><p>正如之前所描述的那样,L2正则化向代价函数中添加了代价项,在研究L1之前,我们先来看看正则化的几何解释</p>
<p>我们首先在$\omega_1$和$\omega_2$两个轴上绘制一个凸函数,在这里,我们将考量<strong>方均根误差</strong>(SSE),因为这种方法的计算要比使用logistic回归的方式方便很多,但是两者的理念是相同的.,我们需要记住我们要找到的是满足权重较小且误差小的结合,就像在下图中展现的那样<br><img src="/2023/02/22/machine-learning/goodtrainingsets/1.png" alt="1.png"><br>那么,我们可以认为正则化是在尽量的鼓励较小的权重,因此,通过添加正则化参量,我们让最佳点靠近原点<br><img src="/2023/02/22/machine-learning/goodtrainingsets/2.png" alt="2.png"><br>此时$\lambda$可以用来描述这个圆有多重要,倘使$\lambda$非常大,那么这个圆就会变小</p>
<h3 id="使用L1正则化分散解"><a href="#使用L1正则化分散解" class="headerlink" title="使用L1正则化分散解"></a>使用L1正则化分散解</h3><p>现在,我们来讨论L1正则化的结果,虽然有点类似,但是我们需要知道L1正则化是直接绝对值求和,因此可以表示为一个菱形而不是一个圆<br><img src="/goodtrainingsets/3.png" alt="png"></p>
<p>在前面那张图中,我们可以注意到代价函数的等高线与L1菱形相交(在$\omega_1&#x3D;0$处),既然L1正则系统比较尖锐,那么我们可以推断最为理想的状态应当是位于轴上,此时$\omega_1&#x3D;0$,这就增强了稀疏性<br>而对于正则化支持L1正则化后的模型,我们可以简单地将<code>penalty</code>参数设定为<code>l1</code></p>
<blockquote>
<p>注意,在这么做时,要将<code>dual</code>设为<code>False</code>,要将<code>solver</code>设为<code>liblinear</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">LogisticRegression(penalty=<span class="string">&#x27;l1&#x27;</span>,dual=<span class="literal">False</span>,solver=<span class="string">&#x27;liblinear&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>我们将这个方法运用到刚才那个酒类的例子之中,我们可以得到这样的分散解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr=LogisticRegression(penalty=<span class="string">&#x27;l1&#x27;</span>,C=<span class="number">1.0</span>,dual=<span class="literal">False</span>,solver=<span class="string">&#x27;liblinear&#x27;</span>)</span><br><span class="line">lr.fit(X_train_std,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training accuracy:&#x27;</span>,lr.score(X_train_std,y_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>,lr.score(X_test_std,y_test))</span><br></pre></td></tr></table></figure>

<pre><code>Training accuracy: 1.0
Test accuracy: 1.0
</code></pre>
<p>可以看到,我们的模型对训练集和测试集都有着完美的描述,接下来我们可以看一看训练的结果参数<br>其中包含了截距和参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The w0 is &quot;</span>,lr.intercept_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The wi is&quot;</span>,lr.coef_)</span><br></pre></td></tr></table></figure>

<pre><code>The w0 is  [-1.26382301 -1.21599452 -2.36990903]
The wi is [[ 1.24557242  0.18072145  0.74571775 -1.1636765   0.          0.
   1.16100096  0.          0.          0.          0.          0.55564141
   2.50903545]
 [-1.53717924 -0.38698786 -0.99501331  0.36448555 -0.05940712  0.
   0.66768246  0.          0.         -1.93424305  1.23445191  0.
  -2.23163889]
 [ 0.13578242  0.16856474  0.35719175  0.          0.          0.
  -2.43795819  0.          0.          1.56376444 -0.81884123 -0.4924925
   0.        ]]
</code></pre>
<p>作为L1正则化的结果,我们可以看到存在一些可能与我们的推断不相关的参数.虽然前面的那个例子可能并不是非常的稀疏,因为里面仍然包含了许多的非零参数,但是我们也可以通过加大<code>C</code>的方式使得正则化强度增加</p>
<p>而对于在这一部分的最后一个例子,我们将展现随着C的逐渐增大,正则化参数的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig=plt.figure()</span><br><span class="line">ax=plt.subplot(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_gen</span>():  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;line_gen 产生不超过九个线形</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields</span></span><br><span class="line"><span class="string">    ------</span></span><br><span class="line"><span class="string">    str</span></span><br><span class="line"><span class="string">        产生得到线形的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line">    line_shapes=[<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;-*&quot;</span>]</span><br><span class="line">    line_cols=[<span class="string">&quot;r&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> line_shape <span class="keyword">in</span> line_shapes:</span><br><span class="line">        <span class="keyword">for</span> line_col <span class="keyword">in</span> line_cols:</span><br><span class="line">            <span class="keyword">yield</span> line_col+line_shape</span><br><span class="line"></span><br><span class="line">weights,params=[],[]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> np.arange(-<span class="number">4.</span>,<span class="number">6.</span>):</span><br><span class="line">    lr=LogisticRegression(penalty=<span class="string">&#x27;l1&#x27;</span>,C=<span class="number">10</span>**c,solver=<span class="string">&#x27;liblinear&#x27;</span>,random_state=<span class="number">0</span>)</span><br><span class="line">    lr.fit(X_train_std,y_train)</span><br><span class="line">    weights.append(lr.coef_[<span class="number">1</span>])</span><br><span class="line">    params.append(<span class="number">10</span>**c)</span><br><span class="line">weights=np.array(weights)   </span><br><span class="line">lg=line_gen()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(weights.shape[<span class="number">1</span>]):</span><br><span class="line">    plt.plot(params,weights[:,c],<span class="built_in">next</span>(lg),label=df.columns[c+<span class="number">1</span>])</span><br><span class="line">plt.xlim([<span class="number">10</span>**(-<span class="number">5</span>),<span class="number">10</span>**<span class="number">5</span>])</span><br><span class="line">plt.ylabel(<span class="string">&quot;weighr coeff&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">plt.xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;best&quot;</span>,fancybox=<span class="literal">True</span>,ncol=<span class="number">1</span>)</span><br><span class="line">ax.grid(<span class="literal">True</span>,<span class="string">&#x27;both&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/02/22/machine-learning/goodtrainingsets/goodtrainingsets_68_0.png" alt="png"><br>​    </p>
<p>我们可以看到如果我们将<code>C</code>设置很小(相当于很高的正则化参数),那么各个参数将会趋向0</p>
<h2 id="序列特征选择算法"><a href="#序列特征选择算法" class="headerlink" title="序列特征选择算法"></a>序列特征选择算法</h2><p>另外一种降低模型复杂度并且避免过拟合的手段是<strong>降维法</strong>,常见有两种降维的手段:特征选取和特征提取,使用前者我们会得到特征的一个子集,使用后者我们则会得到一个全新的特征空间</p>
<p>在这一部分中,我们将讨论一个特征选择算法中传统的一族.</p>
<p>序列特征选择算法是一种贪心算法,其目的在于选取出与与问题关联程度最高的子集,可以提高计算效率并且降低误差的影响</p>
<p>一个经典的序列特征选择算法是<strong>序列后向选择(SBS)</strong>,其目的在于减少初始特征子空间位数,而SBS在模型面临过拟合的困境时,还可以提高模型的说服力.</p>
<p>SBS算法背后的思想非常简单,SBS一步步减少特征直到最后拥有指定数量,而为了判断移除特征的顺序,我们需要定义一个标准函数$J$达到最小值,这个函数可以简单地认为是保留这个特征和删除这个特征训练效果之差,也就是说让这个函数最小的特征可以被看作是<strong>最不重要</strong>的特征</p>
<blockquote>
<p>虽然书中原文讲并没有可以实现这个目的的函数,但是可能由于版本迭代,我在<a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SequentialFeatureSelector.html">这里</a>看到了有关函数的资料,也许可以用一下   </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SequentialFeatureSelector</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">scorel=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line">    sbs=SequentialFeatureSelector(KNeighborsClassifier(p=<span class="number">2</span>),n_features_to_select=i,direction=<span class="string">&quot;backward&quot;</span>)</span><br><span class="line">    sbs.fit(X_train_std,y_train)</span><br><span class="line">    nxt=X_train_std[:,sbs.support_]</span><br><span class="line">    c=KNeighborsClassifier(p=<span class="number">2</span>)</span><br><span class="line">    c.fit(nxt,y_train)</span><br><span class="line">    sc=accuracy_score(c.predict(nxt),y_train)</span><br><span class="line">    scorel.append(sc)</span><br></pre></td></tr></table></figure>

<p>在上面,我们应用了所给的<code>SequentialFeatureSelector</code>进行后向选取,但是我们需要注意到,在我们对分数进行评估的时候,必须要使用<strong>训练集</strong>进行评估,实际上是要保证<strong>测试集的数据无论如何不会影响到训练过程</strong>,否则测试集的效果将会降低</p>
<p>下面展现出使用序列选取后准确率的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">13</span>)),scorel,<span class="string">&quot;*-&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of features&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>,<span class="string">&quot;both&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/goodtrainingsets_files/goodtrainingsets_73_0.png" alt="png"><br>​    </p>
<blockquote>
<p>其他还有许多类型的选取方法,可以去参考官方网页</p>
</blockquote>
<h2 id="使用随机森林方法评估特征的重要性"><a href="#使用随机森林方法评估特征的重要性" class="headerlink" title="使用随机森林方法评估特征的重要性"></a>使用随机森林方法评估特征的重要性</h2><p>在之前的部分中,我们通过L1正则化方法学会如何去除无关的特征,另外一种常用方法是<strong>随机森林</strong>,因为在之前我们就提到过,随机森林会随机选取某些特征和某些样本进行训练,在我们训练完后,我们就可以得到不同特征的重要程度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">flabel=df.columns[<span class="number">1</span>:]</span><br><span class="line">forest=RandomForestClassifier(n_estimators=<span class="number">500</span>,random_state=<span class="number">1</span>)</span><br><span class="line">forest.fit(X_train,y_train)</span><br><span class="line">imp=forest.feature_importances_</span><br><span class="line">indices=np.argsort(imp)[::-<span class="number">1</span>]</span><br><span class="line">plt.bar(<span class="built_in">range</span>(X_train.shape[<span class="number">1</span>]),imp[indices],align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/02/22/machine-learning/goodtrainingsets/goodtrainingsets_76_0.png" alt="png"><br>​    </p>
<p>从这张图我们可以清晰地看出哪些特征更加重要</p>
<p>作为对随机森林的总结,<code>sklearn</code>里面还包含了一种<code>SelectFromModel</code>类支持用户用自定义阈值来实现模型选取,那么我们就可以用随机森林作为中间步骤,例如我们下面就可以将阈值设为0.1,看到五个最为重要的特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">sfm=SelectFromModel(forest,threshold=<span class="number">0.1</span>,prefit=<span class="literal">True</span>)</span><br><span class="line">X_selected=sfm.transform(X_train)</span><br><span class="line">X_selected</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们首先看了处理缺失数据的正确方法,然后对数据进行编码以方便进行学习</p>
<p>接下来,我们介绍了L1正则化方法,可以规避过拟合现象发生,同时,选取合适的学习特征也有其他的手段可以使用.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>被控对象的行为</title>
    <url>/2023/01/15/control%20system/control2/</url>
    <content><![CDATA[<h1 id="被控对象的行为"><a href="#被控对象的行为" class="headerlink" title="被控对象的行为"></a>被控对象的行为</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了更加方便地绘制相关图像,在这里要进行相应的准备工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> control <span class="keyword">as</span> ct </span><br><span class="line"><span class="keyword">from</span> control.matlab <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>绘图时用以确定线条类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">line_generator</span>():</span><br><span class="line">    linestyle=[<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;:&quot;</span>]</span><br><span class="line">    lineid=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> linestyle[lineid] <span class="comment">#* 这个yield用法很有趣,可以学习一下</span></span><br><span class="line">        lineid=(lineid+<span class="number">1</span>)%<span class="built_in">len</span>(linestyle)</span><br></pre></td></tr></table></figure>

<p>用以完善绘图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax.set_xlabel(args[<span class="number">0</span>])</span><br><span class="line">    fig_ax.set_ylabel(args[<span class="number">1</span>])</span><br><span class="line">    fig_ax.grid(ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">        fig_ax.legend(loc=args[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>用以完善伯德图函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bodeplot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax[<span class="number">0</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;Gain [dB]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;$\omega$ [rad/s]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;Phase [deg]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">0</span>:</span><br><span class="line">        fig_ax[<span class="number">1</span>].legend(loc=args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">1</span>:</span><br><span class="line">        fig_ax[<span class="number">0</span>].legend(loc=args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="时域响应"><a href="#时域响应" class="headerlink" title="时域响应"></a>时域响应</h2><span id="more"></span>

<p>在这一部分,我们选取常见的阶跃函数<code>step</code>对于一阶和二阶的滞后系统进行描述</p>
<h3 id="一阶滞后系统"><a href="#一阶滞后系统" class="headerlink" title="一阶滞后系统"></a>一阶滞后系统</h3><p>之前用来描述有阻尼手推车系统的传递函数的传递函数为<br>$$\mathcal{P}(s)&#x3D;\frac{\frac{1}{\mu}}{1+\frac{M}{\mu}s}$$<br>可以将$\frac{1}{\mu}$简化为增益$K$,$\frac{M}{\mu}$简化为时间常数$T$,<br>这一类系统的阶跃响应可以被表示为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts,k=<span class="number">0.5</span>,<span class="number">1</span></span><br><span class="line">p=tf([<span class="number">0</span>,k],[ts,<span class="number">1</span>])</span><br><span class="line">y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,y)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_11_0.png" alt="png"><br>​    </p>
<p>其中,我们需要注意到,$T$代表系统达到稳定值的63.2%所需要的时间.<br>下面展示了在不同的$T$下系统的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"></span><br><span class="line">k=<span class="number">1</span></span><br><span class="line">tl=[<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> tt <span class="keyword">in</span> tl:</span><br><span class="line">    p=tf([<span class="number">0</span>,k],[tt,<span class="number">1</span>])</span><br><span class="line">    y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line">    ax.plot(t,y,<span class="built_in">next</span>(ls),label=<span class="string">&quot;T=&quot;</span>+<span class="built_in">str</span>(tt))</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_13_0.png" alt="png"><br>​    </p>
<p>可以明显看出$T$越大,达到平衡就越慢,$K$为增益,在这里不再加以演示了</p>
<h3 id="二阶滞后系统"><a href="#二阶滞后系统" class="headerlink" title="二阶滞后系统"></a>二阶滞后系统</h3><p>如果考量一个阻尼弹簧的模型,我们可以得到其传递模型为<br>$$\mathcal{P}(s)&#x3D;\frac{\omega_n^2}{s^2+2\zeta\omega_ns+\omega_n^2}$$<br>式中$\zeta$被称为阻尼系数,$\omega_n$被称为无阻尼自然频率.<br>这样的系统被称为<strong>二阶滞后系统</strong></p>
<blockquote>
<p>实际上就是阻尼振动(LCR振荡的模型)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zeta,omega0=<span class="number">0.4</span>,<span class="number">5</span></span><br><span class="line">p=tf([<span class="number">0</span>,omega0**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*zeta*omega0,omega0**<span class="number">2</span>])</span><br><span class="line">y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,y)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_16_0.png" alt="png"><br>​    </p>
<p>可以注意到响应图象呈现先增大后减小(中间存在过冲)<strong>过冲</strong>在二阶滞后系统时有发生.<br>下面展现出过冲在不同的阻尼系数下的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"></span><br><span class="line">omega=<span class="number">5</span></span><br><span class="line">beta=[<span class="number">0.3</span>,<span class="number">0.5</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> tt <span class="keyword">in</span> beta:</span><br><span class="line">    p=tf([<span class="number">0</span>,omega**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*tt*omega,omega**<span class="number">2</span>])</span><br><span class="line">    y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line">    ax.plot(t,y,<span class="built_in">next</span>(ls),label=<span class="string">&quot;$\zeta$=&quot;</span>+<span class="built_in">str</span>(tt))</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_18_0.png" alt="png"><br>​    </p>
<p>可以注意到随着$\zeta$增加,过冲逐渐减小,乃至消失,而不同的$\omega_n$的影响可以如下图所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"></span><br><span class="line">omegas=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">tt=<span class="number">0.3</span></span><br><span class="line"><span class="keyword">for</span> omega <span class="keyword">in</span> omegas:</span><br><span class="line">    p=tf([<span class="number">0</span>,omega**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*tt*omega,omega**<span class="number">2</span>])</span><br><span class="line">    y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line">    ax.plot(t,y,<span class="built_in">next</span>(ls),label=<span class="string">&quot;$\omega_n$=&quot;</span>+<span class="built_in">str</span>(omega))</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_20_0.png" alt="png"><br>​    </p>
<p>可见$\omega_n$不会改变响应的大小,只会改变响应速度</p>
<blockquote>
<p>下面展现了一个高阶响应系统的阶跃响应</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=tf([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">y,t=step(p,np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,y)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;y&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_23_0.png" alt="png"><br>​    </p>
<h2 id="状态空间模型的时域响应"><a href="#状态空间模型的时域响应" class="headerlink" title="状态空间模型的时域响应"></a>状态空间模型的时域响应</h2><p>在状态空间模型中,我们还会考虑不同的初始值会给出什么样不同的结果</p>
<blockquote>
<p>状态空间模型(单输入,单输出)定义<br>$$\mathbf{\dot{x}}(t)&#x3D;\mathrm{A}\mathbf{x}(t)+\mathbf{B}u(t)$$<br>$$y(t)&#x3D;\mathrm{C}\mathbf{x}(t)+Du(t)$$<br>我们考虑一个系统,其中$A&#x3D;\left[\begin{matrix}0&amp;1\-4&amp;-5\end{matrix}\right],B&#x3D;\left[\begin{matrix}0\1\end{matrix}\right],C&#x3D;\left[\begin{matrix}1&amp;0\0&amp;1\end{matrix}\right],D&#x3D;\left[\begin{matrix}0\0\end{matrix}\right]$,为了便于观察中间状态的行为,将$C$设定为单位阵<br>而在Python中,可以利用<code>initial</code>函数获得系统对于初值的响应</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A=[[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">4</span>,-<span class="number">0.5</span>]]</span><br><span class="line">B=[[<span class="number">0</span>],[<span class="number">1</span>]]</span><br><span class="line">C=[[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">D=[[<span class="number">0</span>],[<span class="number">0</span>]]</span><br><span class="line">P=ss(A,B,C,D)</span><br><span class="line">x0=[-<span class="number">0.3</span>,<span class="number">0.4</span>]</span><br><span class="line">x,t=initial(P,np.linspace(<span class="number">0</span>,<span class="number">30</span>,<span class="number">1000</span>),x0)</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&#x27;$x_1$&#x27;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],<span class="string">&#x27;-.&#x27;</span>,label=<span class="string">&#x27;$x_2$&#x27;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_25_0.png" alt="png"><br>​    </p>
<p>可以注意到,两个状态(分别对应于阻尼运动的位置和速度)最终都会趋向0,这是阻尼运动的特征<br>对于一个微分方程$\dot{x}(t)&#x3D;ax(t)$,其具有解$x(t)&#x3D;e^{at}x(0)$,而将$a$替换为矩阵$\mathrm{A}$可以得到状态方程的解为<br>$$\mathbf{x}(t)&#x3D;e^{\mathrm{A}t}\mathbf{x}(0)$$<br>如果可以计算出这个指数,那么就可以得到状态方程的行为特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.linalg</span><br><span class="line">mA=np.array(A)</span><br><span class="line">t=<span class="number">10</span></span><br><span class="line">scipy.linalg.expm(mA*t)</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0.05345953,  0.03466486],
       [-0.13865943,  0.0361271 ]])
</code></pre>
<p>接下来我们考虑具有输入的情况,利用下面的求解公式<br>$$\mathrm{x}(t)&#x3D;e^{\mathrm{A}t}\mathrm{x}(0)+\int_0^te^{\mathrm{A}(t-t_s)}\mathrm{B}u(t_s)\mathrm{d}t_s$$<br>其中右边第一项为<strong>零输入响应</strong>,第二项为<strong>零初值响应</strong><br>接下来来看一下之前函数$x&#x3D;\left[\begin{matrix}0\0\end{matrix}\right]$时的零初值响应,输入为阶跃输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Td=np.linspace(<span class="number">0</span>,<span class="number">20</span>,<span class="number">1000</span>)</span><br><span class="line">x,t=step(P,Td)</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&quot;$x_1$&quot;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],ls=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&quot;$x_2$&quot;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_29_0.png" alt="png"><br>​    </p>
<p>我们可以进一步将之前的零输入响应添加进去,只要将两者相加即可,或者使用<code>lsim</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Td=np.linspace(<span class="number">0</span>,<span class="number">20</span>,<span class="number">1000</span>)</span><br><span class="line">x1,t=step(P,Td)</span><br><span class="line">x2,t=initial(P,Td,[<span class="number">0.3</span>,-<span class="number">0.4</span>])</span><br><span class="line">x=x1[...,<span class="number">0</span>]+x2</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&quot;$x_1$&quot;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],ls=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&quot;$x_2$&quot;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_31_0.png" alt="png"><br>​    </p>
<p>下面我们可以稍稍修改一下代码,实现$u(t)&#x3D;3\sin 5t,x(0)&#x3D;[0.5,1]^T$时系统响应</p>
<blockquote>
<p>对于一般的响应,建议还是使用<code>lsim</code>实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Td=np.linspace(<span class="number">0</span>,<span class="number">20</span>,<span class="number">1000</span>)</span><br><span class="line">x1=<span class="number">3</span>*np.sin(<span class="number">5</span>*Td)</span><br><span class="line">x2,t=initial(P,Td,[<span class="number">0.5</span>,<span class="number">1</span>])</span><br><span class="line">x,_,_=lsim(P,x1,Td,[<span class="number">0.5</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,x[:,<span class="number">0</span>],label=<span class="string">&quot;$x_1$&quot;</span>)</span><br><span class="line">ax.plot(t,x[:,<span class="number">1</span>],ls=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&quot;$x_2$&quot;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_33_0.png" alt="png"><br>​    </p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>在研究系统工作时,我们发现一部分值可能会导致系统发散,即系统<strong>不稳定</strong>,我们需要研究系统的稳定性取决于哪些因素 </p>
<h3 id="输入输出稳定性"><a href="#输入输出稳定性" class="headerlink" title="输入输出稳定性"></a>输入输出稳定性</h3><p>如果输入信号有界,输出也有界,这种情况被称作<strong>输入输出稳定(BIBO稳定)</strong>  </p>
<blockquote>
<p>判断不稳定的方法<br>观察传递函数$\mathcal{P}(s)$的极点(其中代数式达到无穷的情况)<br>在python中可以使用<code>pole</code>函数寻找到传递函数的极点</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P1=tf([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;P1:&quot;</span>,pole(P1))</span><br></pre></td></tr></table></figure>

<pre><code>P1: [-1.+0.j]
</code></pre>
<p>接下来看看二阶滞后函数中$K&#x3D;1,\omega_n&#x3D;1,\zeta&#x3D;0.025$时的传递函数的极点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P2=tf([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0.05</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;P2:&quot;</span>,pole(P2))</span><br></pre></td></tr></table></figure>

<pre><code>P2: [-0.025+0.99968745j -0.025-0.99968745j]
</code></pre>
<p><em><strong>系统处于输入输出稳定条件为:传递函数的所有极点实部均为负数</strong></em><br>实部为负值的极点为<strong>稳定极点</strong>,否则为<strong>不稳定极点</strong></p>
<h3 id="渐进稳定性"><a href="#渐进稳定性" class="headerlink" title="渐进稳定性"></a>渐进稳定性</h3><p>前面介绍的是相对于传递函数而言的,现在讨论状态空间模型,可以通过观察系统的A矩阵的<strong>特征值</strong>实现对稳定性的观测,则有:<br><em><strong>系统稳定的充分必要条件:矩阵A所有特征值的实部均为负数</strong></em></p>
<p>但是同时需要注意到的是这里的稳定性具有<strong>渐进</strong>的特性即<br>$$\lim_{t\to\infin}x(t)&#x3D;0$$<br>如果具有渐进稳定性,那么对于有界输入,存在有界输出(<strong>逆命题不成立</strong>)</p>
<p>使用<code>np.linalg.eigvals</code>可以求得矩阵的特征值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A=np.array([[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">4</span>,-<span class="number">5</span>]])</span><br><span class="line">np.linalg.eigvals(A)</span><br></pre></td></tr></table></figure>




<pre><code>array([-1., -4.])
</code></pre>
<p>而通过绘制相平面图(即状态$x$的演化轨迹)如下代码所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_phase</span>(<span class="params">matA,w=<span class="number">1.5</span></span>):</span><br><span class="line">    Y,X=np.mgrid[-w:w:<span class="number">100j</span>,-w:w:<span class="number">100j</span>]</span><br><span class="line">    s,v=np.linalg.eig(matA)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">    U=matA[<span class="number">0</span>,<span class="number">0</span>]*X+matA[<span class="number">0</span>,<span class="number">1</span>]*Y</span><br><span class="line">    V=matA[<span class="number">1</span>,<span class="number">0</span>]*X+matA[<span class="number">1</span>,<span class="number">1</span>]*Y</span><br><span class="line"></span><br><span class="line">    t=np.arange(-k,k,<span class="number">0.01</span>)</span><br><span class="line">    fig,ax=plt.subplots()</span><br><span class="line">    <span class="keyword">if</span> s.imag[<span class="number">0</span>]==<span class="number">0</span> <span class="keyword">and</span> s.imag[<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">        ax.plot(t,(v[<span class="number">1</span>,<span class="number">0</span>]/v[<span class="number">0</span>,<span class="number">0</span>])*t,ls=<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        ax.plot(t,(v[<span class="number">1</span>,<span class="number">1</span>]/v[<span class="number">0</span>,<span class="number">1</span>])*t,ls=<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    ax.streamplot(X,Y,U,V,density=<span class="number">0.7</span>,color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plot_set(ax,<span class="string">&#x27;$x_1$&#x27;</span>,<span class="string">&#x27;$x_2&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>先来刚刚那个矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">make_phase(A,w=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code>[-1. -4.]
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_45_1.png" alt="png"></p>
<p>可以注意到,所有的箭头都指向不动线的,下面展示如果特征值大于零会如何</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">make_phase(np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>]]),w=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code>[-0.23606798  4.23606798]
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_47_1.png" alt="png"></p>
<p>还有没有实数特征值的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">make_phase(np.array([[np.cos(<span class="number">0.5</span>),np.sin(<span class="number">0.5</span>)],[-np.sin(<span class="number">0.5</span>),np.cos(<span class="number">0.5</span>)]]),w=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code>[0.87758256+0.47942554j 0.87758256-0.47942554j]
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_49_1.png" alt="png"></p>
<p>这些极点和系统行为密切相关,若极点负值越大,那么<strong>响应越迅速</strong></p>
<p>当极点的虚部不为零时,会出现振荡,虚部越大<strong>振荡越快</strong></p>
<p>观察实部,可以得到振荡<strong>振幅</strong>;观察虚部,可以得到振荡<strong>周期</strong></p>
<h2 id="频域响应"><a href="#频域响应" class="headerlink" title="频域响应"></a>频域响应</h2><p>当输入为<strong>冲激输入</strong>(函数形式为$\delta$函数)时,系统的响应就是传递函数,因此只需要对施加冲激输入后的系统响应进行拉普拉斯变换就可以得到传递函数</p>
<p>但是在现实状况下,实现冲激输入非常困难,因此我们需要对信号进行傅里叶变换,研究输入输出的频域响应得到结果</p>
<p>我们可以观察二阶滞后系统在输入正弦波时的响应</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">zeta=<span class="number">0.7</span></span><br><span class="line">omega_n=<span class="number">5</span></span><br><span class="line">P=tf([<span class="number">0</span>,omega_n**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*zeta*omega_n,omega_n**<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">freq=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">Td=np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        u=np.sin(freq[<span class="number">2</span>*i+j]*Td)</span><br><span class="line">        y,t,x0=lsim(P,u,Td,<span class="number">0</span>)</span><br><span class="line">        ax[i,j].plot(t,u,ls=<span class="string">&#x27;--&#x27;</span>,label=<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">        ax[i,j].plot(t,y,label=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        plot_set(ax[i,j],<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u,y&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>,<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\timeresp.py:935: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.
  warnings.warn(
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\timeresp.py:935: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.
  warnings.warn(
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\timeresp.py:935: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.
  warnings.warn(
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\timeresp.py:935: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.
  warnings.warn(





&lt;matplotlib.legend.Legend at 0x1aa4e6be160&gt;
</code></pre>
<p>​<br><img src="/2023/01/15/control%20system/control2/output_53_2.png" alt="png"><br>​    </p>
<p>可以注意到随着频率逐渐增大,振幅逐渐减小,同时相位的滞后就会比较大</p>
<p>对于各个频率,振幅比以$20\log_10\frac{B(\omega)}{A}$(分贝,dB)表示,绘制出图象为幅频图<br>将相位(deg)绘出的图形称为相频图,两者合称伯德图</p>
<blockquote>
<p>可以使用<code>bode</code>获得伯德图(记得转换)</p>
</blockquote>
<h3 id="一阶滞后系统的频域响应"><a href="#一阶滞后系统的频域响应" class="headerlink" title="一阶滞后系统的频域响应"></a>一阶滞后系统的频域响应</h3><p>下面我们来研究一阶滞后系统的伯德图,我们分别取时间常数$T&#x3D;1,0.5,0.1$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K=<span class="number">1</span></span><br><span class="line">T=[<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.1</span>]</span><br><span class="line">Ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line">    P=tf([<span class="number">0</span>,K],[T[i],<span class="number">1</span>])</span><br><span class="line">    gain,phase,w=bode(P,logspace(-<span class="number">2</span>,<span class="number">2</span>),Plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(Ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;T=&#x27;</span>+<span class="built_in">str</span>(T[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_56_1.png" alt="png"></p>
<p>可以注意到,随着频率的提高,输出信号会发生衰减和相移,时间常数$T$越大,衰减和相移越为明显</p>
<blockquote>
<p>这很好理解,时间常数越大,代表响应越慢,自然衰减和相移就大  </p>
</blockquote>
<p>一般可以认为,在$\frac{1}{T}$的范围之内,输入信号振幅与输出信号相似(此时相移45°)</p>
<h2 id="二阶滞后系统的频域响应"><a href="#二阶滞后系统的频域响应" class="headerlink" title="二阶滞后系统的频域响应"></a>二阶滞后系统的频域响应</h2><p>在这一部分,我们来研究一下二阶滞后系统的频域响应,取阻尼系数$\zeta&#x3D;1,0.7,0.4$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zeta=[<span class="number">1</span>,<span class="number">0.7</span>,<span class="number">0.4</span>]</span><br><span class="line">omega=<span class="number">1</span></span><br><span class="line">Ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line">    P=tf([<span class="number">0</span>,omega**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*zeta[i]*omega,omega**<span class="number">2</span>])</span><br><span class="line">    gain,phase,w=bode(P,logspace(-<span class="number">2</span>,<span class="number">2</span>),Plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(Ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$\zeta$=&#x27;</span>+<span class="built_in">str</span>(T[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_59_1.png" alt="png"></p>
<p>通过观察伯德图,我们可以得到在高频段振幅会逐渐减小,虽然在较高频下振幅的衰减与$\zeta$无关,但是如果$\zeta$较低,会出现过冲(类似于共振)<br>相位在二姐滞后系统最终会移相180°</p>
<p>我们再来看看改变频率$\omega_n$的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zeta=<span class="number">0.5</span></span><br><span class="line">omega=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">Ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line">    P=tf([<span class="number">0</span>,omega[i]**<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>*zeta*omega[i],omega[i]**<span class="number">2</span>])</span><br><span class="line">    gain,phase,w=bode(P,logspace(-<span class="number">2</span>,<span class="number">2</span>),Plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(Ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$\omega$=&#x27;</span>+<span class="built_in">str</span>(T[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
C:\Users\h\AppData\Roaming\Python\Python39\site-packages\control\freqplot.py:187: FutureWarning: &#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;
  warnings.warn(&quot;&#39;Plot&#39; keyword is deprecated in bode_plot; use &#39;plot&#39;&quot;,
</code></pre>
<p><img src="/2023/01/15/control%20system/control2/output_61_1.png" alt="png"></p>
<p>可以注意到,随着$\omega_n$的增大,其相移和衰减的程度都下降了,而在固有频率处,刚好相移为90°</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P=tf([<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">b=bode(P,logspace(-<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/15/control%20system/control2/output_63_0.png" alt="png"><br>​    </p>
]]></content>
      <categories>
        <category>Python设计控制系统</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用scikit-learn进行分类学习</title>
    <url>/2023/01/26/machine-learning/machine2/</url>
    <content><![CDATA[<p>在前面一部分,我们构造了几种分类算法,而在这一部分,我们将介绍利用<code>scikit-learn</code>提供的便于使用的接口进行机器学习<br>将分成以下几个部分进行介绍:</p>
<ol>
<li>对具有良好稳定性的常用分类算法的介绍,例如<code>logistic</code>回归算法,支持向量机,决策树</li>
<li>一些使用<code>scikit-learn</code>进行一些常见的应用</li>
<li>对于线性与非线性决策边界的优势与劣势的讨论</li>
</ol>
<h2 id="选取分类算法"><a href="#选取分类算法" class="headerlink" title="选取分类算法"></a>选取分类算法</h2><p>俗话说:天下没有免费的午餐,不同的分类算法具有相应的优势与劣势,在选择的时候需要充分考虑数据的特征以及目的,一般来说,训练一个机器学习模型可以分为以下五步</p>
<ol>
<li>选取特征收集训练数据</li>
<li>选取一个表示矩阵</li>
<li>选取一个分类与优化算法</li>
<li>计算这个算法的效果</li>
<li>改良这个算法</li>
</ol>
<span id="more"></span>

<h2 id="使用scikit-learn训练一个算法"><a href="#使用scikit-learn训练一个算法" class="headerlink" title="使用scikit-learn训练一个算法"></a>使用<code>scikit-learn</code>训练一个算法</h2><p>为了快速使用<code>scikit-learn</code>库,我们将延续前面的例子,使用那个花的分类模型进行练习<br>我们这次将从<code>sklearn</code>的<code>datasets</code>库中加载数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">iris=datasets.load_iris()</span><br><span class="line">X=iris.data[:,[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">y=iris.target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Class labels:&quot;</span>,np.unique(y))</span><br></pre></td></tr></table></figure>

<pre><code>Class labels: [0 1 2]
</code></pre>
<p>在这里,我们可以发现,数据被分成了三类(为了妥善处理内存问题并且加快速度,一般只会拿整数进行标号)</p>
<p>为了更好的判断一个数据集训练的有多好,我们将数据分割成训练集和测试集(这一部分在未来会进一步讨论)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain,Xtest,ytrain,ytest=train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>,stratify=y)</span><br></pre></td></tr></table></figure>

<p><code>stratify</code>的指定表明在分割的训练集与测试集中,<code>y</code>的三种不同值被均等分割</p>
<p>相似的,为了更好的进行机器学习,我们需要对数据进行标准化处理,在这里,我们使用正态分布进行标准化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc=StandardScaler()</span><br><span class="line">sc.fit(Xtrain)</span><br><span class="line">X_train_std=sc.transform(Xtrain)</span><br><span class="line">X_test_std=sc.transform(Xtest)</span><br></pre></td></tr></table></figure>

<p>需要注意,我们要对训练集和测试集采用相同的归一化手段,这样可以才能实现统一</p>
<p>接下来我们就可以进行训练了.我们在这里使用<code>OvR</code>方法对多分类问题进行处理,代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br><span class="line">ppn=Perceptron(n_iter_no_change=<span class="number">100</span>,eta0=<span class="number">1e-3</span>,random_state=<span class="number">1</span>)</span><br><span class="line">ppn.fit(X_train_std,ytrain)</span><br></pre></td></tr></table></figure>




<pre><code>Perceptron(eta0=0.001, n_iter_no_change=100, random_state=1)
</code></pre>
<p>就像前面所说的一样,我们需要正确的选择学习率,如果学习率过高,那么模型会跳过全局最低点,而如果学习率过低,学习速率又会太低.</p>
<p>我们可以使用<code>predict</code>对训练后的模型进行预测,例如以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred=ppn.predict(X_test_std)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Miss classfied samples:&#123;&#125;&quot;</span>.<span class="built_in">format</span>((ytest!=y_pred).<span class="built_in">sum</span>()))</span><br></pre></td></tr></table></figure>

<pre><code>Miss classfied samples:1
</code></pre>
<p>当然,<code>scikit-learn</code>库里面也内置了处理学习准确率的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %.2f&#x27;</span>%accuracy_score(ytest,y_pred))</span><br></pre></td></tr></table></figure>

<pre><code>Accuracy: 0.97
</code></pre>
<p>接下来,我们仿照上一章的例子,编写决策区间的绘图函数</p>
<blockquote>
<p>在其中,我们添加了一些修改来展现出数据是来自于<em>测试集</em>的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_decision_regions</span>(<span class="params">X,y,classifier,resolution=<span class="number">0.02</span>,test=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment">#setup marker generator and color map</span></span><br><span class="line">    markers = (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">    colors = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;lightgreen&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>)</span><br><span class="line">    cmap = ListedColormap(colors[:<span class="built_in">len</span>(np.unique(y))])<span class="comment"># unique函数可以找到所有独立的元素</span></span><br><span class="line">    <span class="comment">#plot the surface</span></span><br><span class="line">    x1_min,x1_max=X[:,<span class="number">0</span>].<span class="built_in">min</span>()-<span class="number">1</span>,X[:,<span class="number">0</span>].<span class="built_in">max</span>()+<span class="number">1</span></span><br><span class="line">    x2_min,x2_max=X[:,<span class="number">1</span>].<span class="built_in">min</span>()-<span class="number">1</span>,X[:,<span class="number">1</span>].<span class="built_in">max</span>()+<span class="number">1</span><span class="comment">#X1,X2分别是X轴Y轴</span></span><br><span class="line">    xx1,xx2=np.meshgrid(np.arange(x1_min,x1_max,resolution),</span><br><span class="line">                        np.arange(x2_min,x2_max,resolution))</span><br><span class="line">    Z=classifier.predict(np.array([xx1.ravel(),xx2.ravel()]).T)<span class="comment">#这里要将数组展平(这里面的向量操作非常有趣)</span></span><br><span class="line">    Z=Z.reshape(xx1.shape)</span><br><span class="line">    plt.contourf(xx1,xx2,Z,alpha=<span class="number">0.3</span>,cmap=cmap)</span><br><span class="line">    plt.xlim(xx1.<span class="built_in">min</span>(),xx1.<span class="built_in">max</span>())</span><br><span class="line">    plt.ylim(xx2.<span class="built_in">min</span>(),xx2.<span class="built_in">max</span>())</span><br><span class="line">    <span class="comment">#plot class samples</span></span><br><span class="line">    <span class="keyword">for</span> idx,cl <span class="keyword">in</span> <span class="built_in">enumerate</span>(np.unique(y)):<span class="comment">#这里使用enumerate来同时获得标签</span></span><br><span class="line">        plt.scatter(x=X[y==cl,<span class="number">0</span>],</span><br><span class="line">                    y=X[y==cl,<span class="number">1</span>],</span><br><span class="line">                    alpha=<span class="number">0.8</span>,</span><br><span class="line">                    c=colors[idx],</span><br><span class="line">                    marker=markers[idx],</span><br><span class="line">                    label=cl,</span><br><span class="line">                    edgecolors=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> test:</span><br><span class="line">        <span class="comment">#将测试集标记出来</span></span><br><span class="line">        plt.scatter(x=X[:,<span class="number">0</span>],</span><br><span class="line">                    y=X[:,<span class="number">1</span>],</span><br><span class="line">                    alpha=<span class="number">1</span>,</span><br><span class="line">                    s=<span class="number">100</span>,</span><br><span class="line">                    marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">                    edgecolors=<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                    c=<span class="string">&#x27;None&#x27;</span>)<span class="comment">#这里颜色的设定需要专门注意</span></span><br></pre></td></tr></table></figure>

<p>我们可以将刚才训练的模型的效果展示出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_decision_regions(X_train_std,ytrain,ppn)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,ppn,test=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_17_1.png" alt="png"></p>
<h2 id="使用logistic回归构建类模型"><a href="#使用logistic回归构建类模型" class="headerlink" title="使用logistic回归构建类模型"></a>使用logistic回归构建类模型</h2><p>虽然我们之前构建的分类算法在机器学习分类中非常好用,但是这中间有个非常严重的问题,那就是当几个类不能被线性分割时,将永远不会收敛</p>
<p>为了节约我们的时间,我们将介绍另外一种强而有力的线性分类模型:logistic回归模型</p>
<blockquote>
<p>需要注意,这里虽然用了”回归”这个名字,但是算法是用来分类的</p>
</blockquote>
<h3 id="logistic回归的介绍和条件概率"><a href="#logistic回归的介绍和条件概率" class="headerlink" title="logistic回归的介绍和条件概率"></a>logistic回归的介绍和条件概率</h3><p>为了理解logistic回归,我们首先介绍<em>比值比</em>,比值比可以被写作$\frac{p}{1-p}$(其中$p$是我们所想预测的概率),接下来我们就可以定义比值比的对数<br>$$logit(p)&#x3D;\log\frac{p}{1-p}$$<br>需要注意到,我们可以将发生预测事件分类为$y&#x3D;1$,认为某一特征与$logit(p(y&#x3D;1|x))$之间呈现线性关系</p>
<p>而我们的工作是预测某一个样本属于某一类的可能性,即从比值比的对数求$p$,那么我们可以使用一个s型生长曲线<br>$$\phi(z)&#x3D;\frac{1}{1+e^{-z}}$$<br>其中$z$是输入,为$z&#x3D;w^Tx$</p>
<p>为了更加直观的看出这个的效果,我们首先绘制一幅s型生长曲线的图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+<span class="number">1.0</span>*np.exp(-x))</span><br><span class="line">x=np.linspace(-<span class="number">7</span>,<span class="number">7</span>,<span class="number">1000</span>)</span><br><span class="line">phix=sigmoid(x)</span><br><span class="line">plt.plot(x,phix)</span><br><span class="line">plt.axvline(<span class="number">0.0</span>,c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.ylim(-<span class="number">0.1</span>,<span class="number">1.1</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$\phi (z)$&#x27;</span>)</span><br><span class="line"><span class="comment">#y axis ticks and gridline</span></span><br><span class="line">plt.yticks([<span class="number">0.0</span>,<span class="number">0.5</span>,<span class="number">1.0</span>])</span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.yaxis.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/26/machine-learning/machine2/scikit-learn_20_0.png" alt="png"><br>​    </p>
<p>我们可以仿照上一章的例子,就是将<code>ADaline</code>中的线性函数变成了生长曲线,而对于生长曲线的输出则是以0.5为阈值大于0.5为1,小于0.5为0</p>
<h3 id="学习logistic误差函数"><a href="#学习logistic误差函数" class="headerlink" title="学习logistic误差函数"></a>学习<code>logistic</code>误差函数</h3><p>接下来我们讨论如何拟合模型中的参数,我们之前定义过平方和误差函数<br>$$J(\omega)&#x3D;\sum_i\frac{1}{2}(\phi(z^{(i)}-y^{(i)})^2$$<br>我们的目的就是让这个函数值最小,首先我们需要定义在已知$x$下,$y$的后验概率分布<br>$$L(\omega)&#x3D;P(y|x;\omega)&#x3D;\Pi_{i&#x3D;1}^nP(y^{(i)}|x^{(i)};\omega)&#x3D;\Pi_{i&#x3D;1}^n(\phi(z^{(i)}))^{y^{(i)}}(1-\phi(z^{(i)}))^{1-y^{(i)}}$$<br>对于实际应用之中,往往取对数可以让问题更加方便,因此最后误差函数在定义时就可以被写作:<br>若$y&#x3D;1$则为$-\log(\phi(z))$,若$y&#x3D;0$则为$-\log(1-\phi(z))$<br>这么做的好处在于,我们对于错误的估计,误差函数会逐渐加大,从下面这张图可以看出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cost_0</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> -np.log(sigmoid(z))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cost_1</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> -np.log(<span class="number">1</span>-sigmoid(z))</span><br><span class="line">z=np.arange(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">phiz=sigmoid(z)</span><br><span class="line">c0=cost_0(z)</span><br><span class="line">c1=cost_1(z)</span><br><span class="line">plt.plot(phiz,c1,<span class="string">&quot;-&quot;</span>,label=<span class="string">&#x27;J(w) if y=1&#x27;</span>)</span><br><span class="line">plt.plot(phiz,c0,<span class="string">&quot;--&quot;</span>,label=<span class="string">&#x27;J(w) if y=0&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;$\phi(z)$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;J(w)&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/26/machine-learning/machine2/scikit-learn_22_0.png" alt="png"><br>​    </p>
<h3 id="将Adaline内置logistic回归"><a href="#将Adaline内置logistic回归" class="headerlink" title="将Adaline内置logistic回归"></a>将<code>Adaline</code>内置logistic回归</h3><p>我们在之前的<code>Adaline</code>算法中,可以做出以下修改:</p>
<p><img src="/2023/01/26/machine-learning/machine2/image-20230126003038092.png" alt="png"></p>
<ol>
<li>将线性激发函数修改为生长激发函数</li>
<li>修改分类阈值从-1到1修改为0到1</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TODO 这些内容还需要修改,未来改一下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogisticRegressionGD</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,eta=<span class="number">0.001</span>,n_iter=<span class="number">100</span>,random_state=<span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.eta=eta</span><br><span class="line">        self.n_iter=n_iter</span><br><span class="line">        self.random_state=random_state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        rgen=np.random.RandomState(self.random_state)</span><br><span class="line">        self.w_=rgen.normal(<span class="number">0.0</span>,<span class="number">0.1</span>,size=<span class="number">1</span>+X.shape[<span class="number">1</span>])</span><br><span class="line">        self.cost_=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iter):</span><br><span class="line">            err,errg,errw0=self._calc_cost(X,y)</span><br><span class="line">            self.cost_.append(err)</span><br><span class="line">            self.w_[<span class="number">1</span>:]+=-self.eta*errg</span><br><span class="line">            self.w_[<span class="number">0</span>]+=-self.eta*errw0</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calc_cost</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        yp=(np.dot(X,self.w_[<span class="number">1</span>:].reshape(-<span class="number">1</span>,<span class="number">1</span>))+self.w_[<span class="number">0</span>]).reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#print(yp)</span></span><br><span class="line">        err=np.<span class="built_in">sum</span>((yp[<span class="number">0</span>]-y)**<span class="number">2</span>)/<span class="number">2</span></span><br><span class="line">        errg=np.dot((yp[<span class="number">0</span>]-y),X)</span><br><span class="line">        errw0=np.<span class="built_in">sum</span>(yp[<span class="number">0</span>]-y)</span><br><span class="line">        <span class="keyword">return</span> err,errg[<span class="number">0</span>],errw0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.where(np.dot(X,self.w_[<span class="number">1</span>:])+self.w_[<span class="number">0</span>]&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用scikit-learn训练一个回归模型"><a href="#使用scikit-learn训练一个回归模型" class="headerlink" title="使用scikit-learn训练一个回归模型"></a>使用<code>scikit-learn</code>训练一个回归模型</h3><p>我们刚才的讨论是基于数学计算上的区别,现在我们来介绍一下如何使用<code>scikit-learn</code>来训练一个回归模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">lr=LogisticRegression(C=<span class="number">100.0</span>,random_state=<span class="number">1</span>)<span class="comment">#?这个C是</span></span><br><span class="line">lr.fit(X_train_std,ytrain)</span><br><span class="line">plot_decision_regions(X_train_std,ytrain,classifier=lr)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,classifier=lr,test=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_26_1.png" alt="png"></p>
<p>我们在看这个问题的时候,会很好奇这个训练参数<code>C</code>是什么东西,我们将在下一小节介绍这个问题</p>
<blockquote>
<p>这个问题主要涉及到关于过拟合和欠拟合</p>
</blockquote>
<p>我们还可以计算出每一个元素属于某一类的概率,需要使用<code>predict_proba</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr.predict_proba(X_test_std[:<span class="number">3</span>,:])*<span class="number">100</span><span class="comment">#这里乘100为了方便用百分数</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[5.83527138e-11, 4.26528227e-03, 9.99957347e+01],
       [9.99623181e+01, 3.76819349e-02, 3.51225598e-17],
       [2.32430493e+00, 9.76756905e+01, 4.61949531e-06]])
</code></pre>
<p>相应的,我们可以用这个来进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr.predict_proba(X_test_std[:<span class="number">3</span>,:]).argmax(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 0, 1], dtype=int64)
</code></pre>
<blockquote>
<p><strong>一个需要注意的问题</strong><br>在使用<code>predict</code>时,如果预测是一个单一样本,那么就需要进行<code>reshape</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr.predict(X_test_std[<span class="number">0</span>,:].reshape(<span class="number">1</span>,-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([2])
</code></pre>
<h3 id="通过正则化处理过拟合"><a href="#通过正则化处理过拟合" class="headerlink" title="通过正则化处理过拟合"></a>通过正则化处理过拟合</h3><p>过拟合在机器学习中是一个常见的问题,<strong>过拟合</strong>主要来自于过于复杂的模型,模型非常容易受到一噪音的影响,而<strong>欠拟合</strong>则是相反的情况,主要来自于过于简单的模型约束过多<br> <img src="/2023/01/26/machine-learning/machine2/image-20230126003240978.png" alt="image-20230126003240978"><br>虽然我们现在讨论的是线性模型,但是很快我们就会遇到一些更加复杂的决策区间<br>这个时候我们就需要使用正则化来调节模型的自由度,这种手段可以有效的处理特征之间的相关性,消除数据误差和防止过拟合有重要作用</p>
<p>正则化的原理是通过添加约束来消除极端变量的值,最为常用的是<code>L2正则化</code>,可以被写成下式<br>$$\frac{\lambda}{2}||\omega||^2&#x3D;\frac{\lambda}{2}\sum_{j&#x3D;1}^m\omega_j^2$$<br>那么我们之前所使用的损失函数就可以被加上这一项$\frac{\lambda}{2}||\omega||^2$</p>
<blockquote>
<p>这个有点像拉格朗日乘子法,添加了一个约束,但是这个$\lambda$是一个预先设定好的量<br>而如果$\lambda$越大,正则化强度越高,之前的参数$C$就是和这个密切相关,是它的倒数<br>我们用绘制两个参数随着$C$变化的变化展示<code>L2正则化</code>强度对机器学习结果的影响</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weights,params=[],[]</span><br><span class="line">lrl=[]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.5</span>):</span><br><span class="line">    lr=LogisticRegression(C=<span class="number">10.</span>**c,random_state=<span class="number">1</span>)</span><br><span class="line">    lr.fit(X_train_std,ytrain)</span><br><span class="line">    weights.append(lr.coef_[<span class="number">1</span>])</span><br><span class="line">    params.append(<span class="number">10.</span>**c)</span><br><span class="line">weights=np.array(weights)</span><br><span class="line">plt.plot(params,weights[:,<span class="number">0</span>],label=<span class="string">&#x27;petal length&#x27;</span>)</span><br><span class="line">plt.plot(params,weights[:,<span class="number">1</span>],label=<span class="string">&#x27;petal width&#x27;</span>,linestyle=<span class="string">&quot;--&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;cofficient&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/26/machine-learning/machine2/scikit-learn_34_0.png" alt="png"><br>​    </p>
<p>可以注意到,$C$越小,相应的正则化强度越高,导致参数越大</p>
<h2 id="使用支持向量机处理最大边界问题"><a href="#使用支持向量机处理最大边界问题" class="headerlink" title="使用支持向量机处理最大边界问题"></a>使用支持向量机处理最大边界问题</h2><p>另外一个强力而广泛应用的算法是<strong>支持向量机算法</strong><code>Support Vector Machine(SVM)</code>,这可以被看做是感知机的升级版.<br>在感知机算法中,我们的目标是让误分类误差尽量小,但是在支持向量机算法中,我们的目标是让边界最大</p>
<p>边界被定义为决策边界和离决策边界最近的点的距离,又被称作<strong>支持向量</strong><code>support vectors</code>,下图可以展现出来<br><img src="/2023/01/26/machine-learning/machine2/image-20230126003135775.png" alt="png"></p>
<h3 id="最大边界"><a href="#最大边界" class="headerlink" title="最大边界"></a>最大边界</h3><p>大的边界在于这种手段可以得到尽量小的整体误差,但是小的边界更加容易发生过拟合.为了更好地理解最大边界,我们来考量一下<em>正负决策边界</em>,这些边界与决策边界平行,可以用下式来表述<br>$$\omega_0+\omega^Tx_{pos}&#x3D;1$$<br>(到标号为1的点的分割面)<br>$$\omega_0+\omega^Tx_{neg}&#x3D;-1$$<br>(到标号为-1的点的分割面)<br>假如我们两式相减,我们可以得到<br>$$\omega^T(x_{pos}-x_{neg})&#x3D;2$$<br>我们可以借助$\omega$的长度对这个式子进行归一化<br>$$\frac{\omega^T(x_{pos}-x_{neg})}{||\omega||}&#x3D;\frac{2}{||\omega||}$$<br>左侧的式子可以被看做正负决策边界的距离,这就是我们希望最大化的东西</p>
<p>现在,问题就转变为让$\frac{2}{||\omega||}$最大(前提是可以使用两个面的分开,满足对于所有的i有 $y^{(i)}(\omega_0+\omega^Tx^{(i)})\ge 1$ 这样的约束(线性约束))<br>在实际问题中,往往使用<em>二次规划</em>来解决这个问题,但这实在是有点复杂,我们不再涉及</p>
<h3 id="通过添加松弛变量应对无法线性完全分类问题"><a href="#通过添加松弛变量应对无法线性完全分类问题" class="headerlink" title="通过添加松弛变量应对无法线性完全分类问题"></a>通过添加松弛变量应对无法线性完全分类问题</h3><p>我们来简单介绍松弛变量$\xi$,这种被称作<strong>软边界分类问题</strong>.引入松弛变量的目的是线性约束需要被松弛来解决无法线性完全分类问题来实现对存在误分类的优化</p>
<p>正值松弛变量就是简单的减在线性约束上<br>$$y^{(i)}(\omega_0+\omega^Tx^{(i)})\ge 1-\xi^{(i)}$$<br>因此新的最优化问题可以被看做让以下式子最小<br>$$\frac{1}{2}||\omega||^2+C(\sum_i \xi^{(i)})$$<br>通过修改$C$,我们可以控制错误分类的<strong>惩罚</strong>,下面这张图展示了不同的$C$的效果<br><img src="attachment:image.png" alt="image.png"><br>这一观念与正则化有关,就像我们所讨论的$C$一样,减少$C$的值会增加约束并减少自由度<br>现在,我们来训练一个支持向量机的模型来给花分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm=SVC(kernel=<span class="string">&#x27;linear&#x27;</span>,C=<span class="number">1.0</span>,random_state=<span class="number">1</span>)</span><br><span class="line">svm.fit(X_train_std,ytrain)</span><br><span class="line">plot_decision_regions(X_train_std,ytrain,classifier=svm)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,classifier=svm,test=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length [standardized]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width [standardized]&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_39_1.png" alt="png"></p>
<h3 id="在scikit-learn中作为代替的实现"><a href="#在scikit-learn中作为代替的实现" class="headerlink" title="在scikit-learn中作为代替的实现"></a>在<code>scikit-learn</code>中作为代替的实现</h3><p>在一些特殊的情况下(比如数据集奇大无比),可以去参考<code>SGDClassifier</code>实现</p>
<h2 id="使用一个SVM核来解决非线性问题"><a href="#使用一个SVM核来解决非线性问题" class="headerlink" title="使用一个SVM核来解决非线性问题"></a>使用一个SVM核来解决非线性问题</h2><p>支持向量机方法如此流行还有一个原因在于支持向量机可以非常轻易的被内核化(<code>kernelized</code>),在我们深入讨论SVM核的数学机理之前,我们首先来看一个例子</p>
<h3 id="对无法线性区分的数据的核方法"><a href="#对无法线性区分的数据的核方法" class="headerlink" title="对无法线性区分的数据的核方法"></a>对无法线性区分的数据的核方法</h3><p>在接下来的数据集中,我们将创建一个简单的X状数据使用<code>logical_xor</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">X_xor=np.random.randn(<span class="number">200</span>,<span class="number">2</span>)</span><br><span class="line">y_xor=np.logical_xor(X_xor[:,<span class="number">0</span>]&gt;<span class="number">0</span>,X_xor[:,<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">y_xor=np.where(y_xor,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">plt.scatter(X_xor[y_xor==<span class="number">1</span>,<span class="number">0</span>],X_xor[y_xor==<span class="number">1</span>,<span class="number">1</span>],c=<span class="string">&#x27;b&#x27;</span>,marker=<span class="string">&#x27;x&#x27;</span>,label=<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">plt.scatter(X_xor[y_xor==-<span class="number">1</span>,<span class="number">0</span>],X_xor[y_xor==-<span class="number">1</span>,<span class="number">1</span>],c=<span class="string">&#x27;r&#x27;</span>,marker=<span class="string">&#x27;s&#x27;</span>,label=<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">plt.xlim([-<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.ylim([-<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/26/machine-learning/machine2/scikit-learn_43_0.png" alt="png"><br>​    </p>
<p>可以看出来,这两种数据有着显著的区别,但是又明显不能线性区分开来,这个时候就要使用<code>核</code>来解决问题</p>
<p>对于核方法最为简单的解释就是将数据通过指定的<strong>非线性</strong>组合,扩展到高维,然后在高维就可以实现区分,即<br>$$\phi(x_1,x_2)&#x3D;(z_1,z_2,z_3)&#x3D;(x_1,x_2,x_1^2+x_2^2)$$<br>而这样做的效果用下面一张图可以很好的体现出来<br>原<img src="/2023/01/26/machine-learning/machine2/image-20230126003317498.png" alt="png">本区分不开的两簇点通过扩展到三维很轻易地区分开来</p>
<h3 id="使用核方法在高维空间中找到决策边界"><a href="#使用核方法在高维空间中找到决策边界" class="headerlink" title="使用核方法在高维空间中找到决策边界"></a>使用核方法在高维空间中找到决策边界</h3><p>为了处理上述问题,我们首先需要利用一个投影函数$\phi$将训练数据投影到高维空间,然后再训练一个支持向量机模型,最后再将原本的投影函数取反来进行预测.</p>
<p>然而,这种方法说起来简单,但是实际运作起来(尤其是面对高维数据)非常困难,因此我们需要使用到<strong>核技巧</strong>(<code>kernel trick</code>),核技巧的数学原理再次不再过多涉及  </p>
<blockquote>
<p>核函数可以被看做给向量空间定义了一个全新的点乘<br>粗略地说,核这个词可以被理解为<strong>一对样本之间的关联函数</strong>,例如说最为常用的高斯核函数<code>Gaussian kernel</code>就是如下定义:<br>$$\mathcal{K}(x^{(i)},x^{(j)})&#x3D;exp\left(-\frac{||x^{(i)}-x^{(j)}||^2}{2\sigma^2}\right)$$<br>(其中的$\sigma$是一个拟合自由度)其得到样本中两个样本差距的模长,并且取$e$的负指数来实现定义两个样本之间的相近程度</p>
</blockquote>
<p>现在我们来看刚才的问题,我们来试试高斯核能不呢解决这个问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svm=SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>,random_state=<span class="number">1</span>,gamma=<span class="number">0.1</span>,C=<span class="number">10</span>)</span><br><span class="line">svm.fit(X_xor,y_xor)</span><br><span class="line">plot_decision_regions(X_xor,y_xor,classifier=svm)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_46_1.png" alt="png"></p>
<p>而我们使用的$\gamma$参数,可以被理解为<strong>切断参数</strong>,$\gamma$越大,我们会得到一个越紧凑的决策边界,我们可以拿之前那个花分类的问题来进行讨论</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svm=SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>,random_state=<span class="number">1</span>,gamma=<span class="number">0.2</span>,C=<span class="number">1.0</span>)</span><br><span class="line">svm.fit(X_train_std,ytrain)</span><br><span class="line">plot_decision_regions(X_train_std,ytrain,svm)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,svm,test=<span class="literal">True</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_48_1.png" alt="png"></p>
<p>因为我们的$\gamma$值比较小,所以看起来还不错,接下来,我们把$\gamma$放大,看看会怎么样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svm=SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>,random_state=<span class="number">1</span>,gamma=<span class="number">100</span>,C=<span class="number">1.0</span>)</span><br><span class="line">svm.fit(X_train_std,ytrain)</span><br><span class="line">plot_decision_regions(X_train_std,ytrain,svm)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,svm,test=<span class="literal">True</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_50_1.png" alt="png"></p>
<p>虽然这种拟合在训练集上很有用,但是无法用在测试集上</p>
<blockquote>
<p>这样的东西,能不能做聚类</p>
</blockquote>
<h2 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h2><p>如果我们非常在乎可解释性的话,<strong>决策树</strong>(<code>Decision tree</code>)分类器是非常吸引人的模型,正如名字所预示的那样,我们可以考虑将数据通过做出一些决策而进行分解,以下面一个决定某一天是否要做某件事的决策树为例:<br><img src="/2023/01/26/machine-learning/machine2/image-20230126003438905.png" alt="png"><br>相似的,对于连续变化的数据,我们可以定义一个阈值来进行决策</p>
<p>在实际应用中,我们从树根开始,对于可以导致<strong>最大学习增加</strong>(<code>largest IG</code>)进行分类(这在之后会详细介绍),然后对每一个分支重复这个过程,直到树变得整洁</p>
<blockquote>
<p>然而这样做在实际情况下往往会导致过拟合,因此我们需要通过设定最大深度对树进行修剪</p>
</blockquote>
<h3 id="最大化信息增加"><a href="#最大化信息增加" class="headerlink" title="最大化信息增加"></a>最大化信息增加</h3><p>为了准确地分隔节点,我们需要定义一个最优化函数来处理决策树学习算法.在这里,我们决策树的目的是尽可能增加<strong>信息</strong>,信息量定义如下:<br>$$IG(D_p,f)&#x3D;I(D_p)-\sum_{j&#x3D;1}^m\frac{N_j}{N_p}I(D_j)$$<br>式中$f$是实行分割的特征,$D_p$和$D_j$是父节点对应数据集和第$j$个子节点数据集,而$I$就是我们的<strong>不纯</strong>度,我们可以看出,所谓信息的增加就是父节点和子节点不纯度和之差,子节点不纯度越小,信息量增加越大</p>
<blockquote>
<p>不过在实际使用过程中,为了简明起见,编译器往往会使用二分法进行分类</p>
</blockquote>
<p>现在我们来介绍经常被使用的三种不纯度的度量($t$为节点)</p>
<ol>
<li>基尼不纯度$I_G&#x3D;1-\sum p(i|t)^2$</li>
<li>信息熵$I_H&#x3D;-\sum p(i|t)\log_2p(i|t)$</li>
<li>分类误差$I_E&#x3D;1-\max{p(i|t)}$<br>1,2往往能够获得相似的结果,而3往往被用在修建上而非生长上</li>
</ol>
<p>下面这张图可以展现出三种度量方式的特性(对于二分类样本)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gini</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> p*(<span class="number">1</span>-p)+(<span class="number">1</span>-p)*(<span class="number">1</span>-(<span class="number">1</span>-p))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">entropy</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> -p*np.log2(p)-(<span class="number">1</span>-p)*np.log2(<span class="number">1</span>-p)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>-np.<span class="built_in">max</span>([p,<span class="number">1</span>-p],axis=<span class="number">0</span>)</span><br><span class="line">x=np.arange(<span class="number">0.001</span>,<span class="number">1</span>,<span class="number">0.01</span>)</span><br><span class="line">ent=entropy(x)</span><br><span class="line">sc_ent=ent*<span class="number">0.5</span></span><br><span class="line">err=error(x)</span><br><span class="line">fig=plt.figure()</span><br><span class="line">ax=plt.subplot(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">for</span> i, lab, ls, c, <span class="keyword">in</span> <span class="built_in">zip</span>([ent, sc_ent, gini(x), err], </span><br><span class="line">    [<span class="string">&#x27;Entropy&#x27;</span>, <span class="string">&#x27;Entropy (scaled)&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Gini Impurity&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Misclassification Error&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;lightgray&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>]):</span><br><span class="line">    line = ax.plot(x, i, label=lab, </span><br><span class="line">    linestyle=ls, lw=<span class="number">2</span>, color=c)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">ax.axhline(y=<span class="number">0.5</span>,linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">ax.axhline(y=<span class="number">1</span>,linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;p(i-1)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Impurity Index&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/01/26/machine-learning/machine2/scikit-learn_54_0.png" alt="png"><br>​    </p>
<h3 id="构建一颗决策树"><a href="#构建一颗决策树" class="headerlink" title="构建一颗决策树"></a>构建一颗决策树</h3><p>我们可以借助<code>scikit-learn</code>来构建一棵决策树,我们在此训练一个最大深度为3的决策树,使用信息熵作为度量.</p>
<blockquote>
<p>需要注意到,虽然在可视化的时候进行数据预处理是好的,但是对于决策树而言,不需要进行数据缩放</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">tree=DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,max_depth=<span class="number">4</span>,random_state=<span class="number">1</span>)</span><br><span class="line">tree.fit(Xtrain,ytrain)</span><br><span class="line">plot_decision_regions(Xtrain,ytrain,tree)</span><br><span class="line">plot_decision_regions(Xtest,ytest,tree,test=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length [cm]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width [cm]&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\h\AppData\Local\Temp\ipykernel_43220\485392308.py:21: UserWarning: You passed a edgecolor/edgecolors (&#39;black&#39;) for an unfilled marker (&#39;x&#39;).  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
  plt.scatter(x=X[y==cl,0],
C:\Users\h\AppData\Local\Temp\ipykernel_43220\485392308.py:21: UserWarning: You passed a edgecolor/edgecolors (&#39;black&#39;) for an unfilled marker (&#39;x&#39;).  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
  plt.scatter(x=X[y==cl,0],
</code></pre>
<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_56_1.png" alt="png"></p>
<p>使用<code>scikit-learn</code>有一个很好的功能在于你可以将训练好的树保存为<code>.dot</code>文件,然后我们可以使用<code>pydotplus</code>库进行查看</p>
<blockquote>
<p>需要注意,我们需要安装<code>GraphViz</code>这样的程序</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! 添加GraphViz环境变量</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>]+=os.pathsep+<span class="string">&#x27;C:/Program Files/Graphviz/bin&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pydotplus <span class="keyword">import</span> graph_from_dot_data</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line">dot_data=export_graphviz(tree,</span><br><span class="line">                         filled=<span class="literal">True</span>,</span><br><span class="line">                         rounded=<span class="literal">True</span>,</span><br><span class="line">                         class_names=[<span class="string">&#x27;Setosa&#x27;</span>,<span class="string">&#x27;Versicolor&#x27;</span>,<span class="string">&#x27;Virginica&#x27;</span>],</span><br><span class="line">                         feature_names=[<span class="string">&#x27;petal length&#x27;</span>,<span class="string">&#x27;petal width&#x27;</span>],</span><br><span class="line">                         out_file=<span class="literal">None</span>)</span><br><span class="line">graph=graph_from_dot_data(dot_data)</span><br><span class="line">graph.write_png(<span class="string">&#x27;tree.png&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True
</code></pre>
<p>我们可以得到一个如下所示的结果<br><img src="/2023/01/26/machine-learning/machine2/tree.png" alt="png"></p>
<p>我们可以看到这中间的各种决策过程,这个决策树在区分花种类中可以做得很好</p>
<p>遗憾的是,<code>scikit-learn</code>库中并没有内置进行修剪的函数,我们需要修改之前的源代码</p>
<h3 id="使用随机森林法合并不同的决策树"><a href="#使用随机森林法合并不同的决策树" class="headerlink" title="使用随机森林法合并不同的决策树"></a>使用随机森林法合并不同的决策树</h3><p><strong>决策森林</strong>(<code>Random forests</code>)在机器学习中变得非常流行,随机森林可以被看作是一组决策树的集合,随机森林可以被总结为以下四步:</p>
<ol>
<li>从数据集中随机抽取$n$个样本(放回抽样)</li>
<li>从这$n$个样本中生长出一棵决策树,而在每一个样本中,有:<ul>
<li>随机选取$d$个特征</li>
<li>选取使用最能分割特征的节点进行分割</li>
</ul>
</li>
<li>重复这个过程$k$次</li>
<li>使用<em>绝对多数投票</em>合并这些树</li>
</ol>
<p>我们尤其需要注意在步骤2中是<strong>对部分特征进行生长</strong><br>虽然随机森林的结果不像决策树一样易于解读,但是相应的,其可以过滤掉很大一部分噪声,鲁棒性很高,我们只需要关心我们需要训练多少个树,而往往树越多,结果越为理想.</p>
<blockquote>
<p>当然,像$n$和$d$这样的的值也可以优化,但是在这里不加以过多赘述</p>
</blockquote>
<p>我们可以使用库来构建随机森林</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">forest=RandomForestClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,</span><br><span class="line">                              n_estimators=<span class="number">250</span>,</span><br><span class="line">                              random_state=<span class="number">1</span>,</span><br><span class="line">                              n_jobs=<span class="number">2</span>)</span><br><span class="line">forest.fit(Xtrain,ytrain)</span><br><span class="line">plot_decision_regions(Xtrain,ytrain,forest)</span><br><span class="line">plot_decision_regions(Xtest,ytest,forest,test=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length [cm]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width [cm]&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()                 </span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_62_1.png" alt="png"></p>
<p>虽然我们长的树很少,数据集也很小,但是我们修改了<code>n_jobs</code>来实现多线程运算</p>
<h2 id="第K近邻居–一种懒惰的学习算法"><a href="#第K近邻居–一种懒惰的学习算法" class="headerlink" title="第K近邻居–一种懒惰的学习算法"></a>第K近邻居–一种懒惰的学习算法</h2><p>我们最后要介绍的算法是KNN算法,这种算法非常有趣因为其采用了一种不同的方式进行学习</p>
<p>所谓<em>懒惰</em>不是因为其结构简单,而是因为其不从训练数据中学习区分函数,而是通过记住训练集的方式</p>
<blockquote>
<p>KNN属于一个典型的非参数模型<br>KNN算法自身是相当直截了当的,可以用以下几步来总结</p>
</blockquote>
<ol>
<li>选择数量$k$和距离矩阵</li>
<li>找到我们想要分类的$k$个邻居</li>
<li>使用绝对多数投票决定类标签<br>下图展示了一个新的数据点是如何拿KNN算法分类的<br><img src="attachment:image.png" alt="image.png"><br>这种方法的好处在于一旦我们添加新的数据,那么模型可以立即适应,然而,当训练数据非常大时,这一算法会变得<strong>非常慢</strong>  <blockquote>
<p>似乎不准确的抽样可能会对KNN带来权重<br>下面我们用KNN算法实践一下</p>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn=KNeighborsClassifier(p=<span class="number">2</span>,metric=<span class="string">&#x27;minkowski&#x27;</span>)</span><br><span class="line">knn.fit(X_train_std,ytrain)</span><br><span class="line">plot_decision_regions(X_train_std,ytrain,knn)</span><br><span class="line">plot_decision_regions(X_test_std,ytest,knn,test=<span class="literal">True</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>




<p><img src="/2023/01/26/machine-learning/machine2/scikit-learn_65_1.png" alt="png"></p>
<p>在KNN中,选取合适的$k$尤为重要,同时也要选取一个合理的距离矩阵,例如我们刚才选用的<code>minkowski</code>矩阵,其形式如下:<br>$$d(x^{(i)},x^{(j)})&#x3D;\sqrt[p]{\sum_k |x^{(i)}_k-x^{(j)}_k|}$$<br>当$p&#x3D;2$,为欧几里得距离,当$p&#x3D;1$,为曼哈顿距离<br>可以参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.DistanceMetric.html">这个网页</a>  </p>
<blockquote>
<p>需要注意:当数据维度非常高时,KNN往往会给出过拟合的结果 :</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章所涉及的机器学习算法的特点列举如下:</p>
<ol>
<li>Logistic回归相当于<code>Adaline</code>的一种改进,最为基本</li>
<li>支持向量机可以支持许多类型的核来处理非线性问题,但是其具有非常多的参数需要调节</li>
<li>决策树的结果易于解读,但是鲁棒性不如随机森林</li>
<li>KNN算法不依赖参数模型,但是当数据维度大时综合效果会显著下降</li>
</ol>
<h2 id="有待讨论的问题"><a href="#有待讨论的问题" class="headerlink" title="有待讨论的问题"></a>有待讨论的问题</h2><ol>
<li>关于logistic回归函数的意义</li>
<li>核的意义</li>
<li>修改logistic回归代码</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>控制系统建模</title>
    <url>/2023/01/15/control%20system/control1/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>

<h2 id="描述控制系统"><a href="#描述控制系统" class="headerlink" title="描述控制系统"></a>描述控制系统</h2><p><code>在这一部分,假设$u(t)$为系统某一时刻的输入,$y(t)$为系统某一时刻的输出$t$为时间</code></p>
<p>利用递推法即$y_n&#x3D;\Sigma f(y_k)+g(u_n)$,我们可以得到一个齐次线性微分方程描述输出和输入之间的关系<br>$$\Sigma_k^n\frac{\mathbb{d}^k}{\mathbb{d}t^k}a_ky(t)&#x3D;\Sigma_i^n\frac{\mathbb{d}^i}{\mathbb{d}t^i}b_ku(t)$$</p>
<blockquote>
<p>对于一些特殊情况,例如系统的状态与其历史无关,那么系统可以被简化为$y(t)&#x3D;b_0u(t)$<br>下面将对一个常见模型进行建模</p>
</blockquote>
<span id="more"></span>


<hr>
<h3 id="垂直驱动机械臂模型"><a href="#垂直驱动机械臂模型" class="headerlink" title="垂直驱动机械臂模型"></a>垂直驱动机械臂模型</h3><p>$$J\ddot{\theta}(t)+\mu\dot{\theta}(t)+Mgl\sin \theta(t)&#x3D;u(t)$$<br><code>臂转动惯量为$J$,质量为$M$,重力加速度为$g$,考虑阻尼作用,整体外部扭矩被表示为$u$</code><br>但是这不是一个线性微分方程(由于$\sin$的存在),因此我们可以对$\theta$进行小角度假设,那么就可以得到一个线性微分方程</p>
<p>$$J\ddot{\theta}(t)+\mu\dot{\theta}(t)+Mgl\theta(t)&#x3D;u(t)$$</p>
<h3 id="控制工程所使用的模型描述"><a href="#控制工程所使用的模型描述" class="headerlink" title="控制工程所使用的模型描述"></a>控制工程所使用的模型描述</h3><p>由于微分方程往往很高阶,因此直接分析会非常困难.<br>将微分方程转换为”传递函数模型”或者是”状态方程模型”</p>
<h2 id="传递函数模型"><a href="#传递函数模型" class="headerlink" title="传递函数模型"></a>传递函数模型</h2><p>传递函数模型形式$\mathcal{P}(s)&#x3D;\frac{\Sigma^m_k b_ks^k}{\Sigma^n_i b_is^i}$<br>利用这种模型,可以将在时间域上的微积分操作转化为在$s$上的乘法操作,例如说$$\dot{y(t)}\to sy(s)$$<br>$\mathcal{P}(s)&#x3D;\frac{y(s)}{u(s)}$其中$y(s)&#x3D;\mathcal{L}[y(t)],u(s)&#x3D;\mathcal{L}[u(t)]$</p>
<blockquote>
<p>拉普拉斯变换$\mathcal{L}$,定义$$g(s)&#x3D;\mathcal{L}[g(t)]:&#x3D;\int_0^\infin g(t)e^{-st}\mathbb{d}t$$<br>对其进行$N$次积分相当于除以$s^N$,微分则相反</p>
</blockquote>
<h3 id="传递函数举例"><a href="#传递函数举例" class="headerlink" title="传递函数举例"></a>传递函数举例</h3><p>对于之前的机械臂模型,我们可以将传递函数写作<br>$$\mathcal{P}(s)&#x3D;\frac{1}{s^2J+\mu s+Mgl}$$<br>也可以利用Python中的(<code>tf</code>)函数来表示,例如我们现在有一个控制函数<br>$$\mathcal{P}(s)&#x3D;\frac{1}{s^2+2s+3}$$<br>可以用以下代码表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> control</span><br><span class="line">np=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">dp=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">p=control.tf(np,dp)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure>


<pre><code>      1
-------------
s^2 + 2 s + 3
</code></pre>
<p>​    </p>
<p>或者像这样$$\mathcal{P}(s)&#x3D;\frac{s+2}{(s+1)(s+2)^2}$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(control.tf([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>])*control.tf([<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>])**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>        s + 2
---------------------
s^3 + 5 s^2 + 8 s + 4
</code></pre>
<p>​    </p>
<p>可以利用(<code>tfdata</code>)重新获取分母和分子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[nump]],[[denp]]=control.tfdata(p)</span><br><span class="line"><span class="built_in">print</span>(nump,denp)</span><br></pre></td></tr></table></figure>

<pre><code>[1] [1 2 3]
</code></pre>
<h2 id="状态空间模型"><a href="#状态空间模型" class="headerlink" title="状态空间模型"></a>状态空间模型</h2><p>状态空间模型可以<strong>将多元高阶微分方程表示为一阶微分方程的形式</strong><br>通常可以编写为两个(两组)方程<br>$$<br>\dot{x}(t)&#x3D;Ax(t)+Bu(t)\qquad (状态方程)<br>$$<br>和<br>$$<br>y(t)&#x3D;Cx(t)+Du(t)\qquad (输出方程)<br>$$<br>需要注意的是,$ABCD$都可以是矩阵,$xyu$都可以是矢量,但是我们主要考虑单输入单输出情况(但是$x$可能还是矢量)</p>
<blockquote>
<p>如何建模?<br>考虑$p&#x3D;\frac{\mathbb{d}}{\mathbb{d}t}$,那么可以假设$p$的多项式$A(p)$和$B(p)$,于是我们就可以定义一个新变量$v$,有<br>$A(p)&#x3D;u,y&#x3D;B(p)v$<br>可以定义$x$向量为$v$的各阶导数,就可以写出原来的方程</p>
</blockquote>
<h3 id="机械臂的状态空间模型"><a href="#机械臂的状态空间模型" class="headerlink" title="机械臂的状态空间模型"></a>机械臂的状态空间模型</h3><p>下面以之前的机械臂为例,讨论一下状态空间模型的推导<br>由于机械臂运动状态由角度和角速度确定,因此$x&#x3D;\left[\begin{matrix}\theta\\dot{\theta}\end{matrix}\right]$,然后其状态方程为<br>$$\dot{x}(t)&#x3D;\left[\begin{matrix}\dot{\theta}\\ddot{\theta}\end{matrix}\right]&#x3D;\left[\begin{matrix}0&amp;1\-\frac{Mgl}{J}&amp;-\frac{\mu}{J}\end{matrix}\right]x(t)+\left[\begin{matrix}0\\frac{1}{J}\end{matrix}\right]u(t)$$<br>输出方程为<br>$$y(t)&#x3D;\left[\begin{matrix}1&amp;0\end{matrix}\right]x(t)$$</p>
<h3 id="状态空间模型的Python代码"><a href="#状态空间模型的Python代码" class="headerlink" title="状态空间模型的Python代码"></a>状态空间模型的Python代码</h3><p>可以使用函数<code>ss(A,B,C,D)</code>表示状态空间,非常方便,例如对于一组方程<br>$$\dot{x}(t)&#x3D;\left[\begin{matrix}1&amp;1&amp;2\2&amp;1&amp;1\3&amp;4&amp;5\end{matrix}\right]x(t)+\left[\begin{matrix}2\0\1\end{matrix}\right]u(t)$$<br>$$y(t)&#x3D;\left[\begin{matrix}1&amp;1&amp;0\end{matrix}\right]x(t)+u(t)$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;1 1 2;2 1 1;3 4 5&quot;</span></span><br><span class="line">b=<span class="string">&quot;2;0;1&quot;</span></span><br><span class="line">c=<span class="string">&quot;1 1 0&quot;</span></span><br><span class="line">d=<span class="string">&quot;1&quot;</span></span><br><span class="line">control.ss(a,b,c,d).A</span><br></pre></td></tr></table></figure>




<pre><code>array([[1., 1., 2.],
       [2., 1., 1.],
       [3., 4., 5.]])
</code></pre>
<h2 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h2><p>可以利用框图来描述控制系统</p>
<h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><p>将两个系统输入输出相连,可以得到一个串联的系统,例如将$y&#x3D;\mathcal{S_1}u$与$z&#x3D;\mathcal{S_2}y$串联后就得到$z&#x3D;\mathcal{S_1}\cdot\mathcal{S_2}u$<br>系统可以表示为$$\mathcal{S&#x3D;S_1\cdot S_2}$$<br>这一结果不满足交换律,框图如下所示<br>可以使用Python求得系统中串联的结果模型:</p>
<blockquote>
<p>需要注意如果使用乘法,那么后作用的系统在前(参考矩阵),反之则是先作用的系统在前</p>
</blockquote>
<h3 id="并联"><a href="#并联" class="headerlink" title="并联"></a>并联</h3><p>将输入分别通过两个过程再叠加(略)</p>
<h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>当一个的输出再通过某些形式返回,就构成了反馈系统.例如在一个反馈系统中<br>$$y&#x3D;\mathcal{S_1}r-\mathcal{S_2}y$$<br>那么这个反馈系统可以被化简为<br>$$y&#x3D;\mathcal{S}r\qquad \mathcal{S}&#x3D;\frac{\mathcal{S_1}}{1+\mathcal{S_1S_2}}$$</p>
<blockquote>
<p>可以利用<code>feedback</code>实现反馈</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=control.tf([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">s2=control.tf([<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">s=control.series(s1,s2)</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<p>$$\frac{s + 1}{s^3 + 2 s^2 + 2 s + 1}$$</p>
]]></content>
      <categories>
        <category>Python设计控制系统</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器配置日志3</title>
    <url>/2023/02/16/Linux/linux-server3/</url>
    <content><![CDATA[<p>今天配置了<code>samba</code>服务器,用来放一些共享文档便于查阅,这里记录一下过程以及遇到的问题</p>
<h2 id="在Linux服务器上配置samba"><a href="#在Linux服务器上配置samba" class="headerlink" title="在Linux服务器上配置samba"></a>在Linux服务器上配置samba</h2><p><a href="https://phoenixnap.com/kb/ubuntu-samba">参考资料</a><br>需要注意到,<strong>尽量不要使用默认账户去访问</strong>,因此需要添加专门用来访问的账户<br>过程要先在<code>sudo adduser username</code>进行设定,再在<code>sudo smbpasswd -a new_user</code><br>同时,需要注意:<strong>在授权远程用户具有rwx权限前要先保证这个账户本地具有rwx权限</strong>,例如要分享一个文件夹,即使在samba的配置文件中授权了这个用户的访问,但如果用户自身没有修改等权限,那么即使远程连接上了samba,还是会提示缺乏权限</p>
<h2 id="在Windows上连接samba"><a href="#在Windows上连接samba" class="headerlink" title="在Windows上连接samba"></a>在Windows上连接samba</h2><p>由于Windows服务器那个阴间的密码管理(个人感受),所以连接的时候不能简单地在运行里面输入或者”新建网络位置”,而是应当参考<a href="https://www.cnblogs.com/ssdq/p/12857316.html">这个方法</a>(不过如果是匿名只读用户应该不用担心)</p>
<h2 id="Fish"><a href="#Fish" class="headerlink" title="Fish"></a>Fish</h2><p><a href="https://www.cnblogs.com/Masquer/p/13920104.html">看这里</a></p>
]]></content>
      <categories>
        <category>Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux功能</tag>
      </tags>
  </entry>
  <entry>
    <title>The results and the problems in fitting the spectrum of the maxi1820+70</title>
    <url>/2023/01/15/maxi1820/maxi1/</url>
    <content><![CDATA[<h2 id="Fitting-points"><a href="#Fitting-points" class="headerlink" title="Fitting points"></a>Fitting points</h2><p>We chose three typical points from the HID graph.</p>
<p><img src="/2023/01/15/maxi1820/maxi1/hid.png" alt="hid"></p>
<h2 id="The-first-point"><a href="#The-first-point" class="headerlink" title="The first point"></a>The first point</h2><p>The first point is the observation is the three observation in <code>P14661084</code> and we use the low energy and mid energy part of the spectrum.</p>
<p>We combine the spectra in <code>P14661084</code> and use the model <code>constant*TBabs*(simplcutx*(diskbb+relxillCp)+xillverCp)</code>(The reason why I didn’t use the model <code>mbknpo</code> is that if I add this model, then the spectrum of the very low energy(about 2keV) may not fit well), and I got the best-fit like this.</p>
<p><img src="/2023/01/15/maxi1820/maxi1/fitLS.png" alt="fitLS"></p>
<p>Also, we calculate the error of each parameter, and got the table below</p>
<table>
<thead>
<tr>
<th>par</th>
<th>model</th>
<th>par name</th>
<th>value</th>
<th>range</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td><code>simplcutx</code></td>
<td><code>Gamma</code></td>
<td>2.32037</td>
<td>2.29367~2.34282</td>
</tr>
<tr>
<td>4</td>
<td><code>simplcutx</code></td>
<td><code>FracSctr</code></td>
<td>0.146214</td>
<td>0.139002~0.153343</td>
</tr>
<tr>
<td>6</td>
<td><code>simplcutx</code></td>
<td><code>kT_e</code></td>
<td>963.399</td>
<td>151.681~0(-811.624,-963.304)</td>
</tr>
<tr>
<td>7</td>
<td><code>diskbb</code></td>
<td><code>Tin</code></td>
<td>0.740488</td>
<td>0.737991~0.742486(-0.00249779,0.00199709)</td>
</tr>
<tr>
<td>8</td>
<td><code>diskbb</code></td>
<td><code>norm</code></td>
<td>1.53996E4</td>
<td>15170.5~15622(-229.123,222.451)</td>
</tr>
<tr>
<td>9</td>
<td><code>relxillCp</code></td>
<td><code>Index1</code></td>
<td>10.00000</td>
<td>9.20764~0(-0.792358,-10)</td>
</tr>
<tr>
<td>13</td>
<td><code>relxillCp</code></td>
<td><code>Incl</code></td>
<td>73.6178</td>
<td>72.3889~73.842(-1.22892,0.224224)</td>
</tr>
<tr>
<td>14</td>
<td><code>relxillCp</code></td>
<td><code>Rin</code></td>
<td>-1.01333</td>
<td>-1.03082~-1.00407(-0.0174862,0.00926662)</td>
</tr>
<tr>
<td>18</td>
<td><code>relxillCp</code></td>
<td><code>logxi</code></td>
<td>3.74057</td>
<td>3.61639~3.8515(-0.124187,0.110924)</td>
</tr>
<tr>
<td>19</td>
<td><code>relxillCp</code></td>
<td><code>Afe</code></td>
<td>10.0000</td>
<td>9.32562~0(-0.67438,-10)</td>
</tr>
<tr>
<td>22</td>
<td><code>relxillCp</code></td>
<td><code>norm</code></td>
<td>0.340764</td>
<td>0.29189~0.352971(-0.0488737,0.0122078)</td>
</tr>
<tr>
<td>30</td>
<td><code>xillverCp</code></td>
<td><code>norm</code></td>
<td>1.3216E-3</td>
<td>0~0.00371015(-0.00132301,0.00238714)</td>
</tr>
<tr>
<td>31</td>
<td><code>constant</code>(2)</td>
<td><code>factor</code></td>
<td>1.02040</td>
<td>1.01158~1.03362(-0.00881818,0.0132216)</td>
</tr>
</tbody></table>
<h2 id="The-second-point"><a href="#The-second-point" class="headerlink" title="The second point"></a>The second point</h2><p>The second point is the three observation in &#96;&#96;, we used all the energy part of the spectrum.</p>
<p>Also, we used the model <code>constant*TBabs*(simplcutx*(diskbb+relxillCp)+xillverCp)</code>to fit the spectrum. And ignored the spectrum between 21keV to 23keV. This time, however, we found that the model cannot fit the spectrum very well, especially at about Fe-line and at about 25 keV. </p>
<p>The unfolded spectrum and the ratio is like below:</p>
<p><img src="/2023/01/15/maxi1820/maxi1/fitLH.png" alt="fitLH"></p>
<p>We calculated the error of each parameter, and got the table below:</p>
<table>
<thead>
<tr>
<th>par</th>
<th>model</th>
<th>par name</th>
<th>value</th>
<th>range</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td><code>simplcutx</code></td>
<td><code>Gamma</code></td>
<td>1.55434</td>
<td>1.54259~1.56467(-0.0117559,0.0103268)</td>
</tr>
<tr>
<td>4</td>
<td><code>simplcutx</code></td>
<td><code>FracSctr</code></td>
<td>0.204196</td>
<td>0.187275~0.21611(-0.016921,0.0119141)</td>
</tr>
<tr>
<td>6</td>
<td><code>simplcutx</code></td>
<td><code>kT_e</code></td>
<td>50.2392</td>
<td>49.7608 ~52.4421(-0.47835,2.20294)</td>
</tr>
<tr>
<td>7</td>
<td><code>diskbb</code></td>
<td><code>Tin</code></td>
<td>0.530084</td>
<td>0.519304~0.546117(-0.0107803,0.0160332)</td>
</tr>
<tr>
<td>8</td>
<td><code>diskbb</code></td>
<td><code>norm</code></td>
<td>14927.14</td>
<td>4290.33~5755.6(-636.818,828.452)</td>
</tr>
<tr>
<td>9</td>
<td><code>relxillCp</code></td>
<td><code>Index1</code></td>
<td>10.00000</td>
<td>3.70664~0(-6.29336,-10)</td>
</tr>
<tr>
<td>13</td>
<td><code>relxillCp</code></td>
<td><code>Incl</code></td>
<td>41.5373</td>
<td>38.802~???(-2.73533,4.29916)</td>
</tr>
<tr>
<td>14</td>
<td><code>relxillCp</code></td>
<td><code>Rin</code></td>
<td>-14.5510</td>
<td>-18.111~-9.07362(-3.56002,5.47737)</td>
</tr>
<tr>
<td>18</td>
<td><code>relxillCp</code></td>
<td><code>logxi</code></td>
<td>4.40865</td>
<td>4.35113~4.44465(-0.057525,0.0360025)</td>
</tr>
<tr>
<td>19</td>
<td><code>relxillCp</code></td>
<td><code>Afe</code></td>
<td>9.29539</td>
<td>7.81846~0(-1.47693,-9.29539)</td>
</tr>
<tr>
<td>22</td>
<td><code>relxillCp</code></td>
<td><code>norm</code></td>
<td>8.8196E-2</td>
<td>0.0847278~ 0.0938056(-0.0034684,0.00560941)</td>
</tr>
<tr>
<td>30</td>
<td><code>xillverCp</code></td>
<td><code>norm</code></td>
<td>5.4875E-3</td>
<td>0.00463134~0.00628511(-0.000856129,0.000797643)</td>
</tr>
<tr>
<td>31</td>
<td><code>constant</code>(2)</td>
<td><code>factor</code></td>
<td>1.03591</td>
<td>1.02896~1.04286(-0.00695636,0.00694697)</td>
</tr>
<tr>
<td>61</td>
<td><code>constant</code>(2)</td>
<td><code>factor</code></td>
<td>1.05928</td>
<td>1.05126~1.06678(-0.00801573,0.00750175)</td>
</tr>
</tbody></table>
<p>I noticed that the range of the parameter <code>Rin</code>  is quite large, which may be related to the unfitted Fe-line.</p>
<h2 id="The-third-point"><a href="#The-third-point" class="headerlink" title="The third point"></a>The third point</h2><p>The second point is the two observation in <code>P0114661136</code>, we used all the energy part of the spectrum.</p>
<p>We use the model <code>constant*TBabs*(simplcutx*(diskbb+mbnkpo*relxillCp)+xillverCp)</code> to fit the spectrum. And ignored the spectrum between 21keV to 23keV. This time except the problem at about 20keV and 25keV, the model can fit the spectrum quite well.</p>
<p>The unfolded spectrum and the ratio is like below:<img src="/2023/01/15/maxi1820/maxi1/fit3.png" alt="fit3"></p>
<p>We calculated the error of each parameter, and got the table below:</p>
<table>
<thead>
<tr>
<th>par</th>
<th>model</th>
<th>par name</th>
<th>value</th>
<th>range</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td><code>simplcutx</code></td>
<td><code>Gamma</code></td>
<td>1.70835</td>
<td>1.69696~1.71736(-0.0113903,0.00900463)</td>
</tr>
<tr>
<td>4</td>
<td><code>simplcutx</code></td>
<td><code>FracSctr</code></td>
<td>0.423500</td>
<td>0.388402~0.452862 (-0.0350982,0.0293619)</td>
</tr>
<tr>
<td>6</td>
<td><code>simplcutx</code></td>
<td><code>kT_e</code></td>
<td>296.876</td>
<td>156.831~0(-140.045,-296.876)</td>
</tr>
<tr>
<td>7</td>
<td><code>diskbb</code></td>
<td><code>Tin</code></td>
<td>0.521368</td>
<td>0.499858~0.547507(-0.0215105,0.0261386)</td>
</tr>
<tr>
<td>8</td>
<td><code>diskbb</code></td>
<td><code>norm</code></td>
<td>1679.12</td>
<td>1315.87~2075.26(-363.28,396.115)</td>
</tr>
<tr>
<td>11</td>
<td><code>relxillCp</code></td>
<td><code>Index1</code></td>
<td>10.00000</td>
<td>4.04933~0 (-5.95067,-10)</td>
</tr>
<tr>
<td>15</td>
<td><code>relxillCp</code></td>
<td><code>Incl</code></td>
<td>44.0274</td>
<td>41.2731~48.205 (-2.75424,4.17761)</td>
</tr>
<tr>
<td>16</td>
<td><code>relxillCp</code></td>
<td><code>Rin</code></td>
<td>-4.37220</td>
<td>-5.43035 ~-3.03198 (-1.05815,1.34022)</td>
</tr>
<tr>
<td>20</td>
<td><code>relxillCp</code></td>
<td><code>logxi</code></td>
<td>3.64956</td>
<td>3.48269~3.80451(-0.166872,0.154944)</td>
</tr>
<tr>
<td>21</td>
<td><code>relxillCp</code></td>
<td><code>Afe</code></td>
<td>10.0000</td>
<td>7.14676~0 (-2.85324,-10)</td>
</tr>
<tr>
<td>24</td>
<td><code>relxillCp</code></td>
<td><code>norm</code></td>
<td>07.31228E-3</td>
<td>0.0061945~0.00893408(-0.00111789,0.00162169)</td>
</tr>
<tr>
<td>32</td>
<td><code>xillverCp</code></td>
<td><code>norm</code></td>
<td>2.39388E-11</td>
<td>0~0.000333344(-6.82725e-15,0.000333344)</td>
</tr>
<tr>
<td>33</td>
<td><code>constant</code>(2)</td>
<td><code>factor</code></td>
<td>1.00827</td>
<td>0.985256~1.02789 (-0.0230121,0.0196176)</td>
</tr>
<tr>
<td>65</td>
<td><code>constant</code>(3)</td>
<td><code>factor</code></td>
<td>1.03501</td>
<td>1.00417~1.06166(-0.0308423,0.0266517)</td>
</tr>
</tbody></table>
<h2 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h2><ol>
<li>In real world ,the <code>Incl</code> should not change with time, so we should fix it to some value (In the &#x3D;&#x3D;NuSTAR&#x3D;&#x3D; it is 63, but we’ve found that it cannot fit very well)</li>
<li>We don’t need to get the best fit because our goal is to fit <strong>all</strong> the observations, so if the <code>Reduced Chi-Squared</code>(Chi-Squared&#x2F;Degrees of freedom)is under 1.2,although it is still not the best fit ,it would be ok.</li>
</ol>
]]></content>
      <categories>
        <category>maxi1820</category>
      </categories>
      <tags>
        <tag>maxi1820</tag>
        <tag>X-ray spectrum fitting</tag>
      </tags>
  </entry>
  <entry>
    <title>关于EasyConnect可能存在的问题以及解决方案</title>
    <url>/2023/01/16/misc/abouteasyconnect/</url>
    <content><![CDATA[<h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><p>今天我刷到了一个<a href="https://www.bilibili.com/video/BV163411Z7BD">视频</a>了解到<code>EasyConnect</code>似乎有滥用权限,泄露用户数据的可能,因此希望找到一种方法,在正常访问内网资源的同时实现对<code>EasyConnect</code>的控制.</p>
<h2 id="解决手段"><a href="#解决手段" class="headerlink" title="解决手段"></a>解决手段</h2><p>我采用的是视频中提供的方案,是<code>docker-easyconnect</code>,[此为源代码地址][<a href="https://github.com/Hagb/docker-easyconnect]">https://github.com/Hagb/docker-easyconnect]</a></p>
<p>在操作的时候,需要使用<code>Docker</code>环境进行隔离,刚好也对<code>Docker</code>环境进行学习</p>
<blockquote>
<p>需要注意的,在使用<code>socks5</code>代理的时候,把端口从1080改为其他类型的端口</p>
</blockquote>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>算是实现了部分的功能,在<code>Docker</code>上顺利登陆了,并且使用<code>Firefox</code>上的<code>SwichyOmega</code>实现对于流量的分流(基于<code>socks5</code>原理)(不过目前只代理了&#96;<em>.fudan.edu.cn</em>网页),这么做可以保障我在使用内网资源的时候同时可以访问外网资料</p>
<p>不过,这样的连接存在较为严重的稳定性问题,问题比较像<a href="https://github.com/Hagb/docker-easyconnect/issues/177">一个issue</a>,如何解决目前不明.</p>
<p>同时,非常遗憾的,使用这种手段无法解决我使用<code>ssh</code>的问题,而网上的资料似乎主要针对<code>Linux</code>系统,因此还是无法摆脱<code>EasyConnect</code>的困扰.</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>通讯安全</tag>
        <tag>Docker</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关注闭环系统的控制系统设计(上)</title>
    <url>/2023/01/31/control%20system/close-sys1/</url>
    <content><![CDATA[<p>对于一个被控制对象$\mathcal{P}$,我们需要搭建一个反馈控制系统,如图所示:<br><img src="/2023/01/31/control%20system/close-sys1/image-20230131204212577.png" alt="image-20230131204212577"><br>其中$\mathcal{K}$为控制器,$r$为目标值,$u$为控制输入,$d$为扰动,$y$为输出,$e$为误差,下面来分别介绍稳定性,时域特性以及频域响应特性</p>
<span id="more"></span>

<h2 id="设计规格"><a href="#设计规格" class="headerlink" title="设计规格"></a>设计规格</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>对于闭环系统,外部输入有$r$和$d$,输出包含了被控对象的输出$y$和控制器的输出$u$,因此闭环系统要同时考虑从$r,d$到$u,y$总共四个稳定性<br>通过相关的数学计算,若其特征多项式$\phi(s)&#x3D;D_P(s)D_K(s)+N_P(s)N_K(s)$(其中$\mathcal{P}(s)&#x3D;\frac{N_P(s)}{D_P(s)}$)的根是稳定的,系统内部就是稳定的  </p>
<blockquote>
<p>这一个过程利用传递函数法不难推导  </p>
</blockquote>
<h3 id="时域响应特性"><a href="#时域响应特性" class="headerlink" title="时域响应特性"></a>时域响应特性</h3><p>从发生阶跃到逐渐稳定的过程由许多部分组成,在响应中振荡的部分被称作<strong>瞬态特性</strong>,而当经过足够长时间后振荡收敛的部分则被称为<strong>稳态特性</strong></p>
<p>而对瞬态特性进行定量评价的指标有:<strong>上升时间(从10%-90%),调整时间(稳定在$\pm$%5),峰值时间,过冲</strong>,对于稳态响应进行定量评价的则为<strong>稳态误差</strong>,其描述目标值和稳定值之间的差  </p>
<h3 id="频域响应特性"><a href="#频域响应特性" class="headerlink" title="频域响应特性"></a>频域响应特性</h3><p>描述瞬态特性的指标有<strong>通频带$\omega_{bw}$(幅值下降约3dB的频率)和峰值增益$M_p$</strong>,往往在峰值增益处叫作协助峰值</p>
<h3 id="闭环系统的设计规格"><a href="#闭环系统的设计规格" class="headerlink" title="闭环系统的设计规格"></a>闭环系统的设计规格</h3><p>根据我们之前所讨论的,在控制系统的设计中闭环系统应当满足以下条件:</p>
<ol>
<li>稳定性</li>
<li>快速性(通频带较大)</li>
<li>阻尼特性(峰值增益较小)</li>
<li>稳态特性(直流增益为1)</li>
</ol>
<h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>PID分为三个部分构成:</p>
<ol>
<li>P:比例(Partial),现在的信息,实时误差</li>
<li>I:积分(Integral),过去的信息</li>
<li>D:微分(Derivative),未来的信息<br>只用P,可以让系统稳定,但是无法移动到目标位置,使用PI,可以让系统达到目标,但是会振荡</li>
</ol>
<p>使用公式来表述PID控制,可以写为:<br>$$u(t)&#x3D;k_pe(t)+k_1\int^t_0 e(t_s)\mathbf{d}t_s+k_D\dot{e}(t)$$<br>而对其进行拉普拉斯变换则得到:<br>$$u(s)&#x3D;\frac{k_Ds^2+k_Ps+k_1}{s}e(s)$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备工作</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> control <span class="keyword">as</span> ct </span><br><span class="line"><span class="keyword">from</span> control.matlab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_generator</span>():</span><br><span class="line">    linestyle=[<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;:&quot;</span>]</span><br><span class="line">    lineid=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> linestyle[lineid] <span class="comment">#* 这个yield用法很有趣,可以学习一下</span></span><br><span class="line">        lineid=(lineid+<span class="number">1</span>)%<span class="built_in">len</span>(linestyle)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax.set_xlabel(args[<span class="number">0</span>])</span><br><span class="line">    fig_ax.set_ylabel(args[<span class="number">1</span>])</span><br><span class="line">    fig_ax.grid(ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">        fig_ax.legend(loc=args[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bodeplot_set</span>(<span class="params">fig_ax,*args</span>):</span><br><span class="line">    fig_ax[<span class="number">0</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;Gain [dB]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].grid(which=<span class="string">&#x27;both&#x27;</span>,ls=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;$\omega$ [rad/s]&#x27;</span>)</span><br><span class="line">    fig_ax[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;Phase [deg]&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">0</span>:</span><br><span class="line">        fig_ax[<span class="number">1</span>].legend(loc=args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)&gt;<span class="number">1</span>:</span><br><span class="line">        fig_ax[<span class="number">0</span>].legend(loc=args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="P控制性能"><a href="#P控制性能" class="headerlink" title="P控制性能"></a>P控制性能</h3><p>如下图所示的P控制系统是通过误差来按照比例计算控制输入的<br><img src="/image-20230131204256286.png" alt="image-20230131204256286"></p>
<p>下面以机械臂(二姐滞后系统)为例,看看P控制效果</p>
<p>下面这段代码描述了模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g,l,M,mu,J=<span class="number">9.81</span>,<span class="number">0.2</span>,<span class="number">0.5</span>,<span class="number">1.5e-2</span>,<span class="number">1e-2</span></span><br><span class="line">P=tf([<span class="number">0</span>,<span class="number">1</span>],[J,mu,M*g*l])</span><br><span class="line">ref=<span class="number">30</span><span class="comment">#目标位置</span></span><br></pre></td></tr></table></figure>

<p>我们来试试不同的比例增益阶跃响应会是如何</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp=(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    K=tf([<span class="number">0</span>,kp[i]],[<span class="number">0</span>,<span class="number">1</span>])<span class="comment">#P控制</span></span><br><span class="line">    gyr=feedback(P*K,<span class="number">1</span>)<span class="comment">#形成反馈系统</span></span><br><span class="line">    y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))<span class="comment">#这里与参考之间是归一化</span></span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_P$=&#x27;</span>+<span class="built_in">str</span>(kp[i])&#125;</span><br><span class="line">    ax.plot(t,y*ref,**pltargs)</span><br><span class="line">ax.axhline(ref,color=<span class="string">&#x27;k&#x27;</span>,linewidth=<span class="number">0.5</span>)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_8_0.png" alt="png"><br>​    </p>
<p>可以注意到,只使用P控制无法实现达到目标位置,但是$k$越大,离目标位置越近  </p>
<blockquote>
<p>这里有一个理解上的问题,这里的输入实际上是<strong>预期值</strong>,结果P控制后才转化为像力矩一样的东西  </p>
</blockquote>
<p>我们接下来看看这个系统的伯德图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((<span class="built_in">len</span>(kp))):</span><br><span class="line">    k=tf([<span class="number">0</span>,kp[i]],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    gyr=feedback(P*k,<span class="number">1</span>)</span><br><span class="line">    gain,phase,w=bode(gyr,logspace(-<span class="number">1</span>,<span class="number">2</span>),plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_P$=&#x27;</span>+<span class="built_in">str</span>(kp[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_10_0.png" alt="png"><br>​    </p>
<p>可以注意到,随着$k_P$的增加,通频带在增加,但系统也会更加振荡</p>
<h3 id="PD控制"><a href="#PD控制" class="headerlink" title="PD控制"></a>PD控制</h3><p>刚才我们看到了,随着$k_P$的逐渐增大,振荡也会变大,可以通过添加D控制来控制振荡.<br>PD控制如下图所示,为$\mathcal{K}(s)&#x3D;k_Ds+k_P$<br><img src="/image-20230131204321765.png" alt="image-20230131204321765"></p>
<p>我们可以用以下代码对PD控制进行模拟</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp=<span class="number">2</span></span><br><span class="line">kd=(<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.2</span>)</span><br><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    k=tf([kd[i],kp],[<span class="number">0</span>,<span class="number">1</span>])<span class="comment">#PD控制</span></span><br><span class="line">    gyr=feedback(P*k,<span class="number">1</span>)</span><br><span class="line">    y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_D$=&#x27;</span>+<span class="built_in">str</span>(kd[i])&#125;</span><br><span class="line">    ax.plot(t,y*ref,**pltargs)</span><br><span class="line">ax.axhline(ref,color=<span class="string">&#x27;k&#x27;</span>,linewidth=<span class="number">0.5</span>)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_13_0.png" alt="png"><br>​    </p>
<p>我们可以注意到,在有D控制的情况下,振荡得到了有效的抑制,<strong>但是稳态误差不为0</strong><br>我们接下来来研究一下闭环系统的伯德图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    k=tf([kd[i],kp],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    gyr=feedback(P*k,<span class="number">1</span>)</span><br><span class="line">    gain,phase,w=bode(gyr,logspace(-<span class="number">1</span>,<span class="number">2</span>),plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_D$=&#x27;</span>+<span class="built_in">str</span>(kd[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_15_0.png" alt="png"><br>​    </p>
<p>这里$k_D$等于0的相位有点问题,但是我就懒得调了,可以看出,随着$k_D$的增大,通频带会逐渐增大,且过冲会减小,但是稳态条件下并没有改善  </p>
<blockquote>
<p>PD控制的可实现性<br>我们需要注意到PD控制的传递函数是非真分的,即控制过程中会用到系统未来的信息,因此我们需要使用<strong>不完全微分</strong><br>$$\frac{s}{1+T_{lp}s}$$<br>这是将低通滤波(一阶滞后系统)叠加到微分后的结果,是真分的函数(即添加一个对输出求导的函数)</p>
</blockquote>
<h3 id="PID控制-1"><a href="#PID控制-1" class="headerlink" title="PID控制"></a>PID控制</h3><p>最后,我们为了改善稳态的特性,我们可以添加I控制可以让稳态误差为0,同时,我们也可以注意到,随着$k_I$增大,振荡也会增强</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp=<span class="number">2</span></span><br><span class="line">kd=<span class="number">0.1</span></span><br><span class="line">ki=(<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    k=tf([kd,kp,ki[i]],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">    gyr=feedback(P*k,<span class="number">1</span>)</span><br><span class="line">    y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_I$=&#x27;</span>+<span class="built_in">str</span>(ki[i])&#125;</span><br><span class="line">    ax.plot(t,y*ref,**pltargs)</span><br><span class="line">ax.axhline(ref,color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_18_0.png" alt="png"><br>​    </p>
<p>接下来,我们来观察一下PID控制的伯德图  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    k=tf([kd,kp,ki[i]],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">    gyr=feedback(P*k,<span class="number">1</span>)</span><br><span class="line">    gain,phase,w=bode(gyr,logspace(-<span class="number">1</span>,<span class="number">2</span>),plot=<span class="literal">False</span>)</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_I$=&#x27;</span>+<span class="built_in">str</span>(ki[i])&#125;</span><br><span class="line">    ax[<span class="number">0</span>].semilogx(w,<span class="number">20</span>*np.log10(gain),**pltargs)</span><br><span class="line">    ax[<span class="number">1</span>].semilogx(w,phase*<span class="number">180</span>/np.pi,**pltargs)</span><br><span class="line">bodeplot_set(ax,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_20_0.png" alt="png"><br>​    </p>
<p>我们可以注意到,随着$k_I$的增大,振荡会增大,但是其他性质近似能够保持不变</p>
<blockquote>
<p>我们还可以来研究一下抗干扰性<br>因为可能会从d出现输入(扰动),下面展示了当d为阶跃输入时的系统整体的变化<br>这些扰动在机械系统中往往是一些摩擦等因素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=line_generator()</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    k=tf([kd,kp,ki[i]],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">    gyd=feedback(P,k)<span class="comment">#注意这里反馈环的变化</span></span><br><span class="line">    y,t=step(gyd,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">    pltargs=&#123;<span class="string">&#x27;ls&#x27;</span>:<span class="built_in">next</span>(ls),<span class="string">&#x27;label&#x27;</span>:<span class="string">&#x27;$k_I$=&#x27;</span>+<span class="built_in">str</span>(ki[i])&#125;</span><br><span class="line">    ax.plot(t,y,**pltargs)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_22_0.png" alt="png"><br>​    </p>
<p>可以注意到,虽然有振荡,但是I控制最终总是能够拉回</p>
<blockquote>
<p>PID数学形式<br>闭环系统:<br>$$\frac{k_Ds^2+k_Ps+k_I}{Js^3+(\mu +k_D)s^2+(mgl+k_P)s+k_I}$$<br>当频率为0(稳态时),闭环系统为1<br>扰动:<br>$$\frac{s}{Js^3+(\mu +k_D)s^2+(mgl+k_P)s+k_I}$$<br>当频率为0(稳态扰动时),扰动影响为0</p>
</blockquote>
<h2 id="二自由度控制"><a href="#二自由度控制" class="headerlink" title="二自由度控制"></a>二自由度控制</h2><p>但是在实际的使用过程中,我们往往使用的是PID控制的改良版本,我们下面介绍改良版的PID控制以及其与<strong>二自由度控制</strong>之间的关系.<br>在PID控制中如果目标值以阶跃状变化时控制输入($u(t)$)就会出现微分器中包含的冲激成分(虽然这个值不会像理论计算那样是无穷大,但是也会非常大).因此我们有时会将微分器移动到输出(这样不会直接输入)的<strong>PI-D控制</strong>,可以用下式表示<br>$$u(s)&#x3D;k_Pe(s)+\frac{k_I}{s}e(s)-k_Dsy(s)$$<br>其控制框图如图所示:<br><img src="/image-20230131204356341.png" alt="image-20230131204356341">而对于P控制,输入中也存在有阶跃状的信号,而为了解决这个问题,我们也可以将P也放到输出端,那么可以用下式表述:<br>$$u(s)&#x3D;-k_Py(s)+\frac{k_I}{s}e(s)-k_Dsy(s)$$<br>PI-D控制和P-ID控制就是在反馈控制基础上叠加了顺馈控制的二自由度控制,下面对其加以介绍:<br>对于PI-D控制,我们可以通过计算其输入$u(s)$为:<br>$$u(s)&#x3D;\frac{k_Ds^2+k_Ps+K_I}{s}\left(\frac{k_Ps+k_I}{k_Ds^2+k_Ps+k_I}r(s)-y(s)\right)&#x3D;\mathcal{K}_1(s)(\mathcal{K}_2(s)r(s)-y(s))$$<br>可以看作是两个控制器$\mathcal{K}_1$就是普通的PID控制,而$\mathcal{K}_2$则为一个滤波器,可以将输入信号变得平滑<br>相似的,对于P-ID控制,形式与前相同,只是$\mathcal{K}_2$变成了<br>$$\mathcal{K}_2(s)&#x3D;\frac{k_I}{k_Ds^2+k_Ps+k_I}$$<br>我们可以看看PID控制与PI-D控制以及I-PD控制之间区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp,ki,kd=<span class="number">2</span>,<span class="number">5</span>,<span class="number">0.1</span></span><br><span class="line">pcontrol=tf([<span class="number">0</span>,kp],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">icontrol=tf([<span class="number">0</span>,ki],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">dcontrol=tf([kd,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#首先看看PID控制</span></span><br><span class="line">pid=parallel(pcontrol,icontrol,dcontrol)</span><br><span class="line">fb=feedback(pid*P,<span class="number">1</span>)</span><br><span class="line">pidout,t=step(fb,np.arange(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0.01</span>))</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(t,pidout,<span class="string">&#x27;r-&#x27;</span>,label=<span class="string">&quot;PID&quot;</span>)</span><br><span class="line"><span class="comment">#接下来是PI_D控制</span></span><br><span class="line">pi=parallel(pcontrol,icontrol)</span><br><span class="line">Pd=feedback(P,dcontrol)</span><br><span class="line">gyd=feedback(pi*Pd,<span class="number">1</span>)</span><br><span class="line">pi_dout,t=step(gyd,np.arange(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0.01</span>))</span><br><span class="line">ax.plot(t,pi_dout,<span class="string">&#x27;g-&#x27;</span>,label=<span class="string">&quot;PI-D&quot;</span>)</span><br><span class="line"><span class="comment">#最后是P_ID控制</span></span><br><span class="line">Ppd=feedback(P,parallel(pcontrol,dcontrol))</span><br><span class="line">gyd=feedback(icontrol*Ppd,<span class="number">1</span>)</span><br><span class="line">p_idout,t=step(gyd,np.arange(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0.01</span>))</span><br><span class="line">ax.plot(t,p_idout,<span class="string">&#x27;b-&#x27;</span>,label=<span class="string">&quot;P-ID&quot;</span>)</span><br><span class="line"></span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_25_0.png" alt="png"><br>​    </p>
<p>可以注意到,使用PI-D振荡会略小,而使用P-ID振荡则几乎消失(这样可以避免u输入过大)</p>
<h2 id="使用临界比例度法进行增益调整"><a href="#使用临界比例度法进行增益调整" class="headerlink" title="使用临界比例度法进行增益调整"></a>使用临界比例度法进行增益调整</h2><p>常见有两种调节PID增益的方法,它们分别是<strong>临界比例度法</strong>和阶跃响应法,这里我们主要是研究使用临界比例度法对PID增益的调整,这种方法好处在于<strong>无需知道被控对象的模型</strong>,但是也有着相应的缺点:<strong>必须重复实验并且将机器运行在极其不稳定状态</strong><br>在使用临界比例度法时,首先搭建一个P控制,然后逐渐增大比例增益$k_P$,此时振荡也会逐渐增大<br>此时我们可以来调查比例增益$k_{P0}$和持续振荡的周期$T_0$,在实际的系统中,由于存在有微小的<strong>延迟时间</strong>,因此会产生持续振荡</p>
<p>得到了这些信息,我们就可以根据下表来确定比例增益$k_P$,<strong>积分时间常数$T_I$<strong>和</strong>微分时间常数$T_D$</strong>,对于PID控制,有:<br>$$u(t)&#x3D;k_P\left(e(t)+\frac{1}{T_I}\int e(t)dt+T_D\frac{d}{dt}e(t)\right)$$<br>则有$k_I&#x3D;\frac{k_P}{T_I}$,$k_D&#x3D;k_PT_D$  </p>
<table>
<thead>
<tr>
<th>临界比例度法</th>
<th>比例增益$k_P$</th>
<th>积分时间常数$T_I$</th>
<th>微分时间常数$T_D$</th>
</tr>
</thead>
<tbody><tr>
<td>P控制</td>
<td>0.5 $k_{P0}$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PI控制</td>
<td>0.45 $k_{P0}$</td>
<td>0.83 $T_0$</td>
<td></td>
</tr>
<tr>
<td>PID控制</td>
<td>0.6 $k_{P0}$</td>
<td>0.5 $T_0$</td>
<td>0.125 $T_0$</td>
</tr>
<tr>
<td>无过冲控制</td>
<td>0.2 $k_{P0}$</td>
<td>0.5 $T_0$</td>
<td>0.33 $T_0$</td>
</tr>
</tbody></table>
<p>下面我们假设处理的是作为被控对象的二阶滞后系统中存在有微小的延迟时间</p>
<blockquote>
<p>延迟系统可以表示为$e^{-hs}$这样的无穷维系统,可以近似为有理函数,下面使用一阶帕德近似,延迟时间设定为0.005  </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numd,dend=pade(<span class="number">0.005</span>,<span class="number">1</span>)</span><br><span class="line">Pdelay=P*tf(numd,dend)</span><br></pre></td></tr></table></figure>

<p>我们按照要求将比例增益大概调节到2.9并且施加P控制,那么就会产生下图所示的振荡</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line">kp0=<span class="number">2.9</span></span><br><span class="line">K=tf([<span class="number">0</span>,kp0],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">gyr=feedback(Pdelay*K,<span class="number">1</span>)</span><br><span class="line">y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line">ax.plot(t,y)</span><br><span class="line">ax.axhline(<span class="number">1</span>)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_32_0.png" alt="png"><br>​    </p>
<p>可以注意到,系统已经产生了显著的振荡,我们可以读出持续振荡的周期约为0.3s,那么我们就可以用这个系统来实现PID控制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">ki=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">kd=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">t0=<span class="number">0.3</span></span><br><span class="line">kp[<span class="number">0</span>]=<span class="number">0.6</span>*kp0</span><br><span class="line">ki[<span class="number">0</span>]=kp[<span class="number">0</span>]/(<span class="number">0.5</span>*t0)</span><br><span class="line">kd[<span class="number">0</span>]=kp[<span class="number">0</span>]*(<span class="number">0.125</span>*t0)</span><br><span class="line">K=tf([kd[<span class="number">0</span>],kp[<span class="number">0</span>],ki[<span class="number">0</span>]],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">gyr=feedback(K*Pdelay,<span class="number">1</span>)</span><br><span class="line">y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">ax.plot(t,y)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/close_sys_files/close_sys_34_0.png" alt="png"><br>​    </p>
<p>可以看到,实现了较好的控制,我们还可以避免过冲,可以看以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">ki=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">kd=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">t0=<span class="number">0.3</span></span><br><span class="line">kp[<span class="number">0</span>]=<span class="number">0.2</span>*kp0</span><br><span class="line">ki[<span class="number">0</span>]=kp[<span class="number">0</span>]/(<span class="number">0.5</span>*t0)</span><br><span class="line">kd[<span class="number">0</span>]=kp[<span class="number">0</span>]*(<span class="number">0.33</span>*t0)</span><br><span class="line">K=tf([kd[<span class="number">0</span>],kp[<span class="number">0</span>],ki[<span class="number">0</span>]],[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">gyr=feedback(K*Pdelay,<span class="number">1</span>)</span><br><span class="line">y,t=step(gyr,np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.01</span>))</span><br><span class="line">ax.plot(t,y)</span><br><span class="line">plot_set(ax,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2023/01/31/control%20system/close-sys1/close_sys_36_0.png" alt="png"><br>​    </p>
]]></content>
      <categories>
        <category>Python设计控制系统</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title>所思即所得,一些画图软件(包)介绍</title>
    <url>/2023/01/26/misc/graphviz/</url>
    <content><![CDATA[<p>由于我在学习控制系统的时候,感觉<code>Visio</code>绘图手感像坨屎(我承认是我手不行),但是像流程图这样的东西有特点,即如果你能在这些空间里面把你想要塞的东西全部塞进去,那么优化这样的工作可以是完全交由计算机自行处理的.</p>
<p>在这里,我主要将介绍两种方式进行该类绘图,一种是使用<code>LaTex</code>中<code>tikz</code>包进行绘图,还有一种是使用<code>Graphviz</code>进行绘图</p>
<span id="more"></span>

<h2 id="tikz包的使用与导出"><a href="#tikz包的使用与导出" class="headerlink" title="tikz包的使用与导出"></a><code>tikz</code>包的使用与导出</h2><p><code>tikz</code>包是在<code>LaTex</code>中的一个包,其可以方便(有模板的条件下)实现图的绘制</p>
<p>不过<code>LaTex</code>主要导出的是<code>pdf</code>文件,因此需要进行转换</p>
<h3 id="tikz包的使用-以一个例子为例"><a href="#tikz包的使用-以一个例子为例" class="headerlink" title="tikz包的使用(以一个例子为例)"></a><code>tikz</code>包的使用(以一个例子为例)</h3><p>我们首先以一个官方例子来介绍<code>tikz</code>包</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;tikz&#125;</span><br><span class="line"><span class="keyword">\usetikzlibrary</span>&#123;shapes,arrows&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\tikzstyle</span>&#123;block&#125; = [draw, fill=blue!20, rectangle, </span><br><span class="line">    minimum height=3em, minimum width=6em]</span><br><span class="line"><span class="keyword">\tikzstyle</span>&#123;sum&#125; = [draw, fill=blue!20, circle, node distance=1cm]</span><br><span class="line"><span class="keyword">\tikzstyle</span>&#123;input&#125; = [coordinate]</span><br><span class="line"><span class="keyword">\tikzstyle</span>&#123;output&#125; = [coordinate]</span><br><span class="line"><span class="keyword">\tikzstyle</span>&#123;pinstyle&#125; = [pin edge=&#123;to-,thin,black&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">% The block diagram code is probably more verbose than necessary</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;[auto, node distance=2cm,&gt;=latex&#x27;]</span><br><span class="line">    <span class="comment">% We start by placing the blocks</span></span><br><span class="line">    <span class="keyword">\node</span> [input, name=input] &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [sum, right of=input] (sum) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [block, right of=sum] (controller) &#123;Controller&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [block, right of=controller, pin=&#123;[pinstyle]above:Disturbances&#125;,</span><br><span class="line">            node distance=3cm] (system) &#123;System&#125;;</span><br><span class="line">    <span class="comment">% We draw an edge between the controller and system block to </span></span><br><span class="line">    <span class="comment">% calculate the coordinate u. We need it to place the measurement block. </span></span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (controller) -- node[name=u] &#123;<span class="built_in">$</span>u<span class="built_in">$</span>&#125; (system);</span><br><span class="line">    <span class="keyword">\node</span> [output, right of=system] (output) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [block, below of=u] (measurements) &#123;Measurements&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Once the nodes are placed, connecting them is easy. </span></span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (input) -- node &#123;<span class="built_in">$</span>r<span class="built_in">$</span>&#125; (sum);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (sum) -- node &#123;<span class="built_in">$</span>e<span class="built_in">$</span>&#125; (controller);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (system) -- node [name=y] &#123;<span class="built_in">$</span>y<span class="built_in">$</span>&#125;(output);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (y) |- (measurements);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (measurements) -| node[pos=0.99] &#123;<span class="built_in">$</span>-<span class="built_in">$</span>&#125; </span><br><span class="line">        node [near end] &#123;<span class="built_in">$</span>y<span class="built_in">_</span>m<span class="built_in">$</span>&#125; (sum);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会带来以下的渲染结果:</p>
<p><img src="/2023/01/26/misc/graphviz/test-1.png" alt="test-1"></p>
<p>我们来分段介绍内容</p>
<h4 id="节点node"><a href="#节点node" class="headerlink" title="节点node"></a>节点<code>node</code></h4><p>节点可以看作骨架,应当是最为基础的部分</p>
<p><code>node</code>有三种定义方式:</p>
<ol>
<li>使用<code>\node</code>定义,这里的定义方式应当为<code>\node [style and place] (name) &#123;label&#125;</code></li>
<li>在<code>draw</code>中定义,这种定义往往是用于在线上写字<code>-- node [name and position] &#123;label&#125;</code></li>
<li>使用<code>pin</code>定义</li>
</ol>
<p>然后关于位置,<code>pos</code>应该是线的位置,越大越靠近终点</p>
<h4 id="箭头draw"><a href="#箭头draw" class="headerlink" title="箭头draw"></a>箭头<code>draw</code></h4><p><code>\draw [-&gt;] (nodefrom) -- (nodeto)</code></p>
<p>直接在两个中间添加一个箭头(中间可以添加新节点)</p>
<p><code>\draw [-&gt;] (nodefrom) -| (nodeto)</code></p>
<p>这个箭头是折线</p>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><p>这里我们就直接套用好了没有必要去修改</p>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><p>下面我以控制系统中的一幅框图来实践刚才的知识(只保留)主干部分代码</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;[auto, node distance=2cm,&gt;=latex&#x27;]</span><br><span class="line">    <span class="keyword">\node</span> [input] (input) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [sum, right of=input] (sum1) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [block, right of=sum1] (controlp) &#123;<span class="built_in">$</span>k<span class="built_in">_</span>P<span class="built_in">$</span>&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [sum, right of=controlp,node distance=2cm] (sum2) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [input, above of=sum2] (dis) &#123;&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [block ,right of=sum2] (p) &#123;<span class="built_in">$</span><span class="keyword">\mathcal</span>&#123;P&#125;<span class="built_in">$</span>&#125;;</span><br><span class="line">    <span class="keyword">\node</span> [output, right of=p] (output) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\node</span> [output, below of=sum2] (ins) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (input) -- node &#123;<span class="built_in">$</span>r<span class="built_in">$</span>&#125; (sum1);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (sum1) -- node &#123;<span class="built_in">$</span>e<span class="built_in">$</span>&#125; (controlp);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (controlp) -- node &#123;<span class="built_in">$</span>u<span class="built_in">$</span>&#125; node[pos=0.99] &#123;+&#125; (sum2);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (dis) -- node &#123;<span class="built_in">$</span>d<span class="built_in">$</span>&#125; node[pos=0.99] &#123;+&#125; (sum2);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (sum2) -- (p);</span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (p) -- node[name=y] &#123;<span class="built_in">$</span>y<span class="built_in">$</span>&#125; (output);</span><br><span class="line">    <span class="keyword">\draw</span> [-] (y) |-   (ins);<span class="comment">%中间切断了一下</span></span><br><span class="line">    <span class="keyword">\draw</span> [-&gt;] (ins) -| node[pos=0.99] &#123;-&#125; (sum1);</span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>



<p>其渲染结果如下所示:</p>
<p><img src="/2023/01/26/misc/graphviz/image-20230127220705981.png" alt="image-20230127220705981"></p>
<p>可以看到渲染效果不错</p>
<blockquote>
<p>但是敲<code>tikz</code><strong>太累人</strong>了</p>
</blockquote>
<p>这里主要是介绍性使用<code>tikz</code>,更加完备的教程应当参考这个<a href="https://github.com/Hansimov/pgfmanual-zh">仓库</a></p>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>目前来说,我觉得还是<strong>截图保存</strong>的方式最便捷</p>
<p>虽然确实可以用<code>LaTex</code>直接导出,也可以用python对<code>pdf</code>进行转换,但是太麻烦,还是截图方便</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LaTex</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode特别功能总结</title>
    <url>/2023/01/17/misc/VSCode/</url>
    <content><![CDATA[<p>VSCode作为一个常用的编辑器(有时可以作为集成开发环境),其拥有许多重要的”特殊功能”,在这里进行笔记,以便未来查阅</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h2 id="正则表达式搜索替换"><a href="#正则表达式搜索替换" class="headerlink" title="正则表达式搜索替换"></a>正则表达式搜索替换</h2><h3 id="正则表达式速查表"><a href="#正则表达式速查表" class="headerlink" title="正则表达式速查表"></a>正则表达式速查表</h3><table>
<thead>
<tr>
<th>转义字符</th>
<th>匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车符号\r</td>
</tr>
<tr>
<td>\n</td>
<td>换行符号\n</td>
</tr>
<tr>
<td>\</td>
<td>特殊符号转义，如”<em>“ ，转义后匹配的是字符”</em>“， “(” 匹配的是括号”(“</td>
</tr>
<tr>
<td>[字符序列]</td>
<td>匹配[ ]中的任意字符，如[ae]，字符a和字符e均匹配</td>
</tr>
<tr>
<td>[^字符序列]</td>
<td>匹配不在[ ]中的任意字符，如[^ae]除了a和e，其他字符都匹配</td>
</tr>
<tr>
<td>[字符1-字符2]</td>
<td>匹配在[ ]之间的任意字符，如[a-x]，就是匹配a和x之间的所有字符（包括a和x）</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配任意单个字符(除了\n)</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有单词字符（如”a”，“3”，“E”，但不匹配”?”，”.”等）</td>
</tr>
<tr>
<td>\W</td>
<td>和\w相反，匹配所有非单词字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格</td>
</tr>
<tr>
<td>\S</td>
<td>和\s相反，匹配非空格</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字字符，如”1”，“4”，”9”等</td>
</tr>
<tr>
<td>\D</td>
<td>和\d相反，匹配除了数字字符外的其他字符</td>
</tr>
<tr>
<td>*</td>
<td>将前面的元素匹配0到多次，如”\d*.\d”，可以匹配”19.9”，”.0”,“129.9”</td>
</tr>
<tr>
<td>+</td>
<td>将前面的元素匹配1到多次，如”be+”，可以匹配”be”， “beeeeee”</td>
</tr>
<tr>
<td>？</td>
<td>将前面的元素匹配0次或者一次，如”rai?n” 可以且只可以匹配 “ran” 或者 “rain”</td>
</tr>
<tr>
<td>{n}</td>
<td>n是个数字，将前面的元素匹配n次，如”be{3}“可以且只可以匹配 ”beee”</td>
</tr>
<tr>
<td>{n, m}</td>
<td>将前面的元素匹配至少n次，最多m次，如”be{1,3}” 可以且只可以匹配”be”,“bee”, “beee”</td>
</tr>
<tr>
<td>|</td>
<td>相当于”或”,表示匹配由</td>
</tr>
</tbody></table>
<p>而正则表达式中的”子模式”<code>()</code>,在替换时可以使用<code>$1</code>来相应的替换.</p>
<p>例如对于<code>anaconda</code>导出的<code>environment.yml</code>文件,其一部分格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- packagename=0.0.0=aaaaa</span><br></pre></td></tr></table></figure>

<p>由于在跨操作系统迁移时要将后面那个详细版本给去掉因此可以使用替换功能</p>
<p>查找<code>(.=.)=.</code></p>
<p>替换为<code>$1</code></p>
<h2 id="VSC分屏显示"><a href="#VSC分屏显示" class="headerlink" title="VSC分屏显示"></a>VSC分屏显示</h2><p>由于在写代码时希望可以做到两个显示屏共同显示project的代码,因此需要用分屏显示</p>
<p>首先<code>ctrl+shift+P</code>,然后输入<code>Workspace: Duplicate As Workspace in New Window</code></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>对于数字信号处理的手段</title>
    <url>/2023/01/24/MPS010602/process-logical/</url>
    <content><![CDATA[<p>之前研究过对于<code>MPS010602</code>中的数字信号,应当如何处理(在其中使用二进制位来表示逻辑),今天恰好看到了<code>numpy.bitwise_xor</code>函数,会非常有用,在此记录一下</p>
<h2 id="逻辑位操作"><a href="#逻辑位操作" class="headerlink" title="逻辑位操作"></a>逻辑位操作</h2><p>在<code>numpy</code>库中有相应的逻辑操作函数,而最大的特点就在于它们可以实现向量化,这对于我们应用的场景来说非常重要.</p>
<p>其使用的方法与&amp;类似,主要看代码,以下代码展示如何从一个八进制数取出某一位的数字信号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_binary</span>(<span class="params">data_array:np.array,bit:<span class="built_in">int</span></span>):</span><br><span class="line">    check=<span class="number">1</span>&lt;&lt;bit</span><br><span class="line">    ca=np.array([check])</span><br><span class="line">    dataout=np.bitwise_and(data_array,ca)</span><br><span class="line">    <span class="keyword">return</span> np.where(dataout==<span class="number">0</span>,<span class="literal">False</span>,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MPS010602</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python发送邮件</title>
    <url>/2023/01/30/misc/pythonsmtp/</url>
    <content><![CDATA[<p>由于之前写了一个误差计算脚本,采用了万能的<code>nohup python calc_error.py &gt;logs &amp;</code>实现了后台运行,但是在实际使用过程中,经常会遇到异常或者一些奇奇怪怪的问题,自己每次上线检查也麻烦,遂思考能不能用邮件来解决问题.  </p>
<p>我参考<a href="https://zhuanlan.zhihu.com/p/24180606">这篇文章</a>,学习一下使用python发送邮件</p>
<h2 id="所用到的库"><a href="#所用到的库" class="headerlink" title="所用到的库"></a>所用到的库</h2><p>我们分为两部,一方面是写邮件的过程,需要特定的邮件头和附件,这一部分使用的是<code>email</code>模块进行</p>
<blockquote>
<p>我在使用<code>pip install email</code>的时候一直出错,但是到<code>pip install emails</code>就可以,目前不确定两者关系,但是都可以使用<code>import email</code>调用</p>
</blockquote>
<p>而编写完邮件后,对于邮件的发送则是通过<code>smtp</code>服务进行,这一部分则是用<code>smtplib</code>实现,而其安装可以用<code>pip install aiosmtplib</code>进行</p>
<h2 id="配置smtp"><a href="#配置smtp" class="headerlink" title="配置smtp"></a>配置<code>smtp</code></h2><p>我计划使用<code>Gmail</code>对这些邮件进行配置,为此,我打开了<code>Gmail</code>中的<code>imap</code>和<code>pop3</code>服务,关于<code>Gmail</code>更多信息如下,<a href="https://support.google.com/mail/answer/7126229">摘自于此</a></p>
<table>
<thead>
<tr>
<th>内容</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>接收邮件 (IMAP) 服务器</td>
<td>imap.gmail.com       要求 SSL：是       端口：993</td>
</tr>
<tr>
<td>发送邮件 (SMTP) 服务器</td>
<td>smtp.gmail.com       要求 SSL：是       要求 TLS：是（如适用）       使用身份验证：是       SSL 端口：465       TLS&#x2F;STARTTLS 端口：587</td>
</tr>
<tr>
<td>完整名称或显示名称</td>
<td>您的姓名</td>
</tr>
<tr>
<td>帐号名、用户名或电子邮件地址</td>
<td>您的完整电子邮件地址</td>
</tr>
<tr>
<td>密码</td>
<td>您的 Gmail 密码</td>
</tr>
</tbody></table>
<h2 id="尝试发送邮件"><a href="#尝试发送邮件" class="headerlink" title="尝试发送邮件"></a>尝试发送邮件</h2><p>下面代码展示发送测试邮件过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line">mail_host=<span class="string">&#x27;&#x27;</span></span><br><span class="line">mail_user=<span class="string">&#x27;&#x27;</span></span><br><span class="line">mail_pass=<span class="string">&#x27;&#x27;</span></span><br><span class="line">sender=<span class="string">&#x27;&#x27;</span></span><br><span class="line">receivers=[<span class="string">&#x27;&#x27;</span>]<span class="comment">#可以群发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置邮件信息</span></span><br><span class="line">message=MIMEText(<span class="string">&#x27;content&#x27;</span>,<span class="string">&#x27;plain&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">message[<span class="string">&#x27;Subject&#x27;</span>]=<span class="string">&quot;Test email&quot;</span></span><br><span class="line">message[<span class="string">&#x27;From&#x27;</span>]=sender</span><br><span class="line">message[<span class="string">&#x27;To&#x27;</span>]=receivers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># smtpobj=smtplib.SMTP()</span></span><br><span class="line">    <span class="comment"># smtpobj.connect(mail_host,25)#这是无需ssl验证的情况</span></span><br><span class="line">    smtpobj=smtplib.SMTP_SSL(mail_host)<span class="comment">#这是需要ssl验证的情况</span></span><br><span class="line">    smtpobj.login(mail_user,mail_pass)</span><br><span class="line">    smtpobj.sendmail(sender,receivers,message.as_string())</span><br><span class="line">    smtpobj.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Success&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> smtplib.SMTPException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>,e)</span><br></pre></td></tr></table></figure>

<p>这个代码确实可以发送邮件,测试完成</p>
<h2 id="添加附件"><a href="#添加附件" class="headerlink" title="添加附件"></a>添加附件</h2><p>我们可以利用<code>MIMENonMultipart</code>中的<code>MIMEText</code>类来发送我们得到的csv文件</p>
<p>可以参考<a href="https://www.cnblogs.com/sunjump/p/15593585.html">这篇文章</a></p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>自然,我们可以实现更多内容(比如HTML等),但是我目前不需要,就先留在这里,可能未来还会更新</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python环境配置</title>
    <url>/2023/01/17/python/anaconda/</url>
    <content><![CDATA[<p>像环境配置这样的问题虽然如果想非常快弄完,也不难(你甚至可以去Mircosoft Store里面下载一个Python环境),然而,这么做*<strong>后患无穷</strong>,尤其是等到要安装一些复杂的包的时候.因此,在这篇文章中,我将介绍<code>conda</code>的使用和Python中最常见的两个环境<code>IPython</code>和<code>Jupyter Notebook</code>的相关配置,以及使用<code>VScode</code>编辑器.</p>
<h2 id="conda的使用"><a href="#conda的使用" class="headerlink" title="conda的使用"></a><code>conda</code>的使用</h2><h3 id="为什么要用conda"><a href="#为什么要用conda" class="headerlink" title="为什么要用conda"></a>为什么要用<code>conda</code></h3><blockquote>
<blockquote>
<p><em>Package, dependency and environment management for any language—Python, R, Ruby, Lua, Scala, Java, JavaScript, C&#x2F; C++, FORTRAN</em></p>
</blockquote>
</blockquote>
<p><code>conda</code>作为一个包管理器,可以保证你的电脑上同时存在多个不同的Python版本,并且每一个版本之间都相互独立,互不干扰(为何同时要有多个版本,因为许多包<strong>不是向下兼容的</strong>.简单的说,就是对于一个依赖,安装其最新的版本<strong>并不总是一个好的选择</strong>)</p>
<p>这是其优点的一方面,而另外一个方面则更为重要,在<code>conda</code>中,你可以打包,发布你的程序,这样可以非常方便的实现代码的共享(这可比直接拷贝源文件来得方便)</p>
<p>而我们这次使用的是<code>conda</code>的一个发行版(?有可能是别的名称)<code>anaconda</code>,并且以我个人电脑为例,讨论其安装与使用.</p>
<h3 id="anaconda的安装"><a href="#anaconda的安装" class="headerlink" title="anaconda的安装"></a><code>anaconda</code>的安装</h3><p>首先在<a href="https://www.anaconda.com/">官网</a>上下载<code>anaconda</code>(这个时候要养成在官网下载的习惯,不要下一堆杂七杂八的东西)</p>
<p>然后安装<code>anaconda</code>,首先它会问你是给<code>本用户安装</code>还是<code>给所有用户安装</code>,我个人建议是前者(但实际上就我所知,99%家里的Windows电脑只有一个用户)</p>
<p>之后就会有这样一个提示框</p>
<p><img src="/2023/01/17/python/anaconda/1.png" alt="image-20230117094427619"></p>
<p>这里有两个选项,我刚好要和推荐配置唱一波反调:</p>
<ol>
<li>第一个选项有关于环境变量,虽然上面并不建议添加到环境变量,但是如果不这么做,很多时候会非常麻烦</li>
<li>第二个选项是覆盖原有Python成为默认环境,我个人倾向于如果已经有Python环境了,就不要覆盖,免得影响现有依赖</li>
</ol>
<p>然后就是点击<code>Install</code>等待其安装.</p>
<h3 id="anaconda的使用"><a href="#anaconda的使用" class="headerlink" title="anaconda的使用"></a><code>anaconda</code>的使用</h3><p>安装完<code>anaconda</code>之后,你可以打开你电脑上的<code>Anaconda Powershell Prompt</code>,然后可以看见一个命令行界面</p>
<p><img src="/2023/01/17/python/anaconda/2.png" alt="image-20230117095543879"></p>
<p>不过与<code>Powershell</code>不同的是,在<code>anaconda</code>里面有一个<code>(base)</code>,这意味着你目前处于一个基础环境.</p>
<p>然后如果你在其中输入<code>IPython</code>,那么就会有<code>IPython</code>的界面跳出来,表明其已经被安装了.</p>
<p>而<code>Jupyter</code>环境则可以通过输入<code>jupyter notebook</code>尝试,你们会得到这样的界面:</p>
<p><img src="/2023/01/17/python/anaconda/3.png" alt="image-20230117100215561"></p>
<p>表明<code>Jupyter</code>内核已经启动,然后你需要使用浏览器去连接这个内核</p>
<blockquote>
<p>怎么连接希望大家自己想想,毕竟大家都懂英文</p>
</blockquote>
<p>但是实际上,我更加推荐使用<code>VSCode</code>作为<code>Jupyter</code>的编辑器,不过<code>jupyter</code>命令有别的功能,比如转换笔记本,大家可以去查找一下.</p>
<h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><p>好,现在假设我需要创造一个环境用来给我做机器学习,那么我们可以用</p>
<p><code>conda create -n &quot;machine-learning&quot; python=3.8</code>来创建,这里我配置了一个名字叫”machine-learning”的环境,使用的python版本为3.8</p>
<p>安装好之后,在<code>anaconda</code>里面输入<code>conda info -e</code>(展示所有的环境),就可以看到这样的结果</p>
<p><img src="/2023/01/17/python/anaconda/4.png" alt="image-20230117101138010"></p>
<p>这表明新的环境已经被成功安装,然后输一下<code>ipython</code>试一试</p>
<p><img src="/2023/01/17/python/anaconda/5.png" alt="image-20230117134918357"></p>
<p>淦,出错了,<strong>还是原来的python环境没变</strong></p>
<p>经过分析,我发现这个是我电脑原本安装的python,<strong>由于我的<code>conda</code>环境里面并没有<code>ipython</code>,因此在寻找的时候按照先后顺序就找到了自己电脑的<code>ipython</code></strong></p>
<p>因此,<em><strong>在使用<code>conda</code>的时候,务必注意环境里面你打开的究竟是哪个内核.</strong></em></p>
<h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p>比如说,我现在要安装<code>sklearn</code>库,那么我就在网上搜索<code>sklearn anaconda</code>,然后就搜到了安装指令<code>conda install -c anaconda scikit-learn</code><a href="https://anaconda.org/anaconda/scikit-learn">网址</a></p>
<p>把这输进去(注意检查当前的环境),然后安装即可</p>
<p>其会自动安装依赖,比如:</p>
<p><img src="/2023/01/17/python/anaconda/9.png" alt="image-20230117141643636"></p>
<h4 id="转移环境"><a href="#转移环境" class="headerlink" title="转移环境"></a>转移环境</h4><p>假如你千辛万苦配好一个环境并且成功运行了一套程序,然后你需要移到别的电脑上运行(这台电脑可能是别的系统)</p>
<p>你可以采用<code>conda env export &gt; environment.yml</code>来创建一个配置文件,然后把这个文件复制到另外一台电脑(可能是集群),然后<code>conda env create -f environment.yml</code>,就可以在不同的操作系统平台上复现环境</p>
<blockquote>
<p>这种情况并不少见,你可能希望在自己电脑上(Windows或Mac)编程,然后到集群上(Linux)运行</p>
</blockquote>
<p>可以参考一下<a href="https://www.jianshu.com/p/dea48074b5b8">这个网页</a></p>
<blockquote>
<p>需要注意删除一些不必要的库以提升可移植性</p>
</blockquote>
<h4 id="源配置"><a href="#源配置" class="headerlink" title="源配置"></a>源配置</h4><p>由于一些众所周知的原因,大家需要使用国内镜像站,可以给一个网址</p>
<h2 id="VSCode的安装与使用"><a href="#VSCode的安装与使用" class="headerlink" title="VSCode的安装与使用"></a><code>VSCode</code>的安装与使用</h2><p><code>VSCode</code>作为一个常用编辑器,其安装并不复杂,这个大家自己网上搜就可以了.</p>
<h3 id="VSCode的常用插件"><a href="#VSCode的常用插件" class="headerlink" title="VSCode的常用插件"></a>VSCode的常用插件</h3><ol>
<li>Better Comments</li>
<li>Jupyter(注意,在使用前,需要安装好<code>Jupyter</code>内核)</li>
<li>Python(为python程序设计提供IDE环境)</li>
</ol>
<h2 id="最后想要提醒的"><a href="#最后想要提醒的" class="headerlink" title="最后想要提醒的"></a>最后想要提醒的</h2><p>在每次打开程序的时候,务必要注意打开的python版本</p>
<p>比如:</p>
<p><img src="/2023/01/17/python/anaconda/6.png" alt="image-20230117140557615"></p>
<p><img src="/2023/01/17/python/anaconda/7.png" alt="image-20230117140625609"></p>
<p><img src="/2023/01/17/python/anaconda/8.png" alt="image-20230117141531520"></p>
]]></content>
      <categories>
        <category>python培训</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>库索引与编写__init__.py</title>
    <url>/2023/02/14/python/pyinit/</url>
    <content><![CDATA[<p><code>__init__.py</code>,这个文件很不起眼,而且经常会被人忽略,但是实际在软件开发的过程中非常重要,在这里,我将简单介绍一下<code>__init__.py</code>的编写以及相关可能会遇到的坑.</p>
<span id="more"></span>
<h2 id="引入-多文件夹运行模式"><a href="#引入-多文件夹运行模式" class="headerlink" title="引入:多文件夹运行模式"></a>引入:多文件夹运行模式</h2><p>就以之前的三维移动平台中遇到的例子,由于测量设备三天两头更换,因此需要设计一个方便的切换模块的方式</p>
<blockquote>
<p>我个人感觉这有点像C里面的<code>#ifdef</code>命令,但是这里是脚本语言</p>
</blockquote>
<p>于是就有了这样一个文件结构<br><img src="/Pasted%20image%2020230214235917.png"><br>当我在外面调用<code>import Measuredevices</code>这个命令的时候,我希望能够通过调用<code>Measuredevices.MeasureControl</code>来直接得到</p>
<h2 id="基本的概念"><a href="#基本的概念" class="headerlink" title="基本的概念"></a>基本的概念</h2><p>当你<code>import</code>一个文件夹时,解释器会首先运行<code>__init__.py</code>,执行其中的内容,那么你可以在这一步中进行一些初始化的操作(比如检查系统版本,依赖库之类)<br>因此,我可以这么做,在<code>__init__.py</code>中写入<br><code>from mps import * </code><br>这样的写法使得我们无需关注内部的库结构,实现遍历的调用</p>
<blockquote>
<p>这在为不同系统提供环境支持的时候尤为重要,可能用户看起来调用的同一个库,因为环境不同而实现完全不同</p>
</blockquote>
<p>当然,也可以使用<code>__all__</code>来实现更加精准的调用,可以参考<a href="https://blog.csdn.net/weixin_44835732/article/details/103901283">这篇文章</a></p>
<h2 id="遇到的问题与库调用逻辑"><a href="#遇到的问题与库调用逻辑" class="headerlink" title="遇到的问题与库调用逻辑"></a>遇到的问题与库调用逻辑</h2><p>但是我们在这么做之前需要注意到:python库的查找需要修改<code>sys.path</code>,这样文件夹中的<code>__init__.py</code>就<strong>无法找到</strong>一个文件夹中的文件,因此,需要在<code>sys.path</code>中添加上当前文件所在位置<br><code>sys.path.append(os.path.dirname(__file__))</code></p>
<blockquote>
<p>当然,用完之后(在退出<code>__init__.py</code>的时候)记得恢复,否则你的<code>path</code>会非常臃肿</p>
</blockquote>
]]></content>
      <categories>
        <category>python培训</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为分类问题训练简单的机器学习算法</title>
    <url>/2023/01/24/machine-learning/machine1/</url>
    <content><![CDATA[<h2 id="标记与术语"><a href="#标记与术语" class="headerlink" title="标记与术语"></a>标记与术语</h2><ul>
<li>特征(features):例如数据的种类(一般以列存储)</li>
<li>样本(samples):一般以行存储,数据列表<br>$x^i_j$指第$i$个训练样本,训练集的第$j$维(第$j$个特征)<blockquote>
<p>这种标记输入输出均可</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>另外,机器学习是一回事,这本书中的python代码非常优美,值得学习</p>
</blockquote>
<h1 id="为分类问题训练简单的机器学习算法"><a href="#为分类问题训练简单的机器学习算法" class="headerlink" title="为分类问题训练简单的机器学习算法"></a>为分类问题训练简单的机器学习算法</h1><p>在这一部分,我们构造一个简单的线性分类算法实现我们的分类任务</p>
<h2 id="早期的机器学习模型"><a href="#早期的机器学习模型" class="headerlink" title="早期的机器学习模型"></a>早期的机器学习模型</h2><p>最早的机器学习模型是通过模拟神经元实现的<br>我们可以定义一个决定函数$\phi(x)$来从输入得到输出<br>通过将权重矢量与输入矢量点乘后通过一个阈值函数得到输出.<br>因此,通过计算$sign(\omega^Tx+\omega_0)$即可得到一个<strong>二分类输出</strong></p>
<span id="more"></span>

<h3 id="学习的逻辑"><a href="#学习的逻辑" class="headerlink" title="学习的逻辑"></a>学习的逻辑</h3><p>每一次学习,都需要让计算结果更加接近,因此需要更新权重矢量得到$\Delta \omega$<br>而$\Delta \omega&#x3D;\eta(y^i-\hat{y}^i)x$<br>式中的$\eta$被称为<strong>学习率</strong><br>其过程可以被总结为<br><img src="/2023/01/24/machine-learning/machine1/image-20230124170806576.png" alt="png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面我们尝试构造一个类来解决这个问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Perception</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,eta=<span class="number">0.01</span>,n_iter=<span class="number">100</span>,random_state=<span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.eta=eta</span><br><span class="line">        self.n_iter=n_iter</span><br><span class="line">        self.random_state=random_state</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fitdata</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        self.errors_=[]<span class="comment">#aa_下划线代表运行后才存在的属性</span></span><br><span class="line">        rs=np.random.RandomState(self.random_state)<span class="comment">#种子生成随机数</span></span><br><span class="line">        self.w_=rs.normal(scale=<span class="number">0.1</span>,size=<span class="number">1</span>+X.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iter):</span><br><span class="line">            error=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x,yreal <span class="keyword">in</span> <span class="built_in">zip</span>(X,y):</span><br><span class="line">                ytest=np.where(np.dot(x,self.w_[:-<span class="number">1</span>])+self.w_[-<span class="number">1</span>]&gt;<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">                self.w_[:-<span class="number">1</span>]+=self.eta*(yreal-ytest)*x</span><br><span class="line">                self.w_[-<span class="number">1</span>]+=self.eta*(yreal-ytest)</span><br><span class="line">                error+=np.count_nonzero(yreal-ytest)</span><br><span class="line">            self.errors_.append(error)</span><br><span class="line">            <span class="keyword">if</span>(error==<span class="number">0</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;The fitting have completed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The max iteration have reached&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">net_input</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.dot(X,self.w_[:-<span class="number">1</span>])+self.w_[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.where(self.net_input(X)&gt;=<span class="number">0.0</span>,<span class="number">1</span>,-<span class="number">1</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个类中我们定义<code>fit</code>实现拟合,拟合之后会有两个属性,分别为<code>w_</code>和<code>errors_</code>一个记录了线性参数,另外一个记录了误差</p>
<h2 id="使用鸢尾花数据集训练这个分类模型"><a href="#使用鸢尾花数据集训练这个分类模型" class="headerlink" title="使用鸢尾花数据集训练这个分类模型"></a>使用鸢尾花数据集训练这个分类模型</h2><p>为了测试我们这个的效果,我们将对山鸢尾和变色秋海棠两种不同的花进行分类,虽然特征不一定要是二维的,但是为了展示方便,我们使用两个特征萼片长度和花瓣长度作为特征.</p>
<p>我们首先使用<code>pandas</code>将数据从数据库中加载出来,并且看看大概</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.read_csv(<span class="string">&#x27;https://archive.ics.uci.edu/ml/&#x27;</span></span><br><span class="line">               <span class="string">&#x27;machine-learning-databases/iris/iris.data&#x27;</span>,</span><br><span class="line">               header=<span class="literal">None</span>)</span><br><span class="line">df.tail()               </span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>Iris-virginica</td>
    </tr>
  </tbody>
</table>
</div>



<p>接下来,我们将前50个山鸢尾和前50个变色秋海棠的记录提取出来,分别标记为-1和1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y=df.iloc[<span class="number">0</span>:<span class="number">100</span>,<span class="number">4</span>].values</span><br><span class="line">y=np.where(y==<span class="string">&#x27;Iris-setosa&#x27;</span>,-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X=df.iloc[<span class="number">0</span>:<span class="number">100</span>,[<span class="number">0</span>,<span class="number">2</span>]].values</span><br><span class="line"></span><br><span class="line">plt.scatter(X[y==-<span class="number">1</span>,<span class="number">0</span>],X[y==-<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">&#x27;red&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;setosa&#x27;</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">&#x27;blue&#x27;</span>,marker=<span class="string">&#x27;x&#x27;</span>,label=<span class="string">&#x27;versicolor&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;sepal length [cm]&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;petal length [cm]&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/24/machine-learning/machine1/11_0.png" alt="png"></p>
<p>我们可以从上面那张图中看出来两种花可以被很好的区分开来,接下来我们来训练一下试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model=Perception(<span class="number">0.001</span>)<span class="comment">#这里特地将eta调的很小使得梯度下降过程明显</span></span><br><span class="line">model.fitdata(X,y)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(model.errors_)+<span class="number">1</span>),model.errors_,<span class="string">&#x27;o-&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;errors&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>The fitting have completed
</code></pre>
<p><img src="/2023/01/24/machine-learning/machine1/13_1.png" alt="png"></p>
<p>可以注意到,最后的<code>errors</code>已经为0,为了进一步观察我们拟合的效果,我们将定义一个函数用来描绘决定区间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_decision_regions</span>(<span class="params">X,y,classifier,resolution=<span class="number">0.02</span></span>):</span><br><span class="line">    <span class="comment">#setup marker generator and color map</span></span><br><span class="line">    markers = (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">    colors = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;lightgreen&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>)</span><br><span class="line">    cmap = ListedColormap(colors[:<span class="built_in">len</span>(np.unique(y))])<span class="comment"># unique函数可以找到所有独立的元素</span></span><br><span class="line">    <span class="comment">#plot the surface</span></span><br><span class="line">    x1_min,x1_max=X[:,<span class="number">0</span>].<span class="built_in">min</span>()-<span class="number">1</span>,X[:,<span class="number">0</span>].<span class="built_in">max</span>()+<span class="number">1</span></span><br><span class="line">    x2_min,x2_max=X[:,<span class="number">1</span>].<span class="built_in">min</span>()-<span class="number">1</span>,X[:,<span class="number">1</span>].<span class="built_in">max</span>()+<span class="number">1</span><span class="comment">#X1,X2分别是X轴Y轴</span></span><br><span class="line">    xx1,xx2=np.meshgrid(np.arange(x1_min,x1_max,resolution),</span><br><span class="line">                        np.arange(x2_min,x2_max,resolution))</span><br><span class="line">    Z=classifier.predict(np.array([xx1.ravel(),xx2.ravel()]).T)<span class="comment">#这里要将数组展平(这里面的向量操作非常有趣)</span></span><br><span class="line">    Z=Z.reshape(xx1.shape)</span><br><span class="line">    plt.contourf(xx1,xx2,Z,alpha=<span class="number">0.3</span>,cmap=cmap)</span><br><span class="line">    plt.xlim(xx1.<span class="built_in">min</span>(),xx1.<span class="built_in">max</span>())</span><br><span class="line">    plt.ylim(xx2.<span class="built_in">min</span>(),xx2.<span class="built_in">max</span>())</span><br><span class="line">    <span class="comment">#plot class samples</span></span><br><span class="line">    <span class="keyword">for</span> idx,cl <span class="keyword">in</span> <span class="built_in">enumerate</span>(np.unique(y)):<span class="comment">#这里使用enumerate来同时获得标签</span></span><br><span class="line">        plt.scatter(x=X[y==cl,<span class="number">0</span>],</span><br><span class="line">                    y=X[y==cl,<span class="number">1</span>],</span><br><span class="line">                    alpha=<span class="number">0.8</span>,</span><br><span class="line">                    c=colors[idx],</span><br><span class="line">                    marker=markers[idx],</span><br><span class="line">                    label=cl,</span><br><span class="line">                    edgecolors=<span class="string">&#x27;black&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来,我们来展示一下绘图的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_decision_regions(X,y,classifier=model)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;sepal length [cm]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal length [cm]&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\lison\AppData\Local\Temp\ipykernel_25612\3891387916.py:20: UserWarning: You passed a edgecolor/edgecolors (&#39;black&#39;) for an unfilled marker (&#39;x&#39;).  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
  plt.scatter(x=X[y==cl,0],
</code></pre>
<p><img src="/2023/01/24/machine-learning/machine1/17_1.png" alt="png"></p>
<blockquote>
<p>刚刚我们实现的可以被认为是一个单层的神经网络</p>
</blockquote>
<h2 id="可适应性线性神经元与学习收敛"><a href="#可适应性线性神经元与学习收敛" class="headerlink" title="可适应性线性神经元与学习收敛"></a>可适应性线性神经元与学习收敛</h2><p>在这一部分,我们将研究另外一种单层神经网络:ADAptive LInear NEuron(<code>Adaline</code>)<br>这种算法非常有趣因为其展现了关于定义和最小化连续损失函数的方法,这便于让我们理解之后我们所用的相关函数<br><code>Adaline</code>算法与感知机最关键的区别在于权重函数是使用一个线性激发函数而非一个单位阶跃函数,在<code>Adaline</code>算法中<br>这样一个线性激发函数就是网络输入的线性函数因此有:<br>$$\phi(w^Tx)&#x3D;w^Tx$$<br>虽然激发函数是用在学习权重的,但我们也可以用其来评估最后结果,<code>ADaline</code>的特殊性可以用下面一张图来展示<br><img src="/2023/01/24/machine-learning/machine1/image-20230124170927708.png" alt="png"></p>
<h3 id="使用梯度下降法最小化损失函数"><a href="#使用梯度下降法最小化损失函数" class="headerlink" title="使用梯度下降法最小化损失函数"></a>使用梯度下降法最小化损失函数</h3><p>对于<code>Adaline</code>而言,我们可以定义损失函数$J$并且使用方均根法得到权重<br>$$J(\omega)&#x3D;\frac{1}{2}\sum_i(y^{(i)}-\phi(z^{(i)}))^2$$<br>在该式中,$\frac{1}{2}$只是为了方便求梯度,接下来我们就可以使用一个非常有效的方法<strong>梯度下降法</strong>来使损失函数最小,原理为<br>$$\Delta \omega&#x3D;-\eta\nabla J(\omega)$$<br>梯度的计算为<br>$$\frac{\partial J}{\partial \omega_j}&#x3D;-\sum_i(y^{(i)}-\phi(z^{(i)}))x^{(i)}_j$$</p>
<blockquote>
<p>需要注意一个计算上的不同,在此处我们的计算是<strong>所有样本一起算的</strong>而不是像之前一样<strong>一个样本更新一次</strong></p>
</blockquote>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdalineGD</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,eta=<span class="number">0.001</span>,n_iter=<span class="number">100</span>,random_state=<span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.eta=eta</span><br><span class="line">        self.n_iter=n_iter</span><br><span class="line">        self.random_state=random_state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        rgen=np.random.RandomState(self.random_state)</span><br><span class="line">        self.w_=rgen.normal(<span class="number">0.0</span>,<span class="number">0.1</span>,size=<span class="number">1</span>+X.shape[<span class="number">1</span>])</span><br><span class="line">        self.cost_=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iter):</span><br><span class="line">            err,errg,errw0=self._calc_cost(X,y)</span><br><span class="line">            self.cost_.append(err)</span><br><span class="line">            self.w_[<span class="number">1</span>:]+=-self.eta*errg</span><br><span class="line">            self.w_[<span class="number">0</span>]+=-self.eta*errw0</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calc_cost</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        yp=(np.dot(X,self.w_[<span class="number">1</span>:].reshape(-<span class="number">1</span>,<span class="number">1</span>))+self.w_[<span class="number">0</span>]).reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#print(yp)</span></span><br><span class="line">        err=np.<span class="built_in">sum</span>((yp[<span class="number">0</span>]-y)**<span class="number">2</span>)/<span class="number">2</span></span><br><span class="line">        errg=np.dot((yp[<span class="number">0</span>]-y),X)</span><br><span class="line">        errw0=np.<span class="built_in">sum</span>(yp[<span class="number">0</span>]-y)</span><br><span class="line">        <span class="keyword">return</span> err,errg[<span class="number">0</span>],errw0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.where(np.dot(X,self.w_[<span class="number">1</span>:])+self.w_[<span class="number">0</span>]&gt;<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>接下来,我们将之前的数据输入进去试一试看看如何</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y=df.iloc[<span class="number">0</span>:<span class="number">100</span>,<span class="number">4</span>].values</span><br><span class="line">y=np.where(y==<span class="string">&#x27;Iris-setosa&#x27;</span>,-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X=df.iloc[<span class="number">0</span>:<span class="number">100</span>,[<span class="number">0</span>,<span class="number">2</span>]].values</span><br><span class="line">adamodel=AdalineGD()</span><br><span class="line">adamodel.fit(X,y)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(adamodel.cost_)+<span class="number">1</span>),np.log(adamodel.cost_),<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;log(cost)&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">adamodel.w_</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/24/machine-learning/machine1/24_0.png" alt="png"><br>​    </p>
<pre><code>array([-3.89410517e+55, -2.18332011e+56, -2.18332011e+56])
</code></pre>
<p>可以发现,程序直接爆炸,此时可能是$eta$调大了,我们把$eta$调为1E-5试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y=df.iloc[<span class="number">0</span>:<span class="number">100</span>,<span class="number">4</span>].values</span><br><span class="line">y=np.where(y==<span class="string">&#x27;Iris-setosa&#x27;</span>,-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X=df.iloc[<span class="number">0</span>:<span class="number">100</span>,[<span class="number">0</span>,<span class="number">2</span>]].values</span><br><span class="line">adamodel=AdalineGD(eta=<span class="number">4E-4</span>,n_iter=<span class="number">10000</span>)</span><br><span class="line">adamodel.fit(X,y)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(adamodel.cost_)+<span class="number">1</span>),adamodel.cost_,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;log(cost)&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">adamodel.w_</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/24/machine-learning/machine1/26_0.png" alt="png"><br>​    </p>
<pre><code>array([-3.33272936,  0.39707341,  0.40543187])
</code></pre>
<p>可以注意到,逐渐在趋向一个稳定值,这之中存在的问题可以用下图展示<br><img src="/2023/01/24/machine-learning/machine1/image-20230124171511278.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_decision_regions(X,y,classifier=adamodel)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;sepal length [cm]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal length [cm]&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\lison\AppData\Local\Temp\ipykernel_25612\3891387916.py:20: UserWarning: You passed a edgecolor/edgecolors (&#39;black&#39;) for an unfilled marker (&#39;x&#39;).  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
  plt.scatter(x=X[y==cl,0],
</code></pre>
<p><img src="/2023/01/24/machine-learning/machine1/28_1.png" alt="png"></p>
<p>可以注意到,这种计算方法非常依赖初值,而且最后也没有完全分开来,并不是非常理想,因此需要优化</p>
<h3 id="使用标准化提升梯度下降法效果"><a href="#使用标准化提升梯度下降法效果" class="headerlink" title="使用标准化提升梯度下降法效果"></a>使用标准化提升梯度下降法效果</h3><p>标准化是一个机器学习过程中的非常重要的手段,在这一部分中,我们使用一种<em>正态分布标准化</em><br>这种方法假定数据呈现出正态分布,处理的手段是将数据减去平均值并且除以数据的标准差,即:<br>$$x_j’&#x3D;\frac{x_j-\mu}{\sigma}$$<br>这么做的好处在于可以让优化器更快的实现达到最低值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_std=np.copy(X)</span><br><span class="line">X_std[:,<span class="number">0</span>]=(X[:,<span class="number">0</span>]-X[:,<span class="number">0</span>].mean())/X[:,<span class="number">0</span>].std()</span><br><span class="line">X_std[:,<span class="number">1</span>]=(X[:,<span class="number">1</span>]-X[:,<span class="number">1</span>].mean())/X[:,<span class="number">1</span>].std()</span><br></pre></td></tr></table></figure>

<p>在标准化之后,我们将数据输入到前面的模型中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stdada=AdalineGD(<span class="number">1E-3</span>,<span class="number">150</span>,<span class="number">1</span>)</span><br><span class="line">stdada.fit(X_std,y)</span><br><span class="line">plot_decision_regions(X_std,y,classifier=stdada)</span><br></pre></td></tr></table></figure>





<p><img src="/2023/01/24/machine-learning/machine1/33_1.png" alt="png"></p>
<p>效果变好了一些(但实际上初值问题仍然存在)</p>
<h2 id="大规模机器学习与随机梯度下降法"><a href="#大规模机器学习与随机梯度下降法" class="headerlink" title="大规模机器学习与随机梯度下降法"></a>大规模机器学习与随机梯度下降法</h2><p>现在我们考虑一个非常巨大的数据集(可能有上百万的数据)<br>我们现在用另外一种方式,对于每一个数据,都对$\Delta \omega$进行一次更新,实际上随机梯度下降法达到稳定的速度快于批量梯度下降法(虽然前者看起来是后者的近似)</p>
<p>为了更好的进行梯度下降法,我们需要对数据进行一个更好的随机化处理<br>同时,这么做还有一个好处,因为在一些网络程序之中,数据和模型的训练是同步进行的</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习建议</title>
    <url>/2023/02/07/python/python-learning/</url>
    <content><![CDATA[<p>非常不幸,像我这种半吊子都要给大家来讲Python学习的问题了</p>
<p>我大概会分成以下几个部分来讲:</p>
<ol>
<li>为什么要学python</li>
<li>基础的学习</li>
<li>进阶的学习</li>
<li>其他的一些建议</li>
</ol>
<p>大家挑感兴趣的看吧</p>
<span id="more"></span>

<h2 id="为什么要学python"><a href="#为什么要学python" class="headerlink" title="为什么要学python"></a>为什么要学python</h2><p>我一开始也是不想学,感觉这个玩意简直就是市面上某些广告的最爱,让人觉得非常轻浮.甚至都没有大括号(我当时曾经接触过<code>C,C++,C#,Ruby,汇编</code>等语言,自然是非常不精,但也算会一点点(现在除了<code>C/C++</code>其他全忘了))</p>
<p>接触python的主要契机是当时我想写一个爬虫,然后想想python看起来实现最简单,于是就开始学了起来</p>
<p>现在想想,确实python对我来讲意义重大,因为它有着强大的数学计算功能,但又究竟是一门以编程为目的的语言(问就是Matlab学PTSD了),有着非常多有用的库,而且这些库都是帮你配置好的<em>有人抱怨过python环境配置,那你是没有体验过C++各种链接库调用</em></p>
<p>同时,python也是一个内存友好的语言,它能让你不用担心内存都去哪了(否则面对C&#x2F;C++,你可能要花整天时间研究你的程序是如何泄露掉20个G内存的)</p>
<p>自然,python运行效率底下也总是被人所诟病,但是这在我们的应用环境中并不重要,我们注重的是开发效率,而对于那种计算密集型的问题,如果安排妥当,调库的效率实际上可能更高,实在不行,你还有一个”大杀器”,用C++编写python扩展</p>
<blockquote>
<p>效率的陷阱</p>
<p>有些时候,C++写出来的程序真的不一定比python快,倘使你参加过信息学竞赛就会知道,很多问题的优化绝不是我们这种人能完全掌握的(我们是外行)</p>
</blockquote>
<h2 id="基础的学习"><a href="#基础的学习" class="headerlink" title="基础的学习"></a>基础的学习</h2><p>对于以前没有学过计算机程序设计语言的人来说,python作为你的第一个语言还是很不错的,我个人建议你还是可以去报python课(反正有学分)</p>
<p>然后尽量挑一本书(最好是一本国外教材),从头到尾读一遍,将里面的东西实践一下(先不要管它有没有用,除非是那种教你搭建网页之类的,具体原因后面会讲)</p>
<p>这样也许就可以了,你已经掌握了python的学习</p>
<h2 id="进阶的学习"><a href="#进阶的学习" class="headerlink" title="进阶的学习"></a>进阶的学习</h2><p>如果你自觉自己基础的python学的很好了(<strong>我这里的标准是理论上你什么都可以干了</strong>),那么你就需要记住这样一句话,这是<em>Fluent Python</em>一书的作者写的</p>
<blockquote>
<p>We only miss stuff we know about.</p>
</blockquote>
<p>这句话很有深意,比如我们要把两个数组相加,首先想到的必然是用<code>for</code>循环,但是实际上生成器或者甚至<code>numpy</code>给了我们更加简单和高效的解决方案</p>
<p>所以要把东西读完,而不是觉得”这是重复的”就跳了过去.</p>
<blockquote>
<p>所以,在做一个东西的时候,先查一下有没有现成的解决方案</p>
</blockquote>
<p>但是你到这一步,要专门学的东西也不多了,可能一个是<code>numpy</code>,还有一个就是<code>scikit-learn</code>,毕竟python对我们而言,主要还是工具,而不是目的</p>
<blockquote>
<p>倘使你对于python语言的高级特性感兴趣的话,建议去读一下<em>Fluent Python</em>一书,前提是你要学的够好,也许可以先看看<a href="/2023/02/07/python/vectorize/" title="向量化与面向对象">vectorize</a></p>
</blockquote>
<p>另外,我强烈推荐大家在学习库的用法时,去读<strong>文档</strong>,那个东西比你在CSDN上面看到的各种教程都有用也更加详细.</p>
<blockquote>
<p>文档可比论文简单多了,毕竟就像使用说明</p>
</blockquote>
<h2 id="其他的一些建议"><a href="#其他的一些建议" class="headerlink" title="其他的一些建议"></a>其他的一些建议</h2><h3 id="关于Jupyter-Notebook"><a href="#关于Jupyter-Notebook" class="headerlink" title="关于Jupyter Notebook"></a>关于Jupyter Notebook</h3><p>我蛮喜欢这个可以将文档和代码放到一起的格式,但是我不建议大家去网上下载这样的电子书</p>
<p>我建议大家对于示例代码,<strong>自己敲进去</strong>,不一定要像书上那么完备,可以偷个懒,但是在偷懒的过程也是你思考的过程</p>
]]></content>
      <categories>
        <category>python培训</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用C++为python编写扩展</title>
    <url>/2023/02/05/misc/cpython/</url>
    <content><![CDATA[<blockquote>
<p>编译一时爽,环境火葬场</p>
</blockquote>
<p>因为使用A*算法对于路径的寻找需要更高的效率,很明显,python自身完全不能满足我们的需求,因此使用C++编写python扩展变得非常重要.</p>
<p>不幸的是,我昨天花了整整一天都没有解决这个问题,但是今天却进行的异常顺利,下面我来讲一下在使用C++编写python中的几个坑</p>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我们使用的是<code>pybind</code>的库,具体<code>pybind</code>应当如何使用在这里我就不过多介绍了,下面先贴出来我用做测试的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;pybind11/pybind11.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">testadd</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(pytest2,m)</span><br><span class="line">&#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;testadd&quot;</span>,&amp;testadd,<span class="string">&quot;A function to add&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意将安装好的<code>pybind11</code>中的<code>include</code>文件夹的<code>pybind11</code>文件夹拷贝到工程文件夹中.</p>
<h2 id="使用g-直接编译"><a href="#使用g-直接编译" class="headerlink" title="使用g++直接编译"></a>使用g++直接编译</h2><p>接下来就到了万恶的编译环节,首先,我看见文档里面直接给<code>g++</code>编译的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -O3 -march=native -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` test.cpp -o test `python3-config --extension-suffix`</span><br></pre></td></tr></table></figure>

<p>这个命令看起来很简单,但是存在一个问题,里面依赖<code>python-config</code>命令的输出,但是众所周知,这个命令只有在Linux下才能使用.</p>
<blockquote>
<p>我再一次感觉到了windows开发的险恶</p>
</blockquote>
<h2 id="使用CMake编译"><a href="#使用CMake编译" class="headerlink" title="使用CMake编译"></a>使用CMake编译</h2><p>接下来,我看到网上说<code>cmake</code>可以进行编译,这样看起来挺好,然而暗藏杀机.</p>
<p>因为<code>cmake</code>也需要类似于<code>python-config</code>的环境,然后虽然我安装<code>mingw</code>确实来了一个<code>python-config</code>但是这会导致我编译工具链使用的是MS的产品,但是采用的解释器却是GCC编译的.</p>
<blockquote>
<p>中间省略了因为使用<code>anaconda</code>而不得不一步步教<code>cmake</code>如何找到我的<code>pybind</code>的过程</p>
</blockquote>
<p>然后这就带来一个完全爆炸<code>.pyd</code>文件,这个<code>pyd</code>在<code>mingw</code>里面的python不认,然后到了<code>conda</code>里面的python直接提示我dll丢失.</p>
<blockquote>
<p>你以为我没查Google,直接提示你:<em>“你安装的库可能有误,建议卸载重装”</em></p>
<p>我自己写的库怎么卸载重装</p>
</blockquote>
<p>但是如果我换做<code>mingw</code>编译,则更加刺激,直接python给我闪退了</p>
<blockquote>
<p>我拿<code>windbg</code>查了一下,是内存冲突,但是别的我也不知道了</p>
</blockquote>
<h2 id="使用setup-py编译"><a href="#使用setup-py编译" class="headerlink" title="使用setup.py编译"></a>使用<code>setup.py</code>编译</h2><p>这种方法看起来简单,但是结果和那<code>CMake</code>一样</p>
<p>简而言之,我电脑的状态就是这样:</p>
<ol>
<li>使用windows操作系统</li>
<li>卸载了<code>VisualStudio</code></li>
<li>装了<code>mingw</code></li>
<li>使用<code>anaconda</code>管理python环境</li>
</ol>
<p>直接buff叠满,能做出来才有鬼.</p>
<h2 id="使用cppimport"><a href="#使用cppimport" class="headerlink" title="使用cppimport"></a>使用<code>cppimport</code></h2><p>这是我目前看到的最好的方法来处理这个问题,<a href="https://github.com/tbenthompson/cppimport">源网页</a></p>
<p>使用这个的好处在于反正我编译出来成功了</p>
<p>这个库用法并不复杂,首先是在文件开头需要添加一行注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cppimport</span></span><br></pre></td></tr></table></figure>

<p>然后在文件的末尾需要有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;%</span></span><br><span class="line"><span class="comment">cfg[&#x27;sources&#x27;] = [&#x27;a_star.cpp&#x27;]</span></span><br><span class="line"><span class="comment">cfg[&#x27;extra_compile_args&#x27;] = [&#x27;/O2 /Oi&#x27;]</span></span><br><span class="line"><span class="comment">setup_pybind11(cfg)</span></span><br><span class="line"><span class="comment">%&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这实际上是一段<code>Mako</code>块,这一部分的python代码将会被运行  </p>
<p>其中第一行是由于多文件编译,指定除了这个文件外的另外源文件</p>
<p>第二行则是使用相关的编译选项</p>
<h3 id="cppimport调用"><a href="#cppimport调用" class="headerlink" title="cppimport调用"></a><code>cppimport</code>调用</h3><p>虽然<code>cppimport</code>支持实时调用(每次<code>import</code>)的时候预编译,但是这么做对我们来讲没有必要,我们可以采用<code>cppimport</code>的预编译方式(就是<code>pyd</code>)实现</p>
<p>使用以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m cppimport build pytest.cpp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然理论上没有<code>pytest.cpp</code>也可以自动检测,但是我们不可避免会带有<code>Unicode</code>字符,然后就出错了</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用loguru编写日志文件</title>
    <url>/2023/01/27/misc/pylog/</url>
    <content><![CDATA[<p>在编写程序,尤其是某些运行时间长,中间存在可能错误的程序,往往需要记录日志以便于调试.  </p>
<p>但是日志的编写往往存在大量重复劳动,并且对于我目前的状况来讲可能需要在已有的程序中添加日志代码.  </p>
<p>经过相关资料查阅,我找到了一个内置<code>logging</code>库,其可以较好地实现对于日志的编写.但是查阅了一下相关资料后,发现似乎<code>logging</code>的使用较为复杂,我们往往不需要那么复杂的应用场景,因此我在这里选择另外一个库<code>loguru</code>对日志进行记录</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果使用<code>anaconda</code>,可以用以下命令安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge loguru</span><br></pre></td></tr></table></figure>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>我们可以直接利用封装好的<code>logger</code>对象,直接对不同级别的日志进行输出,例如使用以下代码可以实现不同级别的日志:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;This is debug information&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;This is info information&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;This is warn information&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;This is error information&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以注意到在运行时,其对于不同级别的结果,有着不同的格式化与颜色</p>
<p><img src="/2023/01/27/misc/pylog/image-20230127192915053.png" alt="image-20230127192915053"></p>
<p>接下来,我们可以注意到<code>logger</code>编写日志的一个优势在于其无需设定复杂的如处理器,过滤器等信息</p>
<h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><p>我们往往需要将数据输出到文件,<em>尤其是在使用如<code>xspec</code>这样自己会有大量数据输出的程序</em>(默认是在<code>sys.std_err</code>中输出),可以使用<code>add</code>改变输出位置(<code>add</code>的具体用法之后会讲)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.add(<span class="string">&quot;file_&#123;time&#125;.log&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中<code>&#123;time&#125;</code>会自动替换为当前时间,还有其他的格式化字典如下:  </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Attributes</th>
</tr>
</thead>
<tbody><tr>
<td>elapsed</td>
<td>The time elapsed since the start of the program</td>
<td>See <a href="https://docs.python.org/3/library/datetime.html#datetime.timedelta"><code>datetime.timedelta</code></a></td>
</tr>
<tr>
<td>exception</td>
<td>The formatted exception if any, <code>None</code> otherwise</td>
<td><code>type</code>, <code>value</code>, <code>traceback</code></td>
</tr>
<tr>
<td>extra</td>
<td>The dict of attributes bound by the user (see <a href="https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.bind"><code>bind()</code></a>)</td>
<td>None</td>
</tr>
<tr>
<td>file</td>
<td>The file where the logging call was made</td>
<td><code>name</code> (default), <code>path</code></td>
</tr>
<tr>
<td>function</td>
<td>The function from which the logging call was made</td>
<td>None</td>
</tr>
<tr>
<td>level</td>
<td>The severity used to log the message</td>
<td><code>name</code> (default), <code>no</code>, <code>icon</code></td>
</tr>
<tr>
<td>line</td>
<td>The line number in the source code</td>
<td>None</td>
</tr>
<tr>
<td>message</td>
<td>The logged message (not yet formatted)</td>
<td>None</td>
</tr>
<tr>
<td>module</td>
<td>The module where the logging call was made</td>
<td>None</td>
</tr>
<tr>
<td>name</td>
<td>The <code>__name__</code> where the logging call was made</td>
<td>None</td>
</tr>
<tr>
<td>process</td>
<td>The process in which the logging call was made</td>
<td><code>name</code>, <code>id</code> (default)</td>
</tr>
<tr>
<td>thread</td>
<td>The thread in which the logging call was made</td>
<td><code>name</code>, <code>id</code> (default)</td>
</tr>
<tr>
<td>time</td>
<td>The aware local time when the logging call was made</td>
<td></td>
</tr>
</tbody></table>
<p>输出到文件还有滚动和压缩等功能,在这里不再过多赘述(目前也用不到)</p>
<blockquote>
<p>关于字符着色:</p>
<p>字符着色的问题是通过调节<code>add</code>中的参数<code>colorize</code>来控制的,其添加后有好处有坏处</p>
<p>好处在于可以使用<code>tail -f</code>等很方便看到数据内容</p>
<p>坏处在于由于字符串着色的机理是通过添加字符串进行的,会对编辑器查看带来不便</p>
<p>因此可以尝试同时记录两个log</p>
</blockquote>
<h2 id="过滤器与格式化"><a href="#过滤器与格式化" class="headerlink" title="过滤器与格式化"></a>过滤器与格式化</h2><p>下面是关于更加复杂的过滤器写法和格式化写法的问题,这里不涉及(可能以后会),可以先看参考资料</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Delgan/loguru">源代码与特性介绍</a></p>
<p><a href="https://loguru.readthedocs.io/en/stable/api/logger.html">类定义</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>向量化与面向对象</title>
    <url>/2023/02/07/python/vectorize/</url>
    <content><![CDATA[<p>在这一篇文章中,我们将讨论两个话题:向量化和面向对象</p>
<p>第一个话题大家应该已经有相关的知识了,但是”可能”还缺乏一个非常清晰的理解;<br>而第二个话题大家可能听说的不多,虽然像”面向对象”这样的话题对于计算机程序设计非常重要,但是这对于我们做科学计算实际上意义有限,但是基本概念又不能不知道</p>
<span id="more"></span>

<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>这一部分主要是关于<code>numpy</code>中<code>ndarray</code>类的</p>
<blockquote>
<p>虽然我的意思是,关于科学计算,真正需要”掌握”的就是<code>ndarray</code>,其他查一下就能现学现用  </p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在<code>numpy</code>中存在这样的操作,将一个数组与另一个数组(或者标量)进行数学运算时,这些数据会被”广播”进行计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b=<span class="number">1</span></span><br><span class="line">a+b</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 3, 4, 5, 6])
</code></pre>
<p>这些计算更多的可以被看做是对于线性代数的一种扩展,多了一种标量加矢量的运算</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>在<code>numpy</code>中是使用C编写的代码,使用了大量的底层运算,其速度远快于构造python中的循环<br>下面就是一个例子来比较两种代码的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_list</span>():</span><br><span class="line">    x=[<span class="number">1</span>]*<span class="number">1000</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        x[i]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use_ndarray</span>():</span><br><span class="line">    x=np.ones(<span class="number">1000</span>)</span><br><span class="line">    x+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计时</span></span><br><span class="line">%timeit use_list()</span><br><span class="line">%timeit use_ndarray()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>67.7 µs ± 9.24 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
3.97 µs ± 193 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>可以非常容易地看出,使用python列表(前者)的效率会远低于使用<code>ndarray</code>(后者)</p>
<h3 id="shape"><a href="#shape" class="headerlink" title="shape"></a><code>shape</code></h3><p>前文提到,向量化的操作与线性代数有千丝万缕的联系.因此,数组的形状就显得非常重要<br>可以直接访问<code>shape</code>属性获得关于数组的形状信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b=np.array([<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape of a is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape of b is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(b.shape))</span><br></pre></td></tr></table></figure>

<pre><code>The shape of a is (2, 3)
The shape of b is (2,)
</code></pre>
<p>而对于二维这种最为常见的情况来说,<code>a[i,j]</code>是先行后列.</p>
<p>而为了实现计算,需要修改数组的形状,例如将<code>b</code>变为一个行向量可以进行矩阵乘法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=b.reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">np.dot(c,a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[39, 54, 69]])
</code></pre>
<p>这种<code>reshape</code>在处理解决实际问题的时候往往非常有用,在我个人的理解中,如果需要批量的计算,往往会把数组变到二维便于进行计算(更高的维度也不是不可以,但是会比较复杂).然后等到计算完成之后再变到自己所需的<code>shape</code><br>同时,<code>reshape</code>也支持使用<code>-1</code>缺省</p>
<blockquote>
<p>这里有一个需要注意的地方,<code>reshape</code>返回的是数组的浅拷贝,因此如果对reshape之后的元素进行修改,那么会影响到原来的数组.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="number">0</span>,<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>




<pre><code>array([7, 1])
</code></pre>
<h3 id="axis"><a href="#axis" class="headerlink" title="axis"></a><code>axis</code></h3><p>如果执行一些操作(例如说<code>sum</code>),其就会向你提供一个可选参数<code>axis</code>,是指这个运算沿着哪个轴</p>
<p>下面就展示一下沿着不同的轴进行操作的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Along axis 0 is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a.<span class="built_in">sum</span>(axis=<span class="number">0</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Along axis 1 is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a.<span class="built_in">sum</span>(axis=<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<pre><code>Along axis 0 is [5 7 9]
Along axis 1 is [ 6 15]
</code></pre>
<p>可以将<code>axis</code>的效果简单地理解为如果沿着某个轴进行一些聚合操作(例如求和),那么执行操作之后数组的<code>shape</code>的这个元素就会变为1</p>
<h3 id="布尔数组与布尔索引"><a href="#布尔数组与布尔索引" class="headerlink" title="布尔数组与布尔索引"></a>布尔数组与布尔索引</h3><p>在向量化中,还有一个重要的工具,记为布尔数组<br>我们可以对一个数组进行比较运算,得到布尔数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[False, False, False],
       [False,  True,  True]])
</code></pre>
<p>而这样的布尔数组一方面可以用作输入实现分类,另外一方面也可以作为索引来提取满足条件的元素<br>例如下面的代码展示如何将<code>a</code>中大于4的元素提取出来,以及按照<code>(-1,1)</code>分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[a&gt;<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.where(a&gt;<span class="number">4</span>,<span class="number">1</span>,-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[5 6]
[[-1 -1 -1]
 [-1  1  1]]
</code></pre>
<p>使用这样的功能,我们可以实现一些原本看起来难以实现向量化的运算<br>例如下面一段代码模拟了抛针法估算$\pi$的过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_pi</span>(<span class="params">sample_number:<span class="built_in">int</span>,ran_num:<span class="built_in">int</span></span>):</span><br><span class="line">    ran=np.random.RandomState(ran_num)</span><br><span class="line">    x=ran.uniform(-<span class="number">0.5</span>,<span class="number">0.5</span>,sample_number)<span class="comment">#生成中心坐标</span></span><br><span class="line">    theta=ran.uniform(<span class="number">0</span>,<span class="number">2</span>*np.pi,sample_number)<span class="comment">#生成角度</span></span><br><span class="line">    r1=x-<span class="number">0.5</span>*np.cos(theta)</span><br><span class="line">    r2=x+<span class="number">0.5</span>*np.cos(theta)</span><br><span class="line">    k=r1*r2</span><br><span class="line">    num=np.<span class="built_in">sum</span>(np.where(k&lt;=<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*sample_number/num</span><br><span class="line"></span><br><span class="line">calc_pi(<span class="number">1000000</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>3.139934312574181
</code></pre>
<blockquote>
<p>实际上,关于向量化,大家还有很多需要学,我这里展示的仅为冰山一角</p>
</blockquote>
<h2 id="“流畅地编程”-面向对象和一些特性"><a href="#“流畅地编程”-面向对象和一些特性" class="headerlink" title="“流畅地编程”:面向对象和一些特性"></a>“流畅地编程”:面向对象和一些特性</h2><p>我一开始并不打算讲面向对象,一方面在于面向对象本质太过复杂,完全可以涉及到另外一个完整而复杂的学科,而另外一方面则更为重要,在于面向对象对于我们这种”非专业”的程序设计者尤其如果你仅仅希望将python看成一个分析数据的脚本的人,面向对象是一个完全不需要涉及的内容;并且如果滥用里面的一些东西,<strong>无疑会造成很大灾难</strong>(不信的可以看看我Github上的几个屎山仓库)</p>
<p>不过稍微学习一下相关内容也会有用,至少你不使用,但是在别人使用的时候你要看懂发生了什么</p>
<p>另外,我将介绍一些python中的特性,这些特性和前面说的向量化一样,往往会被人忽视(因为没有它也能工作)</p>
<blockquote>
<p>但是请不要过于依赖一些偏门特性,正如python作者Tim Peters所说</p>
<blockquote>
<p>“Here’s the plan: When someone uses a feature you don’t understand, simply shoot them. This is easier than learning something new, and before too long the only living coders will be writing in an easily understood, tiny subset of Python 0.9.6 <wink>.”</p>
</blockquote>
</blockquote>
<h3 id="面向对象-它是什么-会给我们带来什么影响"><a href="#面向对象-它是什么-会给我们带来什么影响" class="headerlink" title="面向对象:它是什么,会给我们带来什么影响"></a>面向对象:它是什么,会给我们带来什么影响</h3><blockquote>
<p>Object-oriented programming (OOP) is a computer programming model that organizes software design around data, or objects, rather than functions and logic. An object can be defined as a data field that has unique attributes and behavior. </p>
</blockquote>
<p>上面这段话摘自<a href="https://www.techtarget.com/searchapparchitecture/definition/object-oriented-programming-OOP">这个网页</a>,其说明了OOP的一个基本特点:如何处理事物是次要的,主要是将事物抽象成一个个对象<br>这样的抽象有好处也有坏处<br>首先讲好处,其可以将更多东西抽象成一个,不仅仅是函数那样输入输出,这可以极大提升代码规整度并且在实现或改进新功能时尽可能不影响到用户(这里的用户是更加高层的调用)的调用,将各个地方实现”脱耦”<br>但是相应的存在缺陷,一个大问题就在于面向对象编程基本的可读性会变差(对于小程序),同时可能导致开销增大<br>实际上python自己就是非常依赖对象进行工作的,关于什么是属性,什么是方法,大家可以去参考<a href="https://www.runoob.com/python/python-object.html">这里</a><br>至于为何我不讲,一方面是因为我懒,另外一方面这个东西我将可能会误人子弟.大家看到类的基本特征就行了,像继承多态,装饰器等东西大家想看就看,不想看也不勉强.  </p>
<h2 id="python中的一些技巧"><a href="#python中的一些技巧" class="headerlink" title="python中的一些技巧"></a>python中的一些技巧</h2><p>这里面收录了一些我看到的优雅的代码,就将其收集下来,以供参考  </p>
<h3 id="使用迭代器生成形状"><a href="#使用迭代器生成形状" class="headerlink" title="使用迭代器生成形状"></a>使用迭代器生成形状</h3><p>在我们进行科学绘图的时候,总是会遇见一些让你眼前一黑的情况,比如要对于未知个特征的数据进行绘图,不同绘图的线形又要单独指定.这样的场景并不少见,但每一次碰到都会让人非常痛苦,下面是我看到的一个有意思的做法,可以用来参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_gen</span>():  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;line_gen 产生不超过九个线形</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields</span></span><br><span class="line"><span class="string">    ------</span></span><br><span class="line"><span class="string">    str</span></span><br><span class="line"><span class="string">        产生得到线形的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line">    line_shapes=[<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>]</span><br><span class="line">    line_cols=[<span class="string">&quot;r&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> line_shape <span class="keyword">in</span> line_shapes:</span><br><span class="line">        <span class="keyword">for</span> line_col <span class="keyword">in</span> line_cols:</span><br><span class="line">            <span class="keyword">yield</span> line_col+line_shape</span><br><span class="line">            </span><br><span class="line">indata=np.linspace(<span class="number">1</span>,<span class="number">5</span>,<span class="number">100</span>)</span><br><span class="line">pdatas=[indata**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">ls=line_gen()<span class="comment">#创建一个生成器实例</span></span><br><span class="line"><span class="keyword">for</span> pdata <span class="keyword">in</span> pdatas:</span><br><span class="line">    plt.plot(indata,pdata,<span class="built_in">next</span>(ls))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/2023/02/07/python/vectorize/26_0.png" alt="png"><br>​    </p>
<p>可以看到,迭代器完美地处理了这样的情况.<br>其原理可以大概这样解释:</p>
<ol>
<li>解释器注意到函数中的<code>yield</code>关键字,因此在调用<code>line_gen()</code>时不会运行这个函数,而是返回一个生成器对象(<code>generator object</code>)</li>
<li>之后每次调用<code>next</code>中以这个生成器对象作为参数,那么函数就会运行到下一个<code>yield</code>处并返回(需要注意到的是,再一次用同一生成器调用<code>next</code>的时候,函数保留了原来的”记忆”)</li>
<li>如果在<code>next</code>时函数以及执行完了,那么就会发生<code>StopIteration</code>错误  <blockquote>
<p><code>yield</code>的作用与其说”返回”,不如说是”产生”,因为函数并没有终止</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>光学期末复习</title>
    <url>/2023/02/21/physicsnote/light/</url>
    <content><![CDATA[<p>以下内容主要包含光学期末复习相关笔记</p>
<span id="more"></span>

<h2 id="内容整理"><a href="#内容整理" class="headerlink" title="内容整理"></a>内容整理</h2><h3 id="光的干涉"><a href="#光的干涉" class="headerlink" title="光的干涉"></a>光的干涉</h3><h5 id="光干涉的几个要求"><a href="#光干涉的几个要求" class="headerlink" title="光干涉的几个要求"></a>光干涉的几个要求</h5><p>频率相同,振动方向相同(可能这里指的是分量),相位稳定</p>
<h5 id="干涉光强计算"><a href="#干涉光强计算" class="headerlink" title="干涉光强计算"></a>干涉光强计算</h5><p>$I&#x3D;\frac{1}{2}EE^*$,对于相干光,是$E$的叠加;对于非相干光,是$I$的叠加</p>
<h4 id="频谱宽度的计算与注意事项"><a href="#频谱宽度的计算与注意事项" class="headerlink" title="频谱宽度的计算与注意事项"></a>频谱宽度的计算与注意事项</h4><p>$\Delta x\Delta k\approx 2\pi$其中$\Delta x$为发光长度</p>
<p>或者可以用</p>
<p>$\Delta t\Delta \nu&#x3D;1$,其中$\Delta t$为发光时间</p>
<h5 id="相干光的两种产生方式"><a href="#相干光的两种产生方式" class="headerlink" title="相干光的两种产生方式"></a>相干光的两种产生方式</h5><p>分波前与分振幅</p>
<h4 id="典型分波前干涉-杨氏双缝干涉"><a href="#典型分波前干涉-杨氏双缝干涉" class="headerlink" title="典型分波前干涉:杨氏双缝干涉"></a>典型分波前干涉:杨氏双缝干涉</h4><p>$$I&#x3D;I_0\cos^2\left(\pi\frac{\Delta xl}{L\lambda}\right)$$</p>
<p>需要注意,这里假定缝非常小,否则还要考虑<strong>光的衍射</strong></p>
<h5 id="杨氏双缝干涉中单缝作用"><a href="#杨氏双缝干涉中单缝作用" class="headerlink" title="杨氏双缝干涉中单缝作用"></a>杨氏双缝干涉中单缝作用</h5><p>用来产生相干光</p>
<p>随着与中心距离的逐渐变大,条纹会逐渐变暗,一般有两个原因:</p>
<ol>
<li>干涉距离变大,逐渐变得不相干</li>
<li>由于后面会讨论的衍射因子的作用</li>
</ol>
<p>如果非单色光,那么会出现分光的现象</p>
<h4 id="分波面干涉-劈尖干涉与牛顿环"><a href="#分波面干涉-劈尖干涉与牛顿环" class="headerlink" title="分波面干涉:劈尖干涉与牛顿环"></a>分波面干涉:劈尖干涉与牛顿环</h4><p>需要注意,在分拨面干涉中的光路<strong>并不是任意的</strong>,需要注意<strong>成像问题</strong></p>
<p>对于劈尖,需要关心介质的折射率关系以分析半波损失</p>
<p>关于牛顿环,可以直接计算透镜的曲率半径$R$为</p>
<p>$$R&#x3D;\frac{r^2_{m+i}-r^2_m}{i\lambda}$$</p>
<h5 id="等厚干涉与等倾干涉的综合区别"><a href="#等厚干涉与等倾干涉的综合区别" class="headerlink" title="等厚干涉与等倾干涉的综合区别"></a>等厚干涉与等倾干涉的综合区别</h5><p>等厚干涉的光程差来源于不同位置透明介质厚度不同,等倾干涉光程差来源于不同位置光角度不同,经过厚度不同</p>
<h4 id="迈克耳孙干涉"><a href="#迈克耳孙干涉" class="headerlink" title="迈克耳孙干涉"></a>迈克耳孙干涉</h4><p>需要注意到的问题:</p>
<ol>
<li>在第一个反射镜处,是否有镀膜会<strong>对干涉的半波损失带来巨大影响</strong></li>
<li>如果没有补偿镜,需要使用<strong>单色性更好的光</strong></li>
</ol>
<h4 id="多光束干涉"><a href="#多光束干涉" class="headerlink" title="多光束干涉"></a>多光束干涉</h4><p>相当于在薄膜干涉的基础上多考虑反射和折射</p>
<p>可以得到总的反射相对光强和总的投射相对光强</p>
<p>$$\frac{I_r}{I_i}&#x3D;\frac{F\sin^2(\frac{\sigma}{2})}{1+F\sin^2(\frac{\sigma}{2})}$$</p>
<p>$$\frac{I_t}{I_i}&#x3D;\frac{1}{1+F\sin^2(\frac{\sigma}{2})}$$</p>
<p>此处$\sigma&#x3D;\frac{4\pi n h \cos\theta_t}{\lambda}$为每一级条纹之间的相位差($\theta_t$为介质中投射角),$F$为锐度系数$F&#x3D;\left(\frac{2r}{1-r^2}\right)^2$</p>
<p>同时,我们可以定义从光强最大到光强为$\frac{1}{2}$的距离为<strong>半峰宽</strong>$\delta_{\frac{1}{2}}$,可以有</p>
<p>$$\delta\theta\frac{4\pi nh\sin\theta_t}{\lambda}&#x3D;\delta_{1}{2}&#x3D;2\arcsin(\frac{1}{\sqrt{F}})\approx\frac{2}{\sqrt{F}}$$</p>
<p>从这里,我们可以求解出来其角分辨能力</p>
<h3 id="衍射理论"><a href="#衍射理论" class="headerlink" title="衍射理论"></a>衍射理论</h3><h4 id="近场与远场"><a href="#近场与远场" class="headerlink" title="近场与远场"></a>近场与远场</h4><p>远场:满足射入的光近似于平行光(或者用透镜实现无穷远成像)<em>菲涅尔衍射</em></p>
<p>近场:存在角度<em>夫琅和费衍射</em></p>
<h4 id="单个狭缝的夫琅和费衍射"><a href="#单个狭缝的夫琅和费衍射" class="headerlink" title="单个狭缝的夫琅和费衍射"></a>单个狭缝的夫琅和费衍射</h4><h5 id="分析手段"><a href="#分析手段" class="headerlink" title="分析手段"></a>分析手段</h5><ol>
<li>可以使用矢量图法,每一小部分光源相当于构成了一个小矢量,而这些矢量首尾叠加构成圆弧,合成光就是圆弧首尾相连</li>
<li>可以使用半波带法分析明暗条纹</li>
<li>直接积分</li>
</ol>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>记住光强为</p>
<p>$$I&#x3D;\frac{\sin^2\beta}{\beta^2}$$</p>
<p>其中$\beta&#x3D;\frac{\pi b}{\lambda}\sin\theta$(可以看作以某一角度射出时极限光程差相位差的一半)</p>
<h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><p>如果入射光存在角度,那么<strong>需要叠加计算</strong></p>
<p>$$\beta&#x3D;\frac{\pi b}{\lambda}(\sin\theta+\sin\alpha)$$</p>
<p>其中$\alpha$新入射效果</p>
<h5 id="矩形孔"><a href="#矩形孔" class="headerlink" title="矩形孔"></a>矩形孔</h5><p>可以看作两个方向的狭缝,最后结果就是两个方向衍射相乘</p>
<h4 id="圆孔夫琅和费衍射"><a href="#圆孔夫琅和费衍射" class="headerlink" title="圆孔夫琅和费衍射"></a>圆孔夫琅和费衍射</h4><p>我们无法获得圆孔夫琅和费衍射的解析解,其可以被写作$U(\theta)&#x3D;\frac{2kJ_1(x)}{x}$</p>
<p>而$\frac{2\pi}{\lambda}a\sin\theta$,$a$为圆孔半径</p>
<p>因此,可以得到第一个暗环的半角宽为$\delta\theta&#x3D;0.61\frac{\lambda}{a}&#x3D;1.22\frac{\lambda}{D}$</p>
<p>这也是<strong>最小角分辨率</strong>,而对于研究线分辨率$d&#x3D;\Delta\theta f$</p>
<h4 id="多缝衍射"><a href="#多缝衍射" class="headerlink" title="多缝衍射"></a>多缝衍射</h4><p>对于多峰衍射,可以考虑干涉因子和衍射因子相乘</p>
<p>其中干涉因子与一个完整的遮挡和缝的<strong>总宽度</strong>$d$相关</p>
<p>$$I&#x3D;I_0\frac{\sin^2N\gamma}{\sin^2\gamma}\frac{\sin^2\beta}{\beta^2}$$</p>
<p>其中干涉的强度极大值位置为$d\sin\theta&#x3D;\pm m\lambda$,极小值$\sin N\gamma&#x3D;0$且$\sin\gamma\neq 0$</p>
<blockquote>
<p>注意,如果$d$和$b$呈现简单整数比,那么会存在缺级</p>
</blockquote>
<h5 id="角色散率"><a href="#角色散率" class="headerlink" title="角色散率"></a>角色散率</h5><p>我们可以定义角色散率$D&#x3D;\frac{\delta\theta}{\delta\lambda}$</p>
<p>可以得到:级次越大,角色散率越大,刻线越密,色散越大</p>
<p>而使用<strong>瑞利判据</strong>,可以得到色分辨本领$R&#x3D;\frac{\lambda}{\Delta\lambda}&#x3D;mN$</p>
<p>$N$为总刻线数</p>
<h5 id="闪耀光栅"><a href="#闪耀光栅" class="headerlink" title="闪耀光栅"></a>闪耀光栅</h5><p>我们可以让反射面倾斜,这样可以使得衍射极大发生偏离,使得干涉级数大的部分<strong>比较亮</strong></p>
<h4 id="菲涅尔衍射"><a href="#菲涅尔衍射" class="headerlink" title="菲涅尔衍射"></a>菲涅尔衍射</h4><p>分析:可以使用半波带法,如果有奇数个半波带,那么光强较强,偶数个半波带,光强较弱</p>
<h5 id="三种不同的情况"><a href="#三种不同的情况" class="headerlink" title="三种不同的情况"></a>三种不同的情况</h5><ol>
<li>光阑,随着$r$变大,会从一个亮点中间产生黑点再生长….</li>
<li>自由传播:总光场一半</li>
<li>Posson亮斑:中心点总是亮的</li>
</ol>
<h5 id="光阑的半波带个数"><a href="#光阑的半波带个数" class="headerlink" title="光阑的半波带个数"></a>光阑的半波带个数</h5><p>在光阑半径为$R$一点与光阑中心的那一点的光程差</p>
<p>$$\Delta S&#x3D;\frac{R(r_0+\rho)}{\rho r_0\lambda}$$</p>
<p>$\rho$为波面半径,$r_0$为波面到观测点的最短距离</p>
<blockquote>
<p>可以利用半波带性质做透镜,满足</p>
<p>$$(\frac{1}{\rho}+\frac{1}{r})&#x3D;\frac{m\lambda}{R^2_m}$$</p>
</blockquote>
<h3 id="几何光学"><a href="#几何光学" class="headerlink" title="几何光学"></a>几何光学</h3><h4 id="几何光学成像"><a href="#几何光学成像" class="headerlink" title="几何光学成像"></a>几何光学成像</h4><p>物空间-&gt;光学系统-&gt;像空间</p>
<p><img src="/2023/02/21/physicsnote/light/1.png" alt="png"></p>
<h4 id="理想透镜"><a href="#理想透镜" class="headerlink" title="理想透镜"></a>理想透镜</h4><p>原理<strong>光程相等,构成波阵面</strong>,一般理想透镜的透镜方程</p>
<p><img src="/2023/02/21/physicsnote/light/2.png"></p>
<p>对于双曲面镜,有AD为双曲面准线,O为双曲线一个焦点,如果$e&#x3D;\frac{n}{n_0}$</p>
<p>那么可以知道OB光程加上BC光程相当于在玻璃介质中AC,因此<strong>双曲面镜可以点源到平行光</strong></p>
<p><img src="/2023/02/21/physicsnote/light/3.png" alt="3"></p>
<p>相似的,椭圆面镜也可以使平行光汇聚</p>
<blockquote>
<p>如何判断应当使用<strong>双曲面镜</strong>还是使用<strong>椭圆面镜</strong>的手段</p>
<p>在<strong>双曲面镜中</strong>,平行光出现在<strong>折射率大的部分</strong></p>
<p>在<strong>椭圆面镜中</strong>,平行光出现在<strong>折射率小的部分</strong></p>
</blockquote>
<p>可以使用双曲面+球面(光线过球心,不会在表面折射)制作理想双曲面镜</p>
<h4 id="球面透镜"><a href="#球面透镜" class="headerlink" title="球面透镜"></a>球面透镜</h4><p>对于球面透镜,我们往往需要进行小角度近似,可以得到</p>
<p>$$\frac{n_1}{s_o}+\frac{n_2}{s_i}&#x3D;\frac{n_2-n_1}{R}$$</p>
<h4 id="实虚关系"><a href="#实虚关系" class="headerlink" title="实虚关系"></a>实虚关系</h4><h4 id="成像符号约定"><a href="#成像符号约定" class="headerlink" title="成像符号约定"></a>成像符号约定</h4><table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>类型</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>实物$s_o$&gt;0</td>
<td>+</td>
<td>虚物$s_o$&lt;0</td>
<td>-</td>
</tr>
<tr>
<td>实像$s_i&gt;0$</td>
<td>+</td>
<td>虚像$s_i&lt;0$</td>
<td>-</td>
</tr>
<tr>
<td>球心在球面右侧</td>
<td>+</td>
<td>球心在球面左侧</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="薄透镜"><a href="#薄透镜" class="headerlink" title="薄透镜"></a>薄透镜</h4><p>设外界折射率为$n_m$,透镜折射率为$n_l$,则有透镜成像公式</p>
<p>$$\frac{1}{s_o}+\frac{1}{s_i}&#x3D;\frac{1}{f}&#x3D;\frac{n_l-n_m}{n_m}\left(\frac{1}{R_1}-\frac{1}{R_2}\right)$$</p>
<p>需要注意,焦距的<strong>决定式</strong>很重要,需要专门记忆(注意分子上的$n_l-n_m$)</p>
<p>对于$R_1,R_2$的符号,参考上表</p>
<h4 id="作图法求解光学问题"><a href="#作图法求解光学问题" class="headerlink" title="作图法求解光学问题"></a>作图法求解光学问题</h4><p>对于单次成像的问题,往往使用三条光线</p>
<ol>
<li>过光心</li>
<li>过第一个焦点</li>
<li>平行于光轴</li>
</ol>
<p>但是有时会要有多个透镜多次成像,此时可以先绘制出一个透镜的成像,然后做出从该像过第二个透镜光心的光线</p>
<p><img src="/2023/02/21/physicsnote/light/4.png"></p>
<p>例如此处红色光线就是透镜1所成的像(在实际中不会被看到),转换成蓝色线所成的两次叠加成像.</p>
<h4 id="光阑"><a href="#光阑" class="headerlink" title="光阑"></a>光阑</h4><p>入射光瞳:<strong>从物的位置</strong>看到的孔的像</p>
<p>出射光瞳:<strong>从像的位置</strong>看到的孔的像</p>
<h4 id="曲面镜"><a href="#曲面镜" class="headerlink" title="曲面镜"></a>曲面镜</h4><ol>
<li><p>抛物面镜:将平行光汇聚在焦点(有时常常会用离轴抛物面镜)</p>
</li>
<li><p>共轭点成像:对于椭圆面镜或双曲面镜,一个焦点和另一个焦点</p>
</li>
<li><p>球面镜:可以类比于透镜成像,但是<strong>有关符号,需要注意</strong></p>
<p>球面镜的等效焦距为$-\frac{R}{2}$,但是此时像距的符号与位置和实虚关系是<strong>反的</strong>,同时,对于凹面镜成像,$R$是负的,因此$f$是正的,从而有可能成实像.</p>
</li>
</ol>
<h4 id="棱镜"><a href="#棱镜" class="headerlink" title="棱镜"></a>棱镜</h4><p>偏向角$\delta&#x3D;\theta_{i1}+\theta_{t2}-\alpha$</p>
<p><img src="/2023/02/21/physicsnote/light/5.png"></p>
<p>关于$\delta$,满足有</p>
<p>$$\delta&#x3D;\theta_{i1}+\arcsin (\sin\alpha(n^2-\sin^2\theta_{i1})^\frac{1}{2}-\sin\theta_{i1}\cos\alpha)-\alpha$$</p>
<p>需要注意的是,当**$\theta_{i1}&#x3D;\theta_{t2}$时,有偏向角最小**</p>
<p>如果要使用棱镜做光谱,需要使用<strong>透镜制造平行光</strong></p>
<h4 id="人眼"><a href="#人眼" class="headerlink" title="人眼"></a>人眼</h4><p>不考虑任何病变,<strong>人眼最为理想的成像状态是平行光入射</strong></p>
<blockquote>
<p>这个平行光入射在设计制造光学仪器的过程中非常重要</p>
</blockquote>
<p>眼镜可以被看作<strong>紧贴于眼睛的一个透镜</strong>,可以直接焦距合成</p>
<p>$$\frac{1}{f}&#x3D;\frac{1}{f_1}+\frac{1}{f_2}$$</p>
<p>或者是定义<strong>屈光度</strong>为$\mathcal{D}&#x3D;\mathcal{D_1}+\mathcal{D_2}$</p>
<p>一般而言$1D$的屈光度意味着<strong>透镜焦距为1m</strong></p>
<h5 id="眼镜的作用"><a href="#眼镜的作用" class="headerlink" title="眼镜的作用"></a>眼镜的作用</h5><p>近视眼镜将无穷远点投射到近视眼的<strong>远点</strong>上,远视眼镜将正常人的近点投射到远视眼的近点上</p>
<h4 id="色差"><a href="#色差" class="headerlink" title="色差"></a>色差</h4><p>因为一块玻璃对于不同波长的光的折射率存在区别,因此不同波长的光在透镜中会发生<strong>色散</strong></p>
<p>而根据前面提到的<strong>透镜焦距公式</strong></p>
<p>$$\frac{1}{f}&#x3D;\frac{n-n_0}{n_0}(\frac{1}{R_1}-\frac{1}{R_2})$$</p>
<p>我们能够计算出不同颜色光波长的<strong>色差</strong></p>
<p>而<strong>使用一块凹透镜和一块凸透镜可以较好地消除色差</strong></p>
<h3 id="光的偏振"><a href="#光的偏振" class="headerlink" title="光的偏振"></a>光的偏振</h3><p>一般而言,光矢量都可以被分解为$x$,$y$两个分量,对于自然光而言,光的偏振是杂乱无章的</p>
<p>产生偏振光的方法:</p>
<ol>
<li><p>利用二项色性:可以使只有某一个方向的偏振光通过,于其正交的偏振光被吸收</p>
<p>满足马吕斯定律$I&#x3D;I_0\cos^2\alpha$</p>
</li>
<li><p>利用反射:非偏振光在反射后也会成为良好的偏振光</p>
</li>
</ol>
<h4 id="双折射现象"><a href="#双折射现象" class="headerlink" title="双折射现象"></a>双折射现象</h4><p>首先是<strong>光轴</strong>,一般而言,我们讨论的问题中<strong>只有一个光轴</strong>,可以有以下的简单结论</p>
<blockquote>
<p>沿光轴的相对介电常数和垂直于光轴的相对介电常数<strong>不同</strong></p>
</blockquote>
<p>于是,我们就可以分出来<strong>寻常光(o光)<strong>和</strong>非常光(e光)</strong></p>
<p>寻常光<strong>与光轴平行的光,偏振方向垂直于光轴</strong>,因此传播不受到影响</p>
<p>非常光<strong>与光轴垂直的光,偏振方向存在垂直光轴和平行光轴的成分</strong>,因此传播会受到影响</p>
<p><img src="/2023/02/21/physicsnote/light/6-1.png"></p>
<p>如图所示的波阵面图像,可以看到原本光的波矢是<strong>竖直向下</strong>的</p>
<p>需要注意到,即使是e光,其<strong>电位移矢量与波矢</strong>的方向(绿色线)保持不变,但是像<strong>电场强度与坡印廷矢量</strong>的方向(蓝色线)发生偏移</p>
<blockquote>
<p>为什么波矢方向不变,我们仍然认为e光传播方向发生了变化原因在于</p>
<p>我们看到所谓<strong>光线</strong>,是由于光的直线传播,而从光的波动推导到直线传播是通过<strong>计算光的干涉得到相干相长</strong>的结论实现的</p>
<p>而光的干涉则是<strong>光电场相互叠加</strong>的结果,并且$S$传递能量(这只是个人猜想)</p>
</blockquote>
<h4 id="双折射的惠更斯做图"><a href="#双折射的惠更斯做图" class="headerlink" title="双折射的惠更斯做图"></a>双折射的惠更斯做图</h4><p><img src="/2023/02/21/physicsnote/light/7.png"></p>
<p>可以看出,当偏振方向与光轴垂直的波速为$v_o$,对应的折射率为$n_o$</p>
<p>当偏振方向与光轴平行的波速为$v_e$,对应的折射率为$n_e$</p>
<blockquote>
<p>$n_o&lt;n_e$为正晶体</p>
<p>$n_o&gt;n_e$为负晶体</p>
</blockquote>
<p>可以使用这个图像来<strong>确定光的传播</strong></p>
<h4 id="波片的使用"><a href="#波片的使用" class="headerlink" title="波片的使用"></a>波片的使用</h4><p>波片的使用可以让两个方向的偏振光<strong>发生一个相位变化</strong>,导致可能出现干涉</p>
<h4 id="克尔效应与泡克耳斯效应"><a href="#克尔效应与泡克耳斯效应" class="headerlink" title="克尔效应与泡克耳斯效应"></a>克尔效应与泡克耳斯效应</h4><p>透明介质放在电场中会出现双折射现象$n_e-n_o&#x3D;\lambda_0 KE^2$</p>
<p>同时可以利用这一效应做克尔盒对相位进行调节$\Delta\varphi&#x3D;2\pi KlV^2&#x2F;d^2$($l$为盒子的长度)</p>
<p>而泡克耳斯效应的相位差则为$\Delta\varphi&#x3D;2\pi n_0^3r_{63}V&#x2F;\lambda_0$</p>
<h2 id="综合性内容"><a href="#综合性内容" class="headerlink" title="综合性内容"></a>综合性内容</h2><h3 id="“恰好分辨”"><a href="#“恰好分辨”" class="headerlink" title="“恰好分辨”"></a>“恰好分辨”</h3><ol>
<li><p>对于波长存在范围的干涉而言,恰好分辨是<strong>前一级条纹中波长最大和后一级条纹波长最小重合</strong></p>
</li>
<li><p>相似的,在杨氏双缝干涉实验中,如果光源有限宽,可以考虑一个端点到另一个端点的<strong>0级和1级条纹重合</strong></p>
</li>
<li><p>对于多光束干涉而言,恰好分辨是<strong>两个干涉峰恰好错开半峰宽</strong>(这可以认为是一种较为简单的判据)</p>
<blockquote>
<p>对于多光束干涉使用<strong>瑞利判据</strong>,一般认为两光束合成后亮度的<strong>鞍点</strong>亮度为最大辐照亮度的$\frac{8}{\pi^2}$倍,这个时候的推导要更为复杂,但是可以直接记住结论:使用该判据,两个光束的<strong>衍射相位差至少为</strong></p>
<p>$$(\Delta\delta\approx\frac{4.2}{\sqrt{F}})$$</p>
</blockquote>
</li>
<li><p>对于衍射的瑞利判据,恰好分辨是<strong>一个衍射极大恰好落在另一个衍射极小</strong></p>
</li>
</ol>
<h3 id="相矢量图"><a href="#相矢量图" class="headerlink" title="相矢量图"></a>相矢量图</h3><p>这个问题主要来自于多缝衍射</p>
<p>首先,多缝衍射倘使不考虑缺级以及如衍射光强等一系列问题,完全可以看作<strong>多缝干涉</strong>的模型,此时我们可以通过绘制相矢量图来解题</p>
<p>但是这个时候,需要关注到<strong>一个易错点</strong>:相矢量图两个矢量之间的夹角<strong>就是光程差带来的相位差</strong>,但是在式子$\frac{\sin^2(N\alpha)}{\sin^2\alpha}$中$\alpha$的定义确是前者的<strong>一半</strong></p>
<p>同时,我们需要知道<strong>辅极大的位置无法直接求解</strong>,近似在$\sin N\alpha$取极大的位置上</p>
<p>而对于极小的位置,就是$\sin N\alpha&#x3D;0$的位置(这在求解恰好分辨的问题非常重要)</p>
<h4 id="人眼的分辨能力与仪器放大率"><a href="#人眼的分辨能力与仪器放大率" class="headerlink" title="人眼的分辨能力与仪器放大率"></a>人眼的分辨能力与仪器放大率</h4><h4 id="放大率的种类"><a href="#放大率的种类" class="headerlink" title="放大率的种类"></a>放大率的种类</h4><ol>
<li><p>横向放大率$M_T&#x3D;\frac{y_i}{y_o}–\frac{v}{u}$</p>
</li>
<li><p>纵向放大率$M_L&#x3D;\frac{dv}{du}$(这个代表像会拉的多长)</p>
<blockquote>
<p>纵向放大率的选取:对于一般照相机,希望能同时拍摄到近处景物和远处景物,那么此时$M_L$要尽量小</p>
<p>但是对于一些其他的成像设备(例如显微镜),需要让成像的平面性尽量强,那么就要选择大的$M_L$</p>
</blockquote>
</li>
<li><p>角放大倍率$M&#x3D;\frac{\theta’}{\theta}$</p>
<p>其中,$\theta$为人眼在明视距离的条件下看这个物体的张角</p>
</li>
</ol>
<h4 id="放大镜与目镜"><a href="#放大镜与目镜" class="headerlink" title="放大镜与目镜"></a>放大镜与目镜</h4><p>一般而言,放大镜的角放大倍率前面已经说明</p>
<p>但是需要注意到的是,如果物体放在放大镜的<strong>焦平面</strong>上,那么此时放大镜出来的是平行光(最理想状态)</p>
<p>此时的角放大率$M&#x3D;\frac{25cm}{f}$</p>
<h4 id="显微镜与望远镜"><a href="#显微镜与望远镜" class="headerlink" title="显微镜与望远镜"></a>显微镜与望远镜</h4><p>显微镜和望远镜可以看做一个物镜加一个目镜实现,其中最后的放大率为$M&#x3D;M_{To}M’$为物镜的<strong>横向放大率</strong>乘以目镜在该成像条件的<strong>角放大率</strong></p>
<p>而一般而言,从目镜中出来的应当是<strong>平行光</strong></p>
<p>那么此时从显微镜出来的放大率$MP&#x3D;(-\frac{160mm}{f_o})(\frac{254mm}{f_e})$(160mm为标准目镜和物镜焦距距离)</p>
<p>而从望远镜出来的放大率$MP&#x3D;-\frac{f_o}{f_e}$(默认入射光为平行光)</p>
<h4 id="数值孔径-f-数与衍射"><a href="#数值孔径-f-数与衍射" class="headerlink" title="数值孔径,$f$数与衍射"></a>数值孔径,$f$数与衍射</h4><p>数值孔径可以理解为介质折射率乘以收光的半角度正弦$NA&#x3D;n\sin\theta\approx\frac{nD}{2f}$后面一个近似是在$f$很大的时候成立</p>
<p>而在一些相机镜头中,会定义<strong>焦比(f数)</strong>$f&#x2F;#&#x3D;\frac{f}{D}$</p>
<p>这样的定义是用在研究夫琅禾费衍射所产生的光斑,光斑的半径$1.22f\frac{\lambda_n}{D}$</p>
<p>数值孔径越大,其理论分辨极限越大,提高数值孔径有三种方法:</p>
<ol>
<li>增大镜头直径</li>
<li>降低焦距</li>
<li>提高折射率(例如使用油镜)</li>
</ol>
<p>同时,我们也需要注意到,数值孔径会影响<strong>横向放大率</strong></p>
<blockquote>
<p>有时题目会给出数值孔径与瞳孔直径,然后要求<strong>正常放大率</strong>,可以这样考虑</p>
<ol>
<li>从数值孔径可以得到最小分辨长度$s&#x3D;0.61\frac{\lambda}{NA}$</li>
<li>可以使用人眼明视距离得到人眼最小分辨长度$s’&#x3D;1.22\frac{s_0\lambda}{D}$</li>
<li>放大率要相互匹配.即$sM&#x3D;s’$</li>
</ol>
</blockquote>
<h2 id="做题存在问题"><a href="#做题存在问题" class="headerlink" title="做题存在问题"></a>做题存在问题</h2><ol>
<li><p>在每一次做到和干涉衍射相关的题目时,需要<strong>小心的分析半波损失问题</strong></p>
</li>
<li><p>需要去理解半波带法的绘图 </p>
</li>
<li><p>多看闪耀光栅的题目</p>
</li>
<li><p>如果两个发光点相距很远,那么在整个空间中,可以看作总体的$I_1I_2$的空间平均为0,如果两个发光点距离很近(远小于一个波长),<strong>可以看作一个光源,亮度为两倍</strong></p>
</li>
<li><p>波片与旋光性的区分:</p>
<p>波片的讨论往往使用的是分解为两个线偏振光</p>
<p>旋光性的讨论往往使用的是分解为左旋光和右旋光</p>
</li>
<li><p>两个同样厚度,但是摆放方向呈现镜像关系的<strong>会让o光和e光又回到一起</strong></p>
</li>
<li><p>焦深可以认为是成像移动前后多少还能近似看清的一个量度</p>
</li>
<li><p>共轭光线指<strong>物空间和像空间互相对应的点</strong></p>
</li>
<li><p>虽然PPT中没有涉及到关于<em>光阑</em>的问题,但是近似记住:成像系统的入射光瞳就是物镜的直径,出射光瞳往往是物镜通过目镜成的</p>
</li>
<li><p>虽然没有说考,但是在使用偏振的时候还是可能会涉及到</p>
</li>
<li><p>关于双折射定律中,倘使光轴在光学平面内,那么可以用以下公式计算折射率(其中$\theta$为法向和光轴方向夹角)</p>
<p>$$n^2(\theta)&#x3D;\frac{n_o^2n_e^2}{n_e^2\cos^2\theta+n_o^2\sin^2\theta}$$</p>
</li>
<li><p>对于偏振器件要加以了解,例如<strong>尼科尔棱镜</strong></p>
</li>
<li><p>在<strong>瑞利斑</strong>相关计算中,对于从直径求角度变化使用的系数<strong>都是1.22</strong>,使用0.61只有在<strong>使用孔半径</strong>或者<strong>使用数值孔径</strong>时才会出现</p>
</li>
<li><p>在考虑多缝衍射模型,<strong>注意零点光强不是1</strong></p>
</li>
<li><p>关于反射光栅,应当更加仔细去<strong>分析光路</strong>,因为可能有倍数关系</p>
</li>
<li><p>注意观察是要求<strong>艾里斑的半径还是直径</strong></p>
</li>
<li><p>计算薄膜干涉时,<strong>不要忘记折射率</strong></p>
</li>
<li><p>在做几何光学题目时,<strong>记得符号</strong></p>
</li>
<li><p>放大率的符号<strong>包含了正倒关系</strong></p>
</li>
<li><p>注意如果有反射的问题<strong>小心光程是否需要乘2</strong></p>
</li>
<li><p>注意:**半峰宽$\gamma$是两倍的$\delta_{\frac{1}{2}}$</p>
</li>
</ol>
<h1 id="看到要立刻想起来的公式"><a href="#看到要立刻想起来的公式" class="headerlink" title="看到要立刻想起来的公式"></a>看到要立刻想起来的公式</h1><ol>
<li><p>$k,E,B$依次构成右手坐标</p>
</li>
<li><p>玻印亭矢量定义$S&#x3D;\frac{1}{\mu_0}E\times B$</p>
</li>
<li><p>偏振光的反射与折射强度</p>
<p>对于$E$<strong>平行</strong>于光线所在平面的例子</p>
<p>$$r&#x3D;\frac{n_t\cos\theta_i-n_i\cos\theta_t}{n_i\cos\theta_t+n_t\cos\theta_i}$$</p>
<p>$$t&#x3D;\frac{2n_i\cos\theta_i}{n_i\cos\theta_t+n_t\cos\theta_i}$$</p>
<p>对于$E$<strong>垂直</strong>于光线所在平面的例子</p>
<p>$$r&#x3D;\frac{n_i\cos\theta_t-n_t\cos\theta_t}{n_i\cos\theta_i+n_t\cos\theta_t}$$</p>
<p>$$t&#x3D;\frac{2n_i\cos\theta_i}{n_i\cos\theta_i+n_t\cos\theta_t}$$</p>
<p>(从中可以得到布儒斯特角)</p>
</li>
<li><p>频谱宽度计算$\Delta t\Delta v&#x3D;1$</p>
</li>
<li><p>多光线干涉</p>
<p>相位差$\sigma&#x3D;\frac{4\pi nh\cos\theta_i}{\lambda}$</p>
<p>锐度系数$F&#x3D;(\frac{2r}{1-r^2})^2$</p>
<p>从最大光强到光强一半的距离为半峰宽$\delta_{\frac{1}{2}}&#x3D;2\arcsin(\frac{1}{\sqrt{F}})\approx\frac{2}{\sqrt{F}}$</p>
<p>(判断两个条纹是否可以分辨就是看<strong>两个条纹间距恰为一个半峰宽</strong>)</p>
</li>
<li><p>偏振仪器:</p>
<p>克尔盒:$\Delta\varphi&#x3D;2\pi KlV^2&#x2F;d^2$</p>
<p>跑科尔斯效应$\Delta\varphi&#x3D;2\pi n_0^3r_{63}V&#x2F;\lambda_0$</p>
</li>
<li><p>几何光学:</p>
<p>透镜焦距公式$\frac{1}{f}&#x3D;\frac{n-n_0}{n_0}(\frac{1}{R_1}-\frac{1}{R_2})$</p>
<p>显微镜角放大率$MP&#x3D;(-\frac{160mm}{f_o})(\frac{254mm}{f_e})$</p>
<p>数值孔径$NA&#x3D;n\sin\theta$</p>
</li>
<li><p>在计算衍射与多光束干涉,要记得<strong>光程差除以二</strong>再代入式中</p>
<p>瑞利斑的半径为$1.22f\frac{\lambda_n}{D}$</p>
<p>光阑半径R处一点到中心光程差(用于计算菲涅尔衍射)$\Delta S&#x3D;\frac{R(r_0+\rho)}{\rho r_0\lambda}$</p>
</li>
<li><p>尼科尔棱镜e光穿透,o光保留(依靠折射率不同出现双折射)</p>
</li>
<li><p>格兰-汤普森棱镜不依靠双折射</p>
</li>
<li><p>罗尚棱镜依靠光轴方向旋转分光(这些棱镜大多使用负晶体)</p>
</li>
<li><p>角色散率$D&#x3D;\frac{\delta \theta}{\delta\lambda}$</p>
</li>
<li><p>基尔霍夫衍射$$U(P)&#x3D;K\int U_0(Q)\frac{1}{2}(1+\cos\theta)\frac{e^{ikr}}{r}d\Sigma$$</p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>物理学</tag>
      </tags>
  </entry>
  <entry>
    <title>复数与复变函数</title>
    <url>/2023/02/20/physicsnote/mathematicsforphysics/math-physics/</url>
    <content><![CDATA[<p>以下内容主要包含复变函数的相关笔记(基本定义到微分和积分)</p>
<span id="more"></span>

<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><h3 id="基本定义-直角坐标定义"><a href="#基本定义-直角坐标定义" class="headerlink" title="基本定义(直角坐标定义)"></a>基本定义(直角坐标定义)</h3><p>对于一个复数$z&#x3D;x+iy$,其实部为$\Re[z]&#x3D;x$,其虚部为$\Im[z]&#x3D;y$</p>
<h3 id="极坐标定义"><a href="#极坐标定义" class="headerlink" title="极坐标定义"></a>极坐标定义</h3><p>由于前面的定义,我们可以看到一个复数可以对应于在坐标上的一个点(或者是一个矢量),那么既然有一个直角坐标定义,那么肯定会有一个极坐标定义</p>
<p>$z&#x3D;\rho e^{i\theta}$,其中模长$|z|&#x3D;\rho$,辐角$Arg z&#x3D;\theta+2k\pi$</p>
<blockquote>
<p>这里我们需要注意到,对于一个复数,其辐角<strong>不是唯一的</strong>,一般而言,我们为了方便起见,对于一个复数,我们可以选取$[0,2\pi)$的一个辐角作为其<strong>主辐角</strong></p>
<p>但是我们仍然需要注意到在一些函数中,<strong>辐角的多值性会导致函数的多值性</strong></p>
</blockquote>
<h3 id="两个特殊点"><a href="#两个特殊点" class="headerlink" title="两个特殊点"></a>两个特殊点</h3><p><strong>两个特殊点</strong>:零点与无穷远点</p>
<p>其中可以用一种方式联系起来:假设一个球与复平面相切,可以使用映射用切线实现,此时,<strong>底部的点相当于零点,顶部的点相当于无穷远点</strong></p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>加减运算,可以看作矢量加减法,其中也可以推导出相关的不等式性质</p>
<p>$$|z_1+z_2|\le|z_1|+|z_2|\|z_1-z_2|\ge|z_1|-|z_2|$$</p>
<p>复数的积$z_1z_2&#x3D;(x_1x_2-y_1y_2)+i(x_1y_2+x_2y_1)&#x3D;\rho_1\rho_2e^{i(\varphi_1+\varphi_2)}$</p>
<p>复数的商$\frac{z_1}{z_2}&#x3D;\frac{x_1x_2+y_1y_2}{x_1^2+x_2^2}+i\frac{x_2y_1-x_1y_2}{x_1^2+x_2^2}&#x3D;\frac{\rho_1}{\rho_2}e^{i(\varphi_1-\varphi_2)}$</p>
<blockquote>
<p>可以看到,这里的复数的积和商使用极坐标方法更加方便</p>
</blockquote>
<p>开方$\sqrt[n]{z}&#x3D;\sqrt[n]{\rho}e^{i\frac{\varphi}{n}}$</p>
<blockquote>
<p><strong>注意到</strong>,这里对于一个复数$z$,那么$\frac{2k\pi}{n}(k&lt;n)$,的辐角变化后这仍然是函数的结果,<strong>这就导致了函数的多值性</strong></p>
</blockquote>
<h2 id="复变函数"><a href="#复变函数" class="headerlink" title="复变函数"></a>复变函数</h2><h4 id="对于复变函数定义"><a href="#对于复变函数定义" class="headerlink" title="对于复变函数定义"></a>对于复变函数定义</h4><p>$\omega&#x3D;f(z)$代表着从一个复平面上的点集到另外一个复平面的点集</p>
<p>对复平面上的一个点集$E$中每一个点$z$,按照规则存在一个&#x2F;多个复数值$\omega$与$z$对应,此即为复变函数</p>
<h4 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h4><p>为了方便起见,我们往往会将讨论的范围限制在<strong>区域</strong>上的函数</p>
<p>为了定义<strong>区域</strong>,我们需要定义以下内容:</p>
<ol>
<li>内点:若$z_0$及存在邻域均属于$E$,则为内点</li>
<li>外点:若$z_0$及存在邻域均不属于$E$,则为外点</li>
<li>边界点:若$z_0$及所有领域均存在属于$E$和不属于$E$,则为边界点</li>
</ol>
<p>区域的定义:满足<strong>以下两个条件的点集</strong>,被称作为区域:</p>
<ol>
<li>全部由内点构成</li>
<li>具有连通性</li>
</ol>
<blockquote>
<p>如果是区域加上边界线,那么可以表示为闭区域</p>
</blockquote>
<h4 id="常见的复变函数"><a href="#常见的复变函数" class="headerlink" title="常见的复变函数"></a>常见的复变函数</h4><ol>
<li>$e^z&#x3D;e^x(\cos y+i\sin y)$</li>
<li>$\sin z&#x3D;\frac{1}{2i}(e^{iz}-e^{-iz})$$\sinh z&#x3D;\frac{1}{2}(e^z-e^{-z})$</li>
<li>$\cos z&#x3D;\frac{1}{2i}(e^{iz}+e^{-iz})$$\cosh z&#x3D;\frac{1}{2}(e^z+e^{-z})$</li>
<li>$\ln z&#x3D;ln|z|+iArg z$(注意,不唯一,且有无穷多值)</li>
</ol>
<p>一般而言,一个复变函数可以表示为$f(z)&#x3D;u(x,y)+iv(x,y)$(变为一对二元实变函数)</p>
<h2 id="复变函数求导与解析函数"><a href="#复变函数求导与解析函数" class="headerlink" title="复变函数求导与解析函数"></a>复变函数求导与解析函数</h2><h3 id="复变函数可导的两个条件"><a href="#复变函数可导的两个条件" class="headerlink" title="复变函数可导的两个条件"></a>复变函数可导的两个条件</h3><ol>
<li>$\omega&#x3D;f(z)$为单值函数</li>
<li>极限$$\lim_{\delta z\to 0}\frac{f(z+\delta z)-f(z)}{\delta z}$$存在且与$\delta z\to 0$方式无关</li>
</ol>
<h3 id="复变函数可导的柯西-黎曼条件"><a href="#复变函数可导的柯西-黎曼条件" class="headerlink" title="复变函数可导的柯西-黎曼条件"></a>复变函数可导的柯西-黎曼条件</h3><p>考虑沿实轴逼近和沿虚轴逼近:</p>
<p>沿实轴逼近:</p>
<p>$$\frac{\partial f}{\partial z}&#x3D;\frac{\partial f}{\partial x}\frac{\partial x}{\partial z}&#x3D;\frac{\partial u}{\partial x}+i\frac{\partial v}{\partial x}$$</p>
<p>沿虚轴逼近</p>
<p>$$\frac{\partial f}{\partial z}&#x3D;\frac{\partial f}{\partial y}\frac{\partial y}{\partial z}&#x3D;\frac{\partial v}{\partial y}-i\frac{\partial u}{\partial y}$$</p>
<p>需要保证两者相等,因此有:</p>
<p>$$\frac{\partial u}{\partial x}&#x3D;\frac{\partial v}{\partial y}\\frac{\partial v}{\partial x}&#x3D;-\frac{\partial u}{\partial y}$$</p>
<p>此即为柯西-黎曼条件(C-R条件)</p>
<blockquote>
<p>在推导的过程需要注意虽然假定了沿实轴(虚轴)逼近,但是从$\frac{\partial f}{\partial z}$到$\frac{\partial f}{\partial x}$中间还有要考虑$\frac{\partial z}{\partial x}$</p>
</blockquote>
<h3 id="复变函数可导的充分条件"><a href="#复变函数可导的充分条件" class="headerlink" title="复变函数可导的充分条件"></a>复变函数可导的充分条件</h3><p>在满足C-R条件的基础上,如果同时满足$u,v$的偏导数<strong>连续</strong>,那么必然可导</p>
<h3 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h3><p>若$f_0$在$z_0$<strong>及其邻域$E(z_0)$处处可导</strong>,那么称$f(z)$在$z_0$处是解析的</p>
<p>(如果在区域中处处可导,那么<strong>其处处解析</strong>)</p>
<h4 id="解析函数需要满足的性质"><a href="#解析函数需要满足的性质" class="headerlink" title="解析函数需要满足的性质"></a>解析函数需要满足的性质</h4><p>$f(x,y)&#x3D;u(x,y)+iv(x,y)$</p>
<p>其中$u,v$需要是调和函数,即$\nabla^2u&#x3D;\nabla^2v&#x3D;0$</p>
<p>同时有$\frac{\partial f}{\partial z^*}&#x3D;0$</p>
<blockquote>
<p>这个性质的证明和应用都用到了对所有复数$z&#x3D;x+iy$,都有$x&#x3D;\frac{z+z^*}{2}$,$y&#x3D;\frac{z-z^*}{2}$</p>
<p>因此,解析函数对$z^*$偏导恒等于0意味着解析函数必然可以被写作$u(z)+iv(z)$的形式</p>
</blockquote>
<h2 id="多值函数"><a href="#多值函数" class="headerlink" title="多值函数"></a>多值函数</h2><p>在这里,我们将以一个例子开始,分析多值函数的性质</p>
<p>设$w&#x3D;\sqrt{z}$,可以将$w$的模长和辐角提取出来,我们得到</p>
<p>$$r&#x3D;\sqrt{|z|},\theta&#x3D;\frac{1}{2}Argz&#x3D;\frac{1}{2}argz+n\pi$$</p>
<p>那么我们注意到,$w$的主辐角可以取$\theta_1&#x3D;\frac{1}{2}argz,\theta_2&#x3D;\frac{1}{2}argz+\pi$</p>
<p><strong>这里给出了两个不同的值</strong></p>
<p>可以看作为两个单支</p>
<blockquote>
<p>我们要注意到,这和实函数中的多值函数不同,这里的多值<strong>不独立</strong></p>
</blockquote>
<h3 id="支点"><a href="#支点" class="headerlink" title="支点"></a>支点</h3><p>对于给定多值函数$w&#x3D;f(z)$,$z$绕某点一周,$w$不复原,那么该点为多值函数的<strong>支点</strong></p>
<p>例如,对于前面的那个例子</p>
<p><img src="/2023/02/20/physicsnote/mathematicsforphysics/math-physics/1.png"></p>
<p>可以注意到若$w$沿蓝色线转一圈,那么会跑到另外一支上,但是如果沿着绿色线转一圈,就不会,因此可以说$z&#x3D;0$是函数$\sqrt{z}$的支点</p>
<p>同时,如果绕着该点转$n$圈可以回到原来的函数值,那么称该点为函数的$n-1$阶支点</p>
<blockquote>
<p>比如$z&#x3D;0$就是一阶支点</p>
</blockquote>
<h3 id="黎曼面"><a href="#黎曼面" class="headerlink" title="黎曼面"></a>黎曼面</h3><p>我们从刚才这个例子可以看出总共可能会有两支,但是这种展示方法并不直观</p>
<p>我们可以通过建立两张复平面实现将辐角从$2\pi$到$4\pi$,如图所示,将BC相连,DA相连</p>
<p><img src="/2023/02/20/physicsnote/mathematicsforphysics/math-physics/2.png"></p>
<p>那么前面绕支点转一圈的例子就非常明显了(绿线),其不能像蓝线那样回到原处</p>
]]></content>
      <tags>
        <tag>物理学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理(介绍至离散时间傅里叶变换)</title>
    <url>/2023/07/02/digital_and_FPGA/digital1/</url>
    <content><![CDATA[<h1 id="数字信号处理介绍"><a href="#数字信号处理介绍" class="headerlink" title="数字信号处理介绍"></a>数字信号处理介绍</h1><p>数字信号处理具有非常强的<strong>扩展性</strong>,例如对于频率响应不一致的器件进行补偿<br>而对于一些图象处理领域,可以将图像看作为二维信号.</p>
<h1 id="离散时间系统"><a href="#离散时间系统" class="headerlink" title="离散时间系统"></a>离散时间系统</h1><p>以一个数字滤波器为例包含以下部分:</p>
<ol>
<li>采样器</li>
<li>连续&#x2F;数字信号转换器(C&#x2F;D)</li>
<li>数字滤波</li>
<li>数字&#x2F;连续信号转换器(D&#x2F;C)</li>
<li>滤波器</li>
</ol>
<h2 id="C-x2F-D信号转换器的效果"><a href="#C-x2F-D信号转换器的效果" class="headerlink" title="C&#x2F;D信号转换器的效果"></a>C&#x2F;D信号转换器的效果</h2><p>存在有<strong>倍频变形</strong>,一般可以使用低通滤波器实现,然而,如果信号频谱本来就沿伸的比较大,那么就会出现<strong>混叠</strong>的情况<br>因此数字信号处理时需要小心地处理高频情况<br>因此,数字信号采样率<strong>必须远大于</strong>关心的信号的频率的两倍</p>
<p>相似地,对于数字信号处理的情况,整个数字信号处理的波形会发生变化</p>
<p>而在数字滤波器中,其形状与模拟滤波器相同,但是<strong>具有不同的频率坐标轴</strong></p>
<p>对于数字滤波器可能会发现在采样频率的倍频发生<strong>周期行为</strong></p>
<blockquote>
<p>似乎一定的采样频率可以等效于一个低通滤波器,但是我不清楚怎么搞的</p>
</blockquote>
<h1 id="离散时间信号与系统"><a href="#离散时间信号与系统" class="headerlink" title="离散时间信号与系统"></a>离散时间信号与系统</h1><p>对于我们所关心的离散时间系统,我们主要讨论的是有一列一定长度$n$的信号</p>
<h2 id="一些常用的离散时间信号序列"><a href="#一些常用的离散时间信号序列" class="headerlink" title="一些常用的离散时间信号序列"></a>一些常用的离散时间信号序列</h2><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p><img src="/image.png" alt="单位响应的图象"></p>
<h3 id="单位阶跃"><a href="#单位阶跃" class="headerlink" title="单位阶跃"></a>单位阶跃</h3><p><img src="/image-1.png" alt="单位阶跃响应的图象"></p>
<h3 id="两者之间联系"><a href="#两者之间联系" class="headerlink" title="两者之间联系"></a>两者之间联系</h3><p>实际上单位样本$\delta(n)$可以直接从单位阶跃样本中直接得到<br>$$\delta(n)&#x3D;u(n)-u(n-1)$$</p>
<p>相似地,也可以用求和来实现逆操作<br><img src="/image-2.png" alt="离散时间信号的转换"></p>
<h3 id="其他的一些常见样本"><a href="#其他的一些常见样本" class="headerlink" title="其他的一些常见样本"></a>其他的一些常见样本</h3><p><img src="/image-3.png" alt="其他的一些常见样本"></p>
<blockquote>
<p>需要注意到,一些原本是周期的信号在数字信号采样下不一定是周期信号</p>
</blockquote>
<p>这些信号可以用来描述更加普遍的信号(相当于函数展开)</p>
<h2 id="将一般信号使用特殊信号的转化"><a href="#将一般信号使用特殊信号的转化" class="headerlink" title="将一般信号使用特殊信号的转化"></a>将一般信号使用特殊信号的转化</h2><h3 id="使用单位脉冲转化"><a href="#使用单位脉冲转化" class="headerlink" title="使用单位脉冲转化"></a>使用单位脉冲转化</h3><p><img src="/image-4.png" alt="Alt text"></p>
<p>(这个应该算是相当简单和显然的)</p>
<h2 id="离散时间系统的性质"><a href="#离散时间系统的性质" class="headerlink" title="离散时间系统的性质"></a>离散时间系统的性质</h2><ol>
<li>线性性</li>
<li>具有时间平移对称性$x(n-n_0)-&gt;y(n-n_0)$</li>
</ol>
<h3 id="一般表达-卷积和"><a href="#一般表达-卷积和" class="headerlink" title="一般表达(卷积和)"></a>一般表达(卷积和)</h3><p>对于$x(n)&#x3D;\sum x(k)\delta (n-k)$在经过一个系统后,我们可以得到其相应$y(n)&#x3D;\sum y(k)\rho (n-k)$,其中$rho$为脉冲响应</p>
<blockquote>
<p>这可以用卷积的方式来理解这个性质(我们可以把$x$和$\delta$地位互换)</p>
</blockquote>
<h3 id="卷积和的计算"><a href="#卷积和的计算" class="headerlink" title="卷积和的计算"></a>卷积和的计算</h3><p><img src="/image-5.png" alt="卷积和"></p>
<blockquote>
<p>卷积和来源于线性性和时间平移不变性</p>
</blockquote>
<h2 id="稳定性与相关性"><a href="#稳定性与相关性" class="headerlink" title="稳定性与相关性"></a>稳定性与相关性</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果系统的输入是有界的,那么系统的输出是有界</p>
<p>例如我们可以判断一组基是不是有界的$(\frac{1}{2})^nh(n)$就是有界的,但很显然$2^nh(n)$不是</p>
<blockquote>
<p>判断一个系统的稳定性有一个充要条件:单位冲激响应$h(n)$是<strong>绝对可和的</strong></p>
</blockquote>
<h3 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h3><p>一个系统的响应应当<strong>只和之前的输入有关</strong></p>
<blockquote>
<p>这意味着系统不会预测系统的未来输入</p>
</blockquote>
<h2 id="线性常系数差分方程"><a href="#线性常系数差分方程" class="headerlink" title="线性常系数差分方程"></a>线性常系数差分方程</h2><p>输入$x(n)$和输出$y(n)$满足$n$阶线性常系数差分方程可以被表示为<br>$$\sum_{k&#x3D;0}^{N}a_ky(n-k)&#x3D;\sum_{r&#x3D;0}^Mb_rx(n-r)$$</p>
<h3 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h3><p>对于零阶方程,$b_r$系数的确定可以看作是脉冲响应</p>
<p>而对于非零阶的方程,那么我们可以将方程写作如下形式<br><img src="/image-6.png" alt="Alt text"></p>
<p>那么我们可以利用<strong>输入</strong>和<strong>过去的输出</strong>实现对于当前输出的预测(这个时候需要边界条件)</p>
<p>例如,下面一个一阶差分方程展示出一个如何求脉冲响应的例子<br><img src="/image-7.png" alt="Alt text"><br><img src="/image-8.png" alt="Alt text"></p>
<blockquote>
<p>需要根据边界条件合理地选择差分方程方向</p>
</blockquote>
<blockquote>
<p>注意,<strong>不是每个差分方程(包含边界条件)都对应线性和时间平移不变的系统</strong>(似乎一般需要满足边界条件齐次)</p>
</blockquote>
<h2 id="系统的频率响应"><a href="#系统的频率响应" class="headerlink" title="系统的频率响应"></a>系统的频率响应</h2><h3 id="复指数的特点"><a href="#复指数的特点" class="headerlink" title="复指数的特点"></a>复指数的特点</h3><p>复指数函数是<strong>特性函数</strong>,也就是说,如果输入是一个复指数,那么输出是输入乘上一个系数的结果(其中实数部分表示振幅,复数部分表示相位)</p>
<p>因此,对于输入为$x(n)&#x3D;e^{j\omega n}$,我们可以有输出<br>$$y(n)&#x3D;H(e^{j\omega n})e$$</p>
<p>相似地,我们可以将任意一个正弦或余弦函数转化成复指数运算</p>
<blockquote>
<p>如果使用上一部分的差分方程的例子研究频率响应,我们可以得到一个幅频响应呈现周期变化的系统</p>
</blockquote>
<h3 id="频率响应的重要性质"><a href="#频率响应的重要性质" class="headerlink" title="频率响应的重要性质"></a>频率响应的重要性质</h3><ol>
<li>频率响应的自变量是<strong>连续的</strong></li>
<li>频率响应是$\omega$的周期函数,周期为$2\pi$(注意,这里的自变量是$n$)</li>
</ol>
<h2 id="离散时间系统的傅里叶变换"><a href="#离散时间系统的傅里叶变换" class="headerlink" title="离散时间系统的傅里叶变换"></a>离散时间系统的傅里叶变换</h2><blockquote>
<p>之前我们讨论过系统的频率响应,我们知道对于一个复指数的输入,输出也可以被表示为复指数.我们现在要研究如何从频率响应得到冲激响应<br>如果我们分析$H(e^{j\omega})$的性质,我们会发现其作为一个<strong>周期函数</strong>,可以有<strong>傅里叶级数展开</strong>,由于其周期为$2\pi$,我们可以得到<br>$$H(\omega)&#x3D;\sum_{n&#x3D;-\infin}^{\infin}h(n)e^{-\omega n}$$<br>通过比较,我们可以发现此时的$h(n)$<strong>就是系统冲激响应</strong>,因此我们可以得到一个结论:<br>系统的冲激响应和频率响应构成傅里叶变换对</p>
</blockquote>
<h3 id="任意信号的傅里叶变换"><a href="#任意信号的傅里叶变换" class="headerlink" title="任意信号的傅里叶变换"></a>任意信号的傅里叶变换</h3><p>$$X(\omega)&#x3D;\sum_{n&#x3D;-\infin}^{n&#x3D;\infin}x(n)e^{-j\omega n}$$<br>$$x(n)&#x3D;\frac{1}{2\pi}\int_{-\pi}^{\pi}X(\omega)e^{j\omega n}d\omega$$</p>
<blockquote>
<p>这里和一般的傅里叶级数的关系可以看作是”反过来”的,离散的是时域,连续且周期变化的是频域</p>
</blockquote>
<h3 id="卷积特性"><a href="#卷积特性" class="headerlink" title="卷积特性"></a>卷积特性</h3><p>$$x(n)*y(n)\lrArr X(\omega)Y(\omega)$$<br>这个似乎和连续的卷积相似</p>
<h4 id="一种更具有启发性的观点"><a href="#一种更具有启发性的观点" class="headerlink" title="一种更具有启发性的观点"></a>一种更具有启发性的观点</h4><p>对于一个系统,我们有频域转换$e^{j\omega n}\rArr H(\omega)e^{j\omega n}$</p>
<p>那么我们可以有<br>$$\int X(\omega)e^{j\omega n}\rArr \int A(\omega)H(e^{j\omega})e^{j\omega n}d\omega$$</p>
<p>等式左边是输入信号$x(n)$,等式右边则为输出信号$y(n)$</p>
<p>对于某一特定的频率信号,我们是乘积关系<br>对于冲激响应,我们是卷积关系<br><strong>两者可以使用傅里叶变换联合在一起</strong></p>
<h3 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h3><p>对于$x(n)$为实信号的情况,我们可以得到$X(\omega)&#x3D;X^*(-\omega)$</p>
<p>进一步,我们可以将$X$分解为实部与虚部$X&#x3D;X_R+jX_I$<br>那么我们可以有对于实信号,有<br>$$X_R(\omega)&#x3D;X_R(-\omega),X_I(\omega)&#x3D;X_R(-\omega)$$<br>实部为偶函数,虚部为奇函数,相似的,对于傅里叶变换的模关于$\omega$为偶函数,辐角为奇函数</p>
<h3 id="与连续时间傅里叶变换的关系"><a href="#与连续时间傅里叶变换的关系" class="headerlink" title="与连续时间傅里叶变换的关系"></a>与连续时间傅里叶变换的关系</h3><p><img src="/image-10.png" alt="Alt text"><br>将时间$t$转换为$n$,我们可以得到对应于离散时间变量$n$,其所对应的$t$为$nT$,其中$T$为两个采样点之间的距离,图上展示了不同采样间隔下的波形的形状</p>
<p>我们可以考虑具有傅里叶变换的模拟信号<br>$$x_\alpha (t)&#x3D;\frac{1}{2\pi}\int_{-\infty}^{\infty}X_\alpha(j\Omega)e^{j\Omega t}d\Omega$$</p>
<blockquote>
<p>这里为了和离散时间的傅里叶变换相契合,我们把变换和反变换颠倒了一下</p>
</blockquote>
<h4 id="从连续到冲激的转换"><a href="#从连续到冲激的转换" class="headerlink" title="从连续到冲激的转换"></a>从连续到冲激的转换</h4><p>我们可以将转换看作为<strong>冲激的叠加</strong>  </p>
<p>$$x’<em>A&#x3D;\sum</em>{-\infty}^{\infty} x_A(nT)\delta(t-nT)$$</p>
<blockquote>
<p>这里的做法比较类似于将卷积得到的结果和直接傅里叶变换得到的结果之间进行比较</p>
</blockquote>
<p>这里最左边部分需要使用到<strong>泊松求和方程</strong><br>$$\sum_{n&#x3D;-\infty}^{\infty}f(n)&#x3D;\sum_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(x)e^{-2\pi jkx}$$</p>
<p><img src="/image-11.png" alt="Alt text"></p>
<blockquote>
<p>注意最后一个式子,这里可以得到离散傅里叶变换的频率谱与连续傅里叶变换谱的关系,并且包含了由于采样所带来的周期性(<strong>采样定理</strong>)</p>
</blockquote>
<p><img src="/image-12.png" alt="Alt text"></p>
<h4 id="实际应用时的注意事项"><a href="#实际应用时的注意事项" class="headerlink" title="实际应用时的注意事项"></a>实际应用时的注意事项</h4><ol>
<li>考虑一个数字滤波器的效果时,需要将一个模拟输入(频率轴下)进行抽样,然后经过数字滤波器的效果,最后再恢复(低通滤波)</li>
<li>在一些非关联的系统(许多非实时系统)中,可以构造数字滤波器使得<strong>原有滤波器不再产生相位变化</strong></li>
</ol>
]]></content>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>离散傅里叶级数与离散傅里叶变换</title>
    <url>/2023/07/14/digital_and_FPGA/digital3/</url>
    <content><![CDATA[<h1 id="离散傅里叶级数"><a href="#离散傅里叶级数" class="headerlink" title="离散傅里叶级数"></a>离散傅里叶级数</h1><blockquote>
<p>对于大部分情况,傅里叶变换和z变换是初等的变换,但是必须要<strong>处理无限长的情况</strong>,这在实际情况中不太现实<br>离散傅里叶变换有着与傅里叶变换相似的性质,但是也有着<strong>显著的区别</strong>,但是在实际的应用中会<strong>直接使用到离散傅里叶变换</strong><br>其主要思想是:<strong>使用傅里叶变换的采样来描述一段有限长的序列</strong></p>
</blockquote>
<h2 id="使用周期序列介绍离散傅里叶级数"><a href="#使用周期序列介绍离散傅里叶级数" class="headerlink" title="使用周期序列介绍离散傅里叶级数"></a>使用周期序列介绍离散傅里叶级数</h2><p>首先考虑一个有限长的$x(n)$序列,总长度为$N$</p>
<blockquote>
<p>这里是至小于0或者大于$N-1$的序列值<strong>均为0</strong><br><img src="/2023/07/14/digital_and_FPGA/digital3/image.png" alt="Alt text"><br>我们可以<strong>周期延拓</strong>这个序列,得到$x’(n)&#x3D;x(n)+x(N+n)+…$<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-1.png" alt="Alt text"><br>我们可以在有限长度序列和周期序列之间相互转换<br>这里的效果就像把输入序列放在油漆刷上,然后一遍遍涂出来的效果</p>
</blockquote>
<p>将周期序列乘上一个矩形门就可以得到原始的序列</p>
<p>做这个延拓的意义在于:既然在连续的情况下,周期序列有傅里叶级数表示,<strong>离散也应当类似</strong>,于是可以得到离散傅里叶变换(DFT)的定义:<br>$x’$的离散傅里叶级数<strong>就是</strong>$x$的离散傅里叶变换</p>
<p>$$x’(n)&#x3D;\sum X’(k)e^{j\frac{2\pi}{N}nk}$$<br>其中$X’(k)$是展开系数($k$与$n$都是离散的)  </p>
<h2 id="离散傅里叶级数的特性"><a href="#离散傅里叶级数的特性" class="headerlink" title="离散傅里叶级数的特性"></a>离散傅里叶级数的特性</h2><p>我们可以注意到不仅仅$n$是周期的,$k$也应当是周期变化的<br>所以我们可以得到一个求和区间$\sum_{k&#x3D;0}^{N-1}$<br>我们同样也可以用一个关系得到其系数的计算<br>$$X’(k)&#x3D;\sum_{n&#x3D;0}^{N-1}x(n)e^{-j\frac{2\pi}{N}nk}$$<br>这里的$k$是有有限多个值,相应的$X’(k)$也是有有限多个值</p>
<blockquote>
<p>$x(n)$是周期的,相应的$X(k)$也是周期的</p>
</blockquote>
<p>为了简化表示,我们可以记$w_m&#x3D;e^{-j2\pi&#x2F;N}$,那么原来的式子就可以被表示为<br>$$x’(n)&#x3D;\frac{1}{N}\sum X’(k)w_N^{-nk}$$<br>$$X’(k)&#x3D;\sum x’(n)w_N^{nk}$$</p>
<h2 id="离散傅里叶变换的特性"><a href="#离散傅里叶变换的特性" class="headerlink" title="离散傅里叶变换的特性"></a>离散傅里叶变换的特性</h2><blockquote>
<p>在时域上的特性,我们也会在频域上找到,这是离散傅里叶变换<strong>特别的特性</strong></p>
</blockquote>
<h3 id="频移"><a href="#频移" class="headerlink" title="频移"></a>频移</h3><p>$$x(n+m)\lrArr w_N^{km}X(k)$$<br>$$w_N^{ln}x(n)\lrArr X(k+l)$$</p>
<h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><p>这个和傅里叶变换的结果相似,在这里不再介绍</p>
<h3 id="卷积性质"><a href="#卷积性质" class="headerlink" title="卷积性质"></a>卷积性质</h3><p><img src="/2023/07/14/digital_and_FPGA/digital3/image-2.png" alt="Alt text"><br>下图可以看到卷积性质的应用<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-3.png" alt="Alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在这里可以仅仅通过<strong>有限多</strong>的频率信息得到有限长度序列的信息</p>
<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>我们之前讨论了循环序列的离散傅里叶级数,(用有限多个数表示)<br>$$x’(n)&#x3D;x(n mod N)&#x3D;x((n))_N$$</p>
<blockquote>
<p>我们这里使用余数来描述沿伸的信号<br>其中离散傅里叶级数表示为<br>$$X’(k)&#x3D;\sum_{n&#x3D;0}^{N-1}x’(n)w_N^{nk}$$<br>$$x’(n)&#x3D;\frac{1}{N}\sum X’(k)w_N^{-nk}$$</p>
</blockquote>
<h3 id="离散傅里叶变换-1"><a href="#离散傅里叶变换-1" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>我们令$X(k)&#x3D;\sum_{n&#x3D;0}^{N-1}x(n)w_n^{nk}$($k&#x3D;0,1,…,N-1$)</p>
<blockquote>
<p>这样我们就同样拥有一个<strong>有限长的傅里叶变换</strong></p>
</blockquote>
<blockquote>
<p>我们可以看出来这里的离散傅里叶变换结果和信号序列的效果几乎完全一样</p>
</blockquote>
<p>同样也有$X(k)&#x3D;X’(k)Q_N(k)$,$X’(k)&#x3D;X((k))_N$<br>因此我们可以得到离散傅里叶变换的关系<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-4.png" alt="Alt text">  </p>
<blockquote>
<p>相应的,对于z变换,DFT可以视作为z变换的一种<strong>采样</strong></p>
</blockquote>
<h3 id="离散傅里叶变换性质"><a href="#离散傅里叶变换性质" class="headerlink" title="离散傅里叶变换性质"></a>离散傅里叶变换性质</h3><blockquote>
<p>这里我们主要注意到离散变换和连续变换之间的区别(始终记住作用是针对<strong>周期信号而言</strong>的)</p>
</blockquote>
<h4 id="平移性质"><a href="#平移性质" class="headerlink" title="平移性质"></a>平移性质</h4><p><img src="/2023/07/14/digital_and_FPGA/digital3/image-6.png" alt="Alt text"></p>
<p>我们需要注意,这里的平移<strong>不是简单的$n$移动</strong>,而是像如图所示的那样<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-7.png" alt="Alt text">  </p>
<blockquote>
<p>这里是把后面的移动到了前面来(就像之前所说的”圆柱体”一样)</p>
</blockquote>
<h4 id="对称性-1"><a href="#对称性-1" class="headerlink" title="对称性"></a>对称性</h4><p>这个性质讨论的是有关于实信号的结果<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-8.png" alt="Alt text"></p>
<blockquote>
<p>这里的变换在运算时<strong>需要转化为周期的级数来处理</strong><br>下图展示了这一性质的效果<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-9.png" alt="Alt text"></p>
</blockquote>
<h4 id="卷积性质-1"><a href="#卷积性质-1" class="headerlink" title="卷积性质"></a>卷积性质</h4><p><img src="/2023/07/14/digital_and_FPGA/digital3/image-10.png" alt="Alt text">  </p>
<blockquote>
<p>这里需要注意到<strong>卷积的原始定义发生了变化</strong></p>
</blockquote>
<blockquote>
<p>不过实际上循环卷积非常丰富,其主要的意义将在后面一节阐明<br>下图展示了循环卷积的一个例子<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-11.png" alt="Alt text"></p>
</blockquote>
<h2 id="环路卷积"><a href="#环路卷积" class="headerlink" title="环路卷积"></a>环路卷积</h2><blockquote>
<p>由于FFT的存在,因此卷积实际上非常的方便</p>
</blockquote>
<h3 id="卷积性质的复习"><a href="#卷积性质的复习" class="headerlink" title="卷积性质的复习"></a>卷积性质的复习</h3><p><img src="/2023/07/14/digital_and_FPGA/digital3/image-12.png" alt="Alt text"></p>
<blockquote>
<p>注意,首先要把序列变成重复序列(或者用取模序列)<br>最后一个式子可以理解为将$x_2$与一个<strong>周期脉冲</strong>相互卷积,然后再和$x_1$卷积<br>就像这张图中所展示的一样<img src="/2023/07/14/digital_and_FPGA/digital3/image-14.png" alt="Alt text"></p>
</blockquote>
<p>下图则展示了像这样的操作是如何被计算出来的<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-13.png" alt="Alt text"></p>
<h3 id="有关卷积的有趣的解释"><a href="#有关卷积的有趣的解释" class="headerlink" title="有关卷积的有趣的解释"></a>有关卷积的有趣的解释</h3><p>如果我们看如下所示的两个系统<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-15.png" alt="Alt text"><br>这意味着我们可以首先用<strong>两段信号相应的线性卷积</strong>通过一个<strong>单位相应是间隔为$N$的脉冲序列</strong>得到<strong>两段信号的环路卷积</strong></p>
<p>我们可以得到一个重要的结论<br><strong>环路卷积可以被视作线性卷积与混叠共同作用的结果</strong><br>如果将$x’<em>3(n)$看作为线性卷积,那么我们可以有关系<br>$$x_3(n)&#x3D;[\sum</em>{r}x’_3(n+rN)]R_N(n)$$</p>
<blockquote>
<p>注意一下,这里的形式和<strong>离散傅里叶变换</strong>有着异曲同工之处</p>
</blockquote>
<h4 id="一些例子以及如何从循环卷积得到线性卷积"><a href="#一些例子以及如何从循环卷积得到线性卷积" class="headerlink" title="一些例子以及如何从循环卷积得到线性卷积"></a>一些例子以及如何从循环卷积得到线性卷积</h4><p><img src="/2023/07/14/digital_and_FPGA/digital3/image-16.png" alt="Alt text"><br>如果我们将周期变成$2N$,那么又会有什么样的变化<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-17.png" alt="Alt text">  </p>
<blockquote>
<p>可以注意到,混叠的效果消失了<br>如果我们在处理信号的时候,我们就需要<strong>避免循环卷积</strong>,所以需要多一段0(总的处理点数应该是<strong>信号点数加上单位响应</strong>)</p>
</blockquote>
<h3 id="信号的分段"><a href="#信号的分段" class="headerlink" title="信号的分段"></a>信号的分段</h3><p>目前我们所讨论的问题针对与滤波器<strong>已经知道整个序列的前提之下</strong>,但是实际上,这种情况<strong>很难实现</strong></p>
<p>以下面一个例子为例,我们可以将输入的信号<strong>分成$L$为段的信号</strong><br><img src="/2023/07/14/digital_and_FPGA/digital3/image-18.png" alt="Alt text"><br>经过转化后,我们有这样几段信号<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-19.png" alt="Alt text"><br>经过卷积(这里虽然是循环卷积,但由于填的0足够长,所以就是线性卷积),我们可以得到以下结果<br><img src="/2023/07/14/digital_and_FPGA/digital3/image-20.png" alt="Alt text"><br>最后将其叠加到一起即可</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>由于我们将会有非常高效的方法进行DFT(FFT),所以一般信号处理所使用的卷积可以使用DFT来处理</p>
<p>然而,由于DFT的卷积定理是使用<strong>环路卷积</strong>实现的,所以我们需要填0来实现<strong>线性卷积</strong>的表示</p>
]]></content>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>z变换</title>
    <url>/2023/07/10/digital_and_FPGA/digital2/</url>
    <content><![CDATA[<h1 id="z变换"><a href="#z变换" class="headerlink" title="z变换"></a>z变换</h1><h2 id="离散时间傅里叶变换的局限性与z变换介绍"><a href="#离散时间傅里叶变换的局限性与z变换介绍" class="headerlink" title="离散时间傅里叶变换的局限性与z变换介绍"></a>离散时间傅里叶变换的局限性与z变换介绍</h2><p>傅里叶变换对于一部分序列<strong>并不收敛</strong><br>例如$X(\omega)&#x3D;\sum x(n)e^{-j\omega n}$我们需要其收敛,需要判断其条件</p>
<p>可以使用三角不等式,最终会得到前者收敛的条件为$\sum |x(n)|&lt;\infty$(绝对可和)</p>
<blockquote>
<p>我们之前所讨论的<strong>稳定性</strong>,可以得到一个稳定系统中的$H(\omega)$是绝对可和的</p>
</blockquote>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>对于$x(n)&#x3D;2^nu(n)$,我们能够注意到$\sum x(n)&#x3D;\infty$,因此傅里叶变换<strong>不收敛</strong></p>
<blockquote>
<p>根据一个非常常用的结论,假如我们有一个(模)指数下降的序列,那么其<strong>傅里叶变换</strong>必然收敛<br>因此我们可以采用类似于处理拉普拉斯变换的方法,乘以一个指数下降的数列</p>
</blockquote>
<p>如果我们选取一个$r&gt;2$,那么我们能够得到一个收敛的序列$x(n)r^{-n}$</p>
<h2 id="z变换定义"><a href="#z变换定义" class="headerlink" title="z变换定义"></a>z变换定义</h2><p>$$X(z)&#x3D;\sum x(n)z^{-n}$$<br>与傅里叶变换的联系之处在于<br>$$X(\omega)&#x3D;X(z)|_{z&#x3D;e^{j\omega}}$$</p>
<p>对于某些$r$值,z变换会收敛,对于某些$r$值,其并不会收敛</p>
<h3 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h3><blockquote>
<p>这里视频中有许多,但我认为只需要将整个模长保持在<strong>小于1</strong>的部分,那么我们就可以绘制出一个<strong>收敛圆</strong><br>特别地,如果收敛圆包含了单位圆,那么我们可以知道这个序列的<strong>离散傅里叶变换也是收敛的</strong></p>
</blockquote>
<blockquote>
<p>同时,我们也要注意到,对于不同的$u(n)$情况,会有不同的收敛域</p>
</blockquote>
<blockquote>
<p>在这里讨论的极点是<strong>使用求和公式求出来的结果</strong>,而对于不同的条件下,其可能是零点,也有可能是极点</p>
</blockquote>
<p><img src="/2023/07/10/digital_and_FPGA/digital2/image.png" alt="Alt text"></p>
<h3 id="收敛域的一些性质"><a href="#收敛域的一些性质" class="headerlink" title="收敛域的一些性质"></a>收敛域的一些性质</h3><ol>
<li>收敛的范围总是被限制在极点和(0&#x2F;$\infty$)</li>
<li>对于有限长的序列,收敛域为$0&lt;|z|&lt;\infty$</li>
<li>右侧序列($n$有下界),那么$|z|$有下界</li>
<li>左侧序列($n$有上界),那么$|z|$有上界</li>
<li>两侧序列($n$无界),那么有$R_{x-}&lt;|z|&lt;R_{x+}$</li>
</ol>
<p>下面展示了一个判断傅里叶变换是否存在的例子</p>
<p><img src="/2023/07/10/digital_and_FPGA/digital2/image-1.png" alt="Alt text"></p>
<p>而对于两侧序列的判定,我们可以参考<br>$$(\frac{1}{2})^{|n|}$$<br>其可以被视作两侧序列,而$|z|$的收敛范围是$(\frac{1}{2},2)$</p>
<h2 id="z变换的性质"><a href="#z变换的性质" class="headerlink" title="z变换的性质"></a>z变换的性质</h2><p>我们仍然可以得到一些像卷积定理的内容<br>$$y(n)&#x3D;x(n)*h(n)$$<br>$$Y(z)&#x3D;X(z)H(z)$$</p>
<p>我们也可以通过$z$变换的过程得到信号序列的一些性质</p>
<ol>
<li>如果信号序列是<strong>稳定的</strong>,那么单位圆必然在收敛域中</li>
<li>如果信号序列是<strong>关联的</strong>,那么必然是一个右侧序列</li>
</ol>
<h3 id="使用线性差分方程表示的例子"><a href="#使用线性差分方程表示的例子" class="headerlink" title="使用线性差分方程表示的例子"></a>使用线性差分方程表示的例子</h3><p>$$y(n)-\frac{1}{2}y(n-1)&#x3D;x(n)$$<br>我们需要使用一些好用的性质<br>$$y(n)\lrArr Y(z)$$<br>$$y(n+n_0)\lrArr z^{n_0}Y(z)$$<br>我们可以得到一个代数方程,得到<br>$$H(z)&#x3D;\frac{1}{1-\frac{1}{2}z^{-1}}$$</p>
<blockquote>
<p>这里和那拉普拉斯变换解微分方程如出一辙</p>
</blockquote>
<blockquote>
<p>同时我们需要注意到,这里的收敛域会随着序列中$n$条件的变化而变化(如图所示)<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-2.png" alt="Alt text"></p>
</blockquote>
<h1 id="z反变换"><a href="#z反变换" class="headerlink" title="z反变换"></a>z反变换</h1><p>$$X(z)&#x3D;\sum x(n)z^{-n}$$<br>z反变换可以从$X(z)$得到$x(n)$</p>
<h2 id="直接观察法"><a href="#直接观察法" class="headerlink" title="直接观察法"></a>直接观察法</h2><p>例如<br>$$a^nu(n)\lrArr \frac{1}{1-az^{-1}}$$<br>这样的序列,我们可以直接从z反变换的结果反推出原本的过程</p>
<blockquote>
<p>注意,这里需要讨论$|z|$的范围(改变$n$的范围)</p>
</blockquote>
<h2 id="暴力展开"><a href="#暴力展开" class="headerlink" title="暴力展开"></a>暴力展开</h2><p>例如对于$X(z)&#x3D;\frac{1}{1-az^{-1}}$的反变换,我们可以有<strong>这个式子的展开</strong><br><img src="/2023/07/10/digital_and_FPGA/digital2/image-3.png" alt="Alt text"></p>
<blockquote>
<p>我们可以看到,这里对应于$n&gt;0$或者$n&lt;0$的情况,两者有着不同的展开<br>但是这种方法我们<strong>只能得到一系列的式子</strong>,我们还要将其综合起来</p>
</blockquote>
<h2 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h2><p>考虑一个一般有理函数<br>$$F(x)&#x3D;\frac{P(x)}{Q(x)}&#x3D;\sum\frac{R_k}{x-x_k}$$<br>其中$x_k$为$Q$的零点,而$R_k$为留数</p>
<blockquote>
<p>为了讨论方便,我们假定分母次数更高,并且没有重根<br>这里使用了一些留数定理的内容</p>
</blockquote>
<p>可以使用两种不同的方法(视作$z$和$z^{-1}$)<br>下面展示了一个例子<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-4.png" alt="Alt text"><br><img src="/2023/07/10/digital_and_FPGA/digital2/image-5.png" alt="Alt text"></p>
<blockquote>
<p>但是这种方法只适用于分式的情况,因此不能广泛地使用(但是在讨论一些性质的时候非常有用)</p>
</blockquote>
<h2 id="路径积分法"><a href="#路径积分法" class="headerlink" title="路径积分法"></a>路径积分法</h2><p>我们直接给出结论<br>$$x(n)&#x3D;\frac{1}{2\pi j}\int_C X(z)z^{n-1}dz$$<br>($C$环路为包含原点的边缘在收敛域内的环路)</p>
<blockquote>
<p>这个公式的证明实际上来自于$n$阶导的柯西公式</p>
</blockquote>
<blockquote>
<p>在实际计算的时候需要使用留数定理计算($X(z)z^{n-1}$)的留数</p>
</blockquote>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>我们以$X(z)&#x3D;\frac{1}{1-\frac{1}{2}z^{-1}}$<br>其具体的做法如下<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-6.png" alt="Alt text">  </p>
<blockquote>
<p>可以看出来,对于$n&gt;0$的情况,计算要显得方便的很多,但是$n&lt;0$的话,可以考虑使用变量代换的方式计算<br>不过我觉得直接继续用留数定理的公式还是方便的</p>
</blockquote>
<h2 id="一些结论以及重要的注意事项"><a href="#一些结论以及重要的注意事项" class="headerlink" title="一些结论以及重要的注意事项"></a>一些结论以及重要的注意事项</h2><ol>
<li>我们讨论的时候强调<strong>上面的次数要小于下面的次数</strong>,这里体现出<strong>关联性</strong>(否则就会有$z$的正数次项留出来)</li>
<li>对于前面讨论的着一种情况,我们需要小心在环路积分之余,可能<strong>会有单独留出来的项</strong></li>
<li>展开的时候经常会犯迷糊,记得把式子展开为$a_nz^{-n}$的形式,其中注意$z$的符号</li>
</ol>
<h1 id="z变换的相关性质"><a href="#z变换的相关性质" class="headerlink" title="z变换的相关性质"></a>z变换的相关性质</h1><h2 id="频率响应的几何意义"><a href="#频率响应的几何意义" class="headerlink" title="频率响应的几何意义"></a>频率响应的几何意义</h2><h3 id="卷积性质"><a href="#卷积性质" class="headerlink" title="卷积性质"></a>卷积性质</h3><p>对于$y(n)&#x3D;x(n)*h(z)$,我们可以得到z变换$X(z)H(z)&#x3D;Y(z)$</p>
<p>同时,我们也可以得到,<strong>在单位圆上的z变换就是傅里叶变换</strong></p>
<p>作为一个例子,我们请出我们的老朋友$H(z)&#x3D;\frac{z}{z-a}$,<br>进一步,可以把$z$看作矢量,这样就可以看作是<strong>从零点出来的矢量除以从极点出来的矢量</strong><br>相应的,模长就是两者相除,辐角就是两者相减<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-7.png" alt="Alt text"><br><img src="/2023/07/10/digital_and_FPGA/digital2/image-8.png" alt="Alt text">  </p>
<p>接下来,我们考虑$z$是在单位圆上的矢量,那么$z$的<strong>模长不再改变</strong></p>
<p>在整个$z$旋转的时候,$z-a$的模长<strong>先增加后减小</strong><br>这样我们就可以简单地得到频率响应<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-9.png" alt="Alt text">  </p>
<h3 id="一般讨论"><a href="#一般讨论" class="headerlink" title="一般讨论"></a>一般讨论</h3><p>对于频率响应$|H(e^{j\omega})|&#x3D;\frac{\Pi length zero}{\Pi length pole}$,<br>对于相位相应,则有<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-10.png" alt="Alt text"></p>
<blockquote>
<p>这意味着我们可以仅仅知道所有的极点和零点,就可以大致知道频率响应和相位谱<br>如果有多重极点的情况,可以当成多个极点计算</p>
</blockquote>
<h2 id="变换性质"><a href="#变换性质" class="headerlink" title="变换性质"></a>变换性质</h2><h3 id="一般变换性质-可以和连续状况类比"><a href="#一般变换性质-可以和连续状况类比" class="headerlink" title="一般变换性质(可以和连续状况类比)"></a>一般变换性质(可以和连续状况类比)</h3><p>下面列举出了<strong>最为有用的</strong>一些性质<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-11.png" alt="Alt text">   </p>
<h3 id="变换性质与几何性质"><a href="#变换性质与几何性质" class="headerlink" title="变换性质与几何性质"></a>变换性质与几何性质</h3><p>以第四个性质为例,我们可以考虑<strong>极点与零点</strong>,会得到原本的$z-z_0$变成了$a^{-1}(z-az_0)$</p>
<blockquote>
<p>如果$a$是实数,那么极点(零点)会在轴上移动,如果是复数,那么就同时会改变角度</p>
</blockquote>
<h3 id="性质在Boxcar序列中的应用"><a href="#性质在Boxcar序列中的应用" class="headerlink" title="性质在Boxcar序列中的应用"></a>性质在Boxcar序列中的应用</h3><h4 id="Boxcar序列"><a href="#Boxcar序列" class="headerlink" title="Boxcar序列"></a>Boxcar序列</h4><p>$$x(n)&#x3D;1 (0\le n\le (N-1)$$<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-12.png" alt="Alt text"><br>我们可以将Boxcar序列视作为两个阶梯序列相减$x(n)&#x3D;u(n)-u(n-N)$</p>
<h4 id="Boxcar的z变换"><a href="#Boxcar的z变换" class="headerlink" title="Boxcar的z变换"></a>Boxcar的z变换</h4><p>使用上面的观点,可以得到<br>$$X(z)&#x3D;\frac{1}{1-z^{-1}}-\frac{z^{-N}}{1-z^{-1}}&#x3D;\frac{z^N-1}{z^{N-1}(z-1)}$$</p>
<p>接下来,我们可以注意到整个系统在单位圆上有一个极点,在原点有$N-1$个零点<br>而对于零点,则是相当于在单位圆上均匀分布的点</p>
<blockquote>
<p>这里需要注意到,一个零点和一个极点约掉了<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-13.png" alt="Alt text">  </p>
</blockquote>
<h4 id="Boxcar的频率相应"><a href="#Boxcar的频率相应" class="headerlink" title="Boxcar的频率相应"></a>Boxcar的频率相应</h4><p>分母上不构成影响,所以只需要讨论零点伸出来的矢量的影响(越靠近那个确实的零点,<strong>整体的模长值越大</strong>)<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-14.png" alt="Alt text">  </p>
<p>或者直接使用计算法,可以得到<br>$$X(\omega)&#x3D;\frac{1-e^{-j\omega N}}{1-e^{-j\omega}}$$<br>通过化简,可以得到<br>$$e^{j\omega\frac{N-1}{2}}\frac{\omega \frac{N}{2}}{\frac{N}{2}}$$</p>
<p>而我们展示其图象<br><img src="/2023/07/10/digital_and_FPGA/digital2/image-15.png" alt="Alt text"></p>
<blockquote>
<p>可以看出,我们的估计还算是相当不错的</p>
</blockquote>
]]></content>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA编程与仿真注意</title>
    <url>/2023/07/07/digital_and_FPGA/FPGA_Notice/</url>
    <content><![CDATA[<p>最近在学习基于<code>DE10-Nano</code>的FPGA程序设计,这个过程有相对比较复杂的环境配置和一些容易犯的错误,在这里记录一下</p>
<h1 id="环境的配置与操作流程"><a href="#环境的配置与操作流程" class="headerlink" title="环境的配置与操作流程"></a>环境的配置与操作流程</h1><ol>
<li><code>DE10-Nano</code>所使用的FPGA的编号为<code>Cyclone V 5CSEBA6U23I7</code>,在配置<code>Quartus</code>的时候可以方便一点</li>
<li>包含有仿真的项目,首先<strong>指定仿真工具使用<code>ModelSim</code></strong>;在主程序基本完成后(记得编译),自动生成<code>TestBranch</code>脚本;最后将其加入到仿真设定中</li>
<li>每次编译后都要重新生成<code>TestBranch</code>,所以建议改一下文件名</li>
</ol>
<h1 id="Verilog编写注意"><a href="#Verilog编写注意" class="headerlink" title="Verilog编写注意"></a>Verilog编写注意</h1><ol>
<li><strong>不能在不同的<code>always</code>块中对同一个变量修改</strong></li>
<li>对于不同状态进行编码时,可以参考这张表<br><img src="/2023/07/07/digital_and_FPGA/FPGA_Notice/image-9.png" alt="Alt text"></li>
<li>非阻塞复制的操作计算<strong>是在时钟边沿到来之前的值</strong></li>
<li>如果一个<code>always</code>块对某个寄存器赋值,而另外一个<code>always</code>块判断这个寄存器的值,那么这个值对应于<strong>时钟沿到来前的值</strong>(类似于非阻塞赋值)<blockquote>
<p>此时需要正确使用非阻塞赋值,避免出现冲突</p>
</blockquote>
</li>
<li>在<strong>时序逻辑</strong>中,使用非阻塞赋值</li>
<li>注意在按钮摁下的过程<strong>会有非常多的时钟周期</strong><blockquote>
<p>例如每次摁下按钮,将某一个量加一,这个时候有两种解决方案,一个是使用按钮的上升沿触发,另外一种是使用系统时钟,处理<strong>按钮按下事件是否为第一次触发</strong></p>
</blockquote>
</li>
<li>例如复位”高电平触发”,是指<strong>当信号为高电平时,会发生复位</strong></li>
</ol>
<h1 id="ModelSim使用注意"><a href="#ModelSim使用注意" class="headerlink" title="ModelSim使用注意"></a>ModelSim使用注意</h1><ol>
<li>为了和系统时钟相匹配,需要记得修改时间尺度</li>
<li><code>TestBranch</code>的<code>always</code>块中**记得把<code>@allvec</code>删去,否则无法仿真</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
</search>
